**Objective:**
Update the existing Go application's `container` module to implement a robust, vendor-agnostic container management solution. The goal is to dynamically detect and use either a CRI-compliant runtime (like containerd/CRI-O) or the traditional Docker Engine. The existing API routes and `container.NewService` factory function must be preserved.

**Required Changes:**

**1. Modify the `container` Module's Structure**

  * **Create a `ContainerRuntimeExecutor` Interface:** Define a new Go interface within the `container` package. This interface will contain a method for each API route, abstracting the underlying runtime. The methods should return a consistent data structure for both CRI and Docker outputs.
      * `ListContainers(ctx context.Context) ([]ContainerInfo, error)`
      * `GetContainerDetails(ctx context.Context, id string) (*ContainerInfo, error)`
      * `CreateContainer(ctx context.Context, config ContainerConfig) (*ContainerInfo, error)`
      * `StartContainer(ctx context.Context, id string) error`
      * `StopContainer(ctx context.Context, id string) error`
      * `RestartContainer(ctx context.Context, id string) error`
      * `RemoveContainer(ctx context.Context, id string) error`
      * `GetContainerLogs(ctx context.Context, id string) (io.Reader, error)`
      * `ListImages(ctx context.Context) ([]ImageInfo, error)`
      * `GetImageDetails(ctx context.Context, id string) (*ImageInfo, error)`
      * `PullImage(ctx context.Context, name string) error`
      * `RemoveImage(ctx context.Context, id string) error`
  * **Define Consistent Data Structures:** Create new `struct` types like `ContainerInfo`, `ImageInfo`, and `ContainerConfig` to standardize the data returned by the executor. These structs will be populated from either the CRI or Docker SDK responses, providing a unified output for the API handlers.
  * **Create Concrete Executor Implementations:**
      * `CriExecutor`: A struct that implements the `ContainerRuntimeExecutor` interface using the `k8s.io/cri-api` client. It should hold a reference to the CRI client.
      * `DockerExecutor`: A struct that implements the `ContainerRuntimeExecutor` interface using the `github.com/docker/docker/client` SDK. It should hold a reference to the Docker client.

**2. Update the `container.NewService` Factory Function**

  * Modify `container.NewService(executor container.Executor)` to be `container.NewService() (*Service, error)`. The factory function itself will now be responsible for creating the executor.
  * Inside `NewService`, implement the following logic to create the correct executor:
    1.  **Attempt CRI Connection:**
          * Try to establish a gRPC connection to the `containerd` socket (`/run/containerd/containerd.sock`) and `CRI-O` socket (`/var/run/crio/crio.sock`).
          * If a connection is successful, create a `CriExecutor` instance, log the successful connection, and return a new `Service` with this executor.
    2.  **Attempt Docker Connection:**
          * If all CRI connection attempts fail, attempt to create a new `docker.Client`.
          * If successful, create a `DockerExecutor` instance, log the successful connection, and return a new `Service` with this executor.
    3.  **Return Error:** If all connection attempts fail, return a descriptive error indicating that no supported container runtime was found.

**3. Update Existing Service Methods (`ListContainers`, `ListImages`, etc.)**

  * The existing methods on the `Service` struct (e.g., `containerService.ListContainers`) should no longer have the logic to interact with the runtime directly.
  * They should now simply call the corresponding method on the `s.executor` field, which will be of type `ContainerRuntimeExecutor`. This makes the handlers completely agnostic to the underlying runtime.

**4. Update Main Application's Entry Point (`main.go` or similar)**

  * The call to `container.NewService` will now return an error. The main application's startup logic must be updated to handle this error. If `container.NewService()` returns an error, the application should log a fatal error and exit.

**Example `container/service.go` snippet (conceptual):**

```go
package container

import (
    "context"
    "io"

    "github.com/gin-gonic/gin"
)

// ContainerRuntimeExecutor is the interface for our vendor-agnostic runtime client.
type ContainerRuntimeExecutor interface {
    ListContainers(ctx context.Context) ([]ContainerInfo, error)
    GetContainerDetails(ctx context.Context, id string) (*ContainerInfo, error)
    // ... all other methods
}

// Service is the main struct for our container logic.
type Service struct {
    executor ContainerRuntimeExecutor
}

// NewService is the factory function that dynamically creates the correct executor.
func NewService() (*Service, error) {
    // ... (Implement the connection logic here) ...
    // ...
    // return &Service{executor: chosenExecutor}, nil
}

// ListContainers is the public handler that uses the executor.
func (s *Service) ListContainers(c *gin.Context) {
    containers, err := s.executor.ListContainers(c.Request.Context())
    // ... (Handle errors and return JSON) ...
}

// ... (Other handler methods follow the same pattern) ...
```

**Final Output:**
The AI agent should provide the updated code for the `container` module, including:

  * The new `ContainerRuntimeExecutor` interface.
  * The `CriExecutor` and `DockerExecutor` implementations.
  * The modified `container.NewService` factory function.
  * Modified handler methods within the `container.Service` to use the new interface.
  * A brief explanation of how the main application's `main.go` file would need to be changed to handle the error from `container.NewService()`.
  * All necessary Go package imports.