var qd = Object.defineProperty;
var Kd = (s, e, t) => e in s ? qd(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var K = (s, e, t) => Kd(s, typeof e != "symbol" ? e + "" : e, t);
import { i as Mi, a as ts, g as Qa, t as L, b as Ya } from "./index-CcHl5s_m.js";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Wr = globalThis, Go = Wr.ShadowRoot && (Wr.ShadyCSS === void 0 || Wr.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Xo = Symbol(), Ga = /* @__PURE__ */ new WeakMap();
let Fc = class {
  constructor(e, t, i) {
    if (this._$cssResult$ = !0, i !== Xo) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (Go && e === void 0) {
      const i = t !== void 0 && t.length === 1;
      i && (e = Ga.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && Ga.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const zc = (s) => new Fc(typeof s == "string" ? s : s + "", void 0, Xo), re = (s, ...e) => {
  const t = s.length === 1 ? s[0] : e.reduce((i, r, n) => i + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1], s[0]);
  return new Fc(t, s, Xo);
}, Qd = (s, e) => {
  if (Go) s.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else for (const t of e) {
    const i = document.createElement("style"), r = Wr.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = t.cssText, s.appendChild(i);
  }
}, Xa = Go ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const i of e.cssRules) t += i.cssText;
  return zc(t);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Yd, defineProperty: Gd, getOwnPropertyDescriptor: Xd, getOwnPropertyNames: Jd, getOwnPropertySymbols: Zd, getPrototypeOf: eu } = Object, ss = globalThis, Ja = ss.trustedTypes, tu = Ja ? Ja.emptyScript : "", Zn = ss.reactiveElementPolyfillSupport, zi = (s, e) => s, nn = { toAttribute(s, e) {
  switch (e) {
    case Boolean:
      s = s ? tu : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, e) {
  let t = s;
  switch (e) {
    case Boolean:
      t = s !== null;
      break;
    case Number:
      t = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(s);
      } catch {
        t = null;
      }
  }
  return t;
} }, Jo = (s, e) => !Yd(s, e), Za = { attribute: !0, type: String, converter: nn, reflect: !1, useDefault: !1, hasChanged: Jo };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), ss.litPropertyMetadata ?? (ss.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let Xs = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = Za) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0), this.elementProperties.set(e, t), !t.noAccessor) {
      const i = Symbol(), r = this.getPropertyDescriptor(e, i, t);
      r !== void 0 && Gd(this.prototype, e, r);
    }
  }
  static getPropertyDescriptor(e, t, i) {
    const { get: r, set: n } = Xd(this.prototype, e) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get: r, set(o) {
      const a = r == null ? void 0 : r.call(this);
      n == null || n.call(this, o), this.requestUpdate(e, a, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Za;
  }
  static _$Ei() {
    if (this.hasOwnProperty(zi("elementProperties"))) return;
    const e = eu(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(zi("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(zi("properties"))) {
      const t = this.properties, i = [...Jd(t), ...Zd(t)];
      for (const r of i) this.createProperty(r, t[r]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0) for (const [i, r] of t) this.elementProperties.set(i, r);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, i] of this.elementProperties) {
      const r = this._$Eu(t, i);
      r !== void 0 && this._$Eh.set(r, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const i = new Set(e.flat(1 / 0).reverse());
      for (const r of i) t.unshift(Xa(r));
    } else e !== void 0 && t.push(Xa(e));
    return t;
  }
  static _$Eu(e, t) {
    const i = t.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$EO) == null || t.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const i of t.keys()) this.hasOwnProperty(i) && (e.set(i, this[i]), delete this[i]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Qd(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((t) => {
      var i;
      return (i = t.hostConnected) == null ? void 0 : i.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((t) => {
      var i;
      return (i = t.hostDisconnected) == null ? void 0 : i.call(t);
    });
  }
  attributeChangedCallback(e, t, i) {
    this._$AK(e, i);
  }
  _$ET(e, t) {
    var n;
    const i = this.constructor.elementProperties.get(e), r = this.constructor._$Eu(e, i);
    if (r !== void 0 && i.reflect === !0) {
      const o = (((n = i.converter) == null ? void 0 : n.toAttribute) !== void 0 ? i.converter : nn).toAttribute(t, i.type);
      this._$Em = e, o == null ? this.removeAttribute(r) : this.setAttribute(r, o), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var n, o;
    const i = this.constructor, r = i._$Eh.get(e);
    if (r !== void 0 && this._$Em !== r) {
      const a = i.getPropertyOptions(r), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((n = a.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? a.converter : nn;
      this._$Em = r;
      const c = l.fromAttribute(t, a.type);
      this[r] = c ?? ((o = this._$Ej) == null ? void 0 : o.get(r)) ?? c, this._$Em = null;
    }
  }
  requestUpdate(e, t, i) {
    var r;
    if (e !== void 0) {
      const n = this.constructor, o = this[e];
      if (i ?? (i = n.getPropertyOptions(e)), !((i.hasChanged ?? Jo)(o, t) || i.useDefault && i.reflect && o === ((r = this._$Ej) == null ? void 0 : r.get(e)) && !this.hasAttribute(n._$Eu(e, i)))) return;
      this.C(e, t, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, t, { useDefault: i, reflect: r, wrapped: n }, o) {
    i && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(e) && (this._$Ej.set(e, o ?? t ?? this[e]), n !== !0 || o !== void 0) || (this._$AL.has(e) || (this.hasUpdated || i || (t = void 0), this._$AL.set(e, t)), r === !0 && this._$Em !== e && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [n, o] of this._$Ep) this[n] = o;
        this._$Ep = void 0;
      }
      const r = this.constructor.elementProperties;
      if (r.size > 0) for (const [n, o] of r) {
        const { wrapped: a } = o, l = this[n];
        a !== !0 || this._$AL.has(n) || l === void 0 || this.C(n, void 0, o, l);
      }
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (i = this._$EO) == null || i.forEach((r) => {
        var n;
        return (n = r.hostUpdate) == null ? void 0 : n.call(r);
      }), this.update(t)) : this._$EM();
    } catch (r) {
      throw e = !1, this._$EM(), r;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$EO) == null || t.forEach((i) => {
      var r;
      return (r = i.hostUpdated) == null ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((t) => this._$ET(t, this[t]))), this._$EM();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
Xs.elementStyles = [], Xs.shadowRootOptions = { mode: "open" }, Xs[zi("elementProperties")] = /* @__PURE__ */ new Map(), Xs[zi("finalized")] = /* @__PURE__ */ new Map(), Zn == null || Zn({ ReactiveElement: Xs }), (ss.reactiveElementVersions ?? (ss.reactiveElementVersions = [])).push("2.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Hi = globalThis, on = Hi.trustedTypes, el = on ? on.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Hc = "$lit$", Gt = `lit$${Math.random().toFixed(9).slice(2)}$`, jc = "?" + Gt, su = `<${jc}>`, $s = document, Qi = () => $s.createComment(""), Yi = (s) => s === null || typeof s != "object" && typeof s != "function", Zo = Array.isArray, iu = (s) => Zo(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", eo = `[ 	
\f\r]`, Ci = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, tl = /-->/g, sl = />/g, us = RegExp(`>|${eo}(?:([^\\s"'>=/]+)(${eo}*=${eo}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), il = /'/g, rl = /"/g, Uc = /^(?:script|style|textarea|title)$/i, ru = (s) => (e, ...t) => ({ _$litType$: s, strings: e, values: t }), D = ru(1), As = Symbol.for("lit-noChange"), Re = Symbol.for("lit-nothing"), nl = /* @__PURE__ */ new WeakMap(), _s = $s.createTreeWalker($s, 129);
function Wc(s, e) {
  if (!Zo(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return el !== void 0 ? el.createHTML(e) : e;
}
const nu = (s, e) => {
  const t = s.length - 1, i = [];
  let r, n = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = Ci;
  for (let a = 0; a < t; a++) {
    const l = s[a];
    let c, u, h = -1, f = 0;
    for (; f < l.length && (o.lastIndex = f, u = o.exec(l), u !== null); ) f = o.lastIndex, o === Ci ? u[1] === "!--" ? o = tl : u[1] !== void 0 ? o = sl : u[2] !== void 0 ? (Uc.test(u[2]) && (r = RegExp("</" + u[2], "g")), o = us) : u[3] !== void 0 && (o = us) : o === us ? u[0] === ">" ? (o = r ?? Ci, h = -1) : u[1] === void 0 ? h = -2 : (h = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? us : u[3] === '"' ? rl : il) : o === rl || o === il ? o = us : o === tl || o === sl ? o = Ci : (o = us, r = void 0);
    const m = o === us && s[a + 1].startsWith("/>") ? " " : "";
    n += o === Ci ? l + su : h >= 0 ? (i.push(c), l.slice(0, h) + Hc + l.slice(h) + Gt + m) : l + Gt + (h === -2 ? a : m);
  }
  return [Wc(s, n + (s[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), i];
};
class Gi {
  constructor({ strings: e, _$litType$: t }, i) {
    let r;
    this.parts = [];
    let n = 0, o = 0;
    const a = e.length - 1, l = this.parts, [c, u] = nu(e, t);
    if (this.el = Gi.createElement(c, i), _s.currentNode = this.el.content, t === 2 || t === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (r = _s.nextNode()) !== null && l.length < a; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) for (const h of r.getAttributeNames()) if (h.endsWith(Hc)) {
          const f = u[o++], m = r.getAttribute(h).split(Gt), _ = /([.?@])?(.*)/.exec(f);
          l.push({ type: 1, index: n, name: _[2], strings: m, ctor: _[1] === "." ? au : _[1] === "?" ? lu : _[1] === "@" ? cu : wn }), r.removeAttribute(h);
        } else h.startsWith(Gt) && (l.push({ type: 6, index: n }), r.removeAttribute(h));
        if (Uc.test(r.tagName)) {
          const h = r.textContent.split(Gt), f = h.length - 1;
          if (f > 0) {
            r.textContent = on ? on.emptyScript : "";
            for (let m = 0; m < f; m++) r.append(h[m], Qi()), _s.nextNode(), l.push({ type: 2, index: ++n });
            r.append(h[f], Qi());
          }
        }
      } else if (r.nodeType === 8) if (r.data === jc) l.push({ type: 2, index: n });
      else {
        let h = -1;
        for (; (h = r.data.indexOf(Gt, h + 1)) !== -1; ) l.push({ type: 7, index: n }), h += Gt.length - 1;
      }
      n++;
    }
  }
  static createElement(e, t) {
    const i = $s.createElement("template");
    return i.innerHTML = e, i;
  }
}
function ni(s, e, t = s, i) {
  var o, a;
  if (e === As) return e;
  let r = i !== void 0 ? (o = t._$Co) == null ? void 0 : o[i] : t._$Cl;
  const n = Yi(e) ? void 0 : e._$litDirective$;
  return (r == null ? void 0 : r.constructor) !== n && ((a = r == null ? void 0 : r._$AO) == null || a.call(r, !1), n === void 0 ? r = void 0 : (r = new n(s), r._$AT(s, t, i)), i !== void 0 ? (t._$Co ?? (t._$Co = []))[i] = r : t._$Cl = r), r !== void 0 && (e = ni(s, r._$AS(s, e.values), r, i)), e;
}
class ou {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: i } = this._$AD, r = ((e == null ? void 0 : e.creationScope) ?? $s).importNode(t, !0);
    _s.currentNode = r;
    let n = _s.nextNode(), o = 0, a = 0, l = i[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new ur(n, n.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(n, l.name, l.strings, this, e) : l.type === 6 && (c = new hu(n, this, e)), this._$AV.push(c), l = i[++a];
      }
      o !== (l == null ? void 0 : l.index) && (n = _s.nextNode(), o++);
    }
    return _s.currentNode = $s, r;
  }
  p(e) {
    let t = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
  }
}
class ur {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, i, r) {
    this.type = 2, this._$AH = Re, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = r, this._$Cv = (r == null ? void 0 : r.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = ni(this, e, t), Yi(e) ? e === Re || e == null || e === "" ? (this._$AH !== Re && this._$AR(), this._$AH = Re) : e !== this._$AH && e !== As && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : iu(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== Re && Yi(this._$AH) ? this._$AA.nextSibling.data = e : this.T($s.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var n;
    const { values: t, _$litType$: i } = e, r = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = Gi.createElement(Wc(i.h, i.h[0]), this.options)), i);
    if (((n = this._$AH) == null ? void 0 : n._$AD) === r) this._$AH.p(t);
    else {
      const o = new ou(r, this), a = o.u(this.options);
      o.p(t), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let t = nl.get(e.strings);
    return t === void 0 && nl.set(e.strings, t = new Gi(e)), t;
  }
  k(e) {
    Zo(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let i, r = 0;
    for (const n of e) r === t.length ? t.push(i = new ur(this.O(Qi()), this.O(Qi()), this, this.options)) : i = t[r], i._$AI(n), r++;
    r < t.length && (this._$AR(i && i._$AB.nextSibling, r), t.length = r);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, !1, !0, t); e !== this._$AB; ) {
      const r = e.nextSibling;
      e.remove(), e = r;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}
class wn {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, i, r, n) {
    this.type = 1, this._$AH = Re, this._$AN = void 0, this.element = e, this.name = t, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Re;
  }
  _$AI(e, t = this, i, r) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) e = ni(this, e, t, 0), o = !Yi(e) || e !== this._$AH && e !== As, o && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = n[0], l = 0; l < n.length - 1; l++) c = ni(this, a[i + l], t, l), c === As && (c = this._$AH[l]), o || (o = !Yi(c) || c !== this._$AH[l]), c === Re ? e = Re : e !== Re && (e += (c ?? "") + n[l + 1]), this._$AH[l] = c;
    }
    o && !r && this.j(e);
  }
  j(e) {
    e === Re ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class au extends wn {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Re ? void 0 : e;
  }
}
class lu extends wn {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Re);
  }
}
class cu extends wn {
  constructor(e, t, i, r, n) {
    super(e, t, i, r, n), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = ni(this, e, t, 0) ?? Re) === As) return;
    const i = this._$AH, r = e === Re && i !== Re || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive, n = e !== Re && (i === Re || r);
    r && this.element.removeEventListener(this.name, this, i), n && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class hu {
  constructor(e, t, i) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    ni(this, e);
  }
}
const to = Hi.litHtmlPolyfillSupport;
to == null || to(Gi, ur), (Hi.litHtmlVersions ?? (Hi.litHtmlVersions = [])).push("3.3.1");
const du = (s, e, t) => {
  const i = (t == null ? void 0 : t.renderBefore) ?? e;
  let r = i._$litPart$;
  if (r === void 0) {
    const n = (t == null ? void 0 : t.renderBefore) ?? null;
    i._$litPart$ = r = new ur(e.insertBefore(Qi(), n), n, void 0, t ?? {});
  }
  return r._$AI(s), r;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ss = globalThis;
let le = class extends Xs {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = du(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return As;
  }
};
var Nc;
le._$litElement$ = !0, le.finalized = !0, (Nc = Ss.litElementHydrateSupport) == null || Nc.call(Ss, { LitElement: le });
const so = Ss.litElementPolyfillSupport;
so == null || so({ LitElement: le });
(Ss.litElementVersions ?? (Ss.litElementVersions = [])).push("4.2.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const me = (s) => (e, t) => {
  t !== void 0 ? t.addInitializer(() => {
    customElements.define(s, e);
  }) : customElements.define(s, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const uu = { attribute: !0, type: String, converter: nn, reflect: !1, hasChanged: Jo }, fu = (s = uu, e, t) => {
  const { kind: i, metadata: r } = t;
  let n = globalThis.litPropertyMetadata.get(r);
  if (n === void 0 && globalThis.litPropertyMetadata.set(r, n = /* @__PURE__ */ new Map()), i === "setter" && ((s = Object.create(s)).wrapped = !0), n.set(t.name, s), i === "accessor") {
    const { name: o } = t;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, l, s);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, s, a), a;
    } };
  }
  if (i === "setter") {
    const { name: o } = t;
    return function(a) {
      const l = this[o];
      e.call(this, a), this.requestUpdate(o, l, s);
    };
  }
  throw Error("Unsupported decorator location: " + i);
};
function H(s) {
  return (e, t) => typeof t == "object" ? fu(s, e, t) : ((i, r, n) => {
    const o = r.hasOwnProperty(n);
    return r.constructor.createProperty(n, i), o ? Object.getOwnPropertyDescriptor(r, n) : void 0;
  })(s, e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function B(s) {
  return H({ ...s, state: !0, attribute: !1 });
}
class Fs extends le {
  connectedCallback() {
    super.connectedCallback(), this._i18nUnsubscribe = Mi.onChange(() => {
      this.requestUpdate();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._i18nUnsubscribe && (this._i18nUnsubscribe(), this._i18nUnsubscribe = void 0);
  }
}
var pu = Object.defineProperty, gu = Object.getOwnPropertyDescriptor, fr = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? gu(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && pu(e, t, r), r;
};
let Es = class extends Fs {
  constructor() {
    super(...arguments), this.username = "", this.password = "", this.loading = !1, this.error = "";
  }
  render() {
    return D`
      <div class="login-container">
        <div class="logo">
          <svg viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
          </svg>
        </div>
        
        <h1>Vapor</h1>
        
        <form @submit=${this.handleSubmit}>
          <div class="form-group">
            <label for="username">Username</label>
            <input
              id="username"
              type="text"
              .value=${this.username}
              @input=${this.handleUsernameInput}
              ?disabled=${this.loading}
              required
              autocomplete="username"
            />
          </div>
          
          <div class="form-group">
            <label for="password">Password</label>
            <input
              id="password"
              type="password"
              .value=${this.password}
              @input=${this.handlePasswordInput}
              ?disabled=${this.loading}
              required
              autocomplete="current-password"
            />
          </div>
          
          <button type="submit" ?disabled=${this.loading}>
            ${this.loading ? "Logging in..." : "Login"}
          </button>
          
          ${this.error ? D`
            <div class="error-message">${this.error}</div>
          ` : ""}
        </form>
      </div>
    `;
  }
  handleUsernameInput(s) {
    this.username = s.target.value, this.error = "";
  }
  handlePasswordInput(s) {
    this.password = s.target.value, this.error = "";
  }
  async handleSubmit(s) {
    if (s.preventDefault(), !this.username || !this.password) {
      this.error = "Please enter both username and password";
      return;
    }
    this.loading = !0, this.error = "";
    try {
      await ts.login(this.username, this.password) ? this.dispatchEvent(new CustomEvent("login-success", {
        bubbles: !0,
        composed: !0
      })) : this.error = "Invalid username or password";
    } catch (e) {
      this.error = "An error occurred. Please try again.", console.error("Login error:", e);
    } finally {
      this.loading = !1;
    }
  }
};
Es.styles = re`
    :host {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: var(--surface-0);
    }

    .login-container {
      background: var(--surface-1);
      border-radius: 8px;
      padding: 2rem;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    h1 {
      text-align: center;
      color: var(--text-primary);
      margin-bottom: 2rem;
      font-size: 1.5rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--surface-0);
      color: var(--text-primary);
      font-size: 1rem;
      transition: border-color 0.2s;
      box-sizing: border-box;
    }

    input:focus {
      outline: none;
      border-color: var(--primary);
    }

    button {
      width: 100%;
      padding: 0.75rem;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover:not(:disabled) {
      background: var(--primary-hover);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .error-message {
      color: var(--error);
      text-align: center;
      margin-top: 1rem;
      font-size: 0.875rem;
    }

    .logo {
      text-align: center;
      margin-bottom: 2rem;
    }

    .logo svg {
      width: 64px;
      height: 64px;
      fill: var(--primary);
    }
  `;
fr([
  B()
], Es.prototype, "username", 2);
fr([
  B()
], Es.prototype, "password", 2);
fr([
  B()
], Es.prototype, "loading", 2);
fr([
  B()
], Es.prototype, "error", 2);
Es = fr([
  me("login-page")
], Es);
class De extends Error {
  constructor(e, t, i, r) {
    super(e), this.code = t, this.details = i, this.status = r, this.name = "ApiError";
  }
}
class Z {
  // Generic request method
  static async request(e, t = {}) {
    var u, h, f;
    const { method: i = "GET", body: r, headers: n = {}, params: o } = t;
    let a = Qa(e);
    if (o) {
      const m = new URLSearchParams(
        Object.entries(o).map(([_, v]) => [_, String(v)])
      ).toString();
      m && (a += `?${m}`);
    }
    const l = e === "/auth/login" ? {} : ts.getAuthHeaders(), c = {
      "Content-Type": "application/json",
      ...l,
      ...n
    };
    console.log("[API Request]", i, a, {
      headers: c,
      hasAuth: !!l.Authorization
    });
    try {
      const m = await fetch(a, {
        method: i,
        headers: c,
        body: r ? JSON.stringify(r) : void 0
      }), _ = m.headers.get("content-type");
      if (!(_ != null && _.includes("application/json"))) {
        if (!m.ok)
          throw new De(`HTTP error! status: ${m.status}`, void 0, void 0, m.status);
        return m.text();
      }
      const v = await m.json();
      if (!m.ok || v.status === "error")
        throw new De(
          ((u = v.error) == null ? void 0 : u.message) || "An error occurred",
          (h = v.error) == null ? void 0 : h.code,
          (f = v.error) == null ? void 0 : f.details,
          m.status
        );
      return v.data;
    } catch (m) {
      throw m instanceof De ? m : new De(
        m instanceof Error ? m.message : "Network error",
        "NETWORK_ERROR"
      );
    }
  }
  // Convenience methods
  static get(e, t) {
    return this.request(e, { method: "GET", params: t });
  }
  static post(e, t) {
    return this.request(e, { method: "POST", body: t });
  }
  static put(e, t) {
    return this.request(e, { method: "PUT", body: t });
  }
  static delete(e, t) {
    return this.request(e, { method: "DELETE", params: t });
  }
  static patch(e, t) {
    return this.request(e, { method: "PATCH", body: t });
  }
  // Special method for posting Kubernetes resources with custom content type
  static async postResource(e, t, i) {
    var o, a, l;
    const r = ts.getAuthHeaders(), n = Qa(e);
    try {
      const c = await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": i,
          ...r
        },
        body: t
      }), u = c.headers.get("content-type");
      if (!(u != null && u.includes("application/json"))) {
        if (!c.ok)
          throw new De(`HTTP error! status: ${c.status}`, void 0, void 0, c.status);
        return c.text();
      }
      const h = await c.json();
      if (!c.ok || h.status === "error")
        throw new De(
          ((o = h.error) == null ? void 0 : o.message) || "An error occurred",
          (a = h.error) == null ? void 0 : a.code,
          (l = h.error) == null ? void 0 : l.details,
          c.status
        );
      return h.data;
    } catch (c) {
      throw c instanceof De ? c : new De(
        c instanceof Error ? c.message : "Network error",
        "NETWORK_ERROR"
      );
    }
  }
}
class ea {
  constructor(e) {
    this.path = e, this.ws = null, this.reconnectInterval = 5e3, this.maxReconnectAttempts = 5, this.reconnectAttempts = 0, this.messageHandlers = /* @__PURE__ */ new Map(), this.reconnectTimer = null, this.authenticated = !1, this.url = "";
  }
  connect() {
    return new Promise((e, t) => {
      try {
        this.url = ts.getWebSocketUrl(this.path), this.ws = new WebSocket(this.url), this.ws.onopen = () => {
          console.log(`WebSocket connected to ${this.path}`), this.reconnectAttempts = 0, this.authenticate().then(() => {
            e();
          }).catch(t);
        }, this.ws.onmessage = (i) => {
          try {
            const r = JSON.parse(i.data);
            this.handleMessage(r);
          } catch (r) {
            console.error("Failed to parse WebSocket message:", r);
          }
        }, this.ws.onerror = (i) => {
          console.error("WebSocket error:", i), t(i);
        }, this.ws.onclose = () => {
          console.log("WebSocket closed"), this.authenticated = !1, this.scheduleReconnect();
        };
      } catch (i) {
        t(i);
      }
    });
  }
  async authenticate() {
    const e = ts.getToken();
    if (!e)
      throw new Error("No authentication token available");
    return new Promise((t, i) => {
      const r = setTimeout(() => {
        i(new Error("Authentication timeout"));
      }, 5e3), n = (a) => {
        var l;
        a.type === "auth" && ((l = a.payload) == null ? void 0 : l.authenticated) === !0 && (clearTimeout(r), this.authenticated = !0, this.off("auth", n), this.off("error", o), console.log(`WebSocket authenticated as ${a.payload.username}`), t());
      }, o = (a) => {
        a.type === "error" && a.code === "AUTH_FAILED" && (clearTimeout(r), this.off("auth_success", n), this.off("error", o), i(new Error(a.error || "Authentication failed")));
      };
      this.on("auth", n), this.on("error", o), this.send({
        type: "auth",
        payload: {
          token: e
        }
      });
    });
  }
  scheduleReconnect() {
    this.reconnectTimer && clearTimeout(this.reconnectTimer), this.reconnectAttempts < this.maxReconnectAttempts && (this.reconnectAttempts++, console.log(`Scheduling reconnect attempt ${this.reconnectAttempts}...`), this.reconnectTimer = window.setTimeout(() => {
      ts.isAuthenticated() && this.connect().catch(console.error);
    }, this.reconnectInterval));
  }
  handleMessage(e) {
    const t = this.messageHandlers.get(e.type);
    t && t.forEach((i) => i(e)), e.type === "error" && console.error("WebSocket error:", e.error);
  }
  send(e) {
    this.ws && this.ws.readyState === WebSocket.OPEN ? this.ws.send(JSON.stringify(e)) : console.error("WebSocket is not connected");
  }
  on(e, t) {
    this.messageHandlers.has(e) || this.messageHandlers.set(e, /* @__PURE__ */ new Set()), this.messageHandlers.get(e).add(t);
  }
  off(e, t) {
    const i = this.messageHandlers.get(e);
    i && i.delete(t);
  }
  disconnect() {
    this.reconnectTimer && (clearTimeout(this.reconnectTimer), this.reconnectTimer = null), this.ws && (this.ws.close(), this.ws = null), this.messageHandlers.clear(), this.authenticated = !1;
  }
  isConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN && this.authenticated;
  }
}
const J = Z;
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function pr(s) {
  return s + 0.5 | 0;
}
const Xt = (s, e, t) => Math.max(Math.min(s, t), e);
function Ii(s) {
  return Xt(pr(s * 2.55), 0, 255);
}
function is(s) {
  return Xt(pr(s * 255), 0, 255);
}
function Ft(s) {
  return Xt(pr(s / 2.55) / 100, 0, 1);
}
function ol(s) {
  return Xt(pr(s * 100), 0, 100);
}
const ut = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Do = [..."0123456789ABCDEF"], mu = (s) => Do[s & 15], bu = (s) => Do[(s & 240) >> 4] + Do[s & 15], Cr = (s) => (s & 240) >> 4 === (s & 15), vu = (s) => Cr(s.r) && Cr(s.g) && Cr(s.b) && Cr(s.a);
function _u(s) {
  var e = s.length, t;
  return s[0] === "#" && (e === 4 || e === 5 ? t = {
    r: 255 & ut[s[1]] * 17,
    g: 255 & ut[s[2]] * 17,
    b: 255 & ut[s[3]] * 17,
    a: e === 5 ? ut[s[4]] * 17 : 255
  } : (e === 7 || e === 9) && (t = {
    r: ut[s[1]] << 4 | ut[s[2]],
    g: ut[s[3]] << 4 | ut[s[4]],
    b: ut[s[5]] << 4 | ut[s[6]],
    a: e === 9 ? ut[s[7]] << 4 | ut[s[8]] : 255
  })), t;
}
const yu = (s, e) => s < 255 ? e(s) : "";
function wu(s) {
  var e = vu(s) ? mu : bu;
  return s ? "#" + e(s.r) + e(s.g) + e(s.b) + yu(s.a, e) : void 0;
}
const xu = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Vc(s, e, t) {
  const i = e * Math.min(t, 1 - t), r = (n, o = (n + s / 30) % 12) => t - i * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [r(0), r(8), r(4)];
}
function ku(s, e, t) {
  const i = (r, n = (r + s / 60) % 6) => t - t * e * Math.max(Math.min(n, 4 - n, 1), 0);
  return [i(5), i(3), i(1)];
}
function Su(s, e, t) {
  const i = Vc(s, 1, 0.5);
  let r;
  for (e + t > 1 && (r = 1 / (e + t), e *= r, t *= r), r = 0; r < 3; r++)
    i[r] *= 1 - e - t, i[r] += e;
  return i;
}
function Cu(s, e, t, i, r) {
  return s === r ? (e - t) / i + (e < t ? 6 : 0) : e === r ? (t - s) / i + 2 : (s - e) / i + 4;
}
function ta(s) {
  const t = s.r / 255, i = s.g / 255, r = s.b / 255, n = Math.max(t, i, r), o = Math.min(t, i, r), a = (n + o) / 2;
  let l, c, u;
  return n !== o && (u = n - o, c = a > 0.5 ? u / (2 - n - o) : u / (n + o), l = Cu(t, i, r, u, n), l = l * 60 + 0.5), [l | 0, c || 0, a];
}
function sa(s, e, t, i) {
  return (Array.isArray(e) ? s(e[0], e[1], e[2]) : s(e, t, i)).map(is);
}
function ia(s, e, t) {
  return sa(Vc, s, e, t);
}
function Du(s, e, t) {
  return sa(Su, s, e, t);
}
function $u(s, e, t) {
  return sa(ku, s, e, t);
}
function qc(s) {
  return (s % 360 + 360) % 360;
}
function Au(s) {
  const e = xu.exec(s);
  let t = 255, i;
  if (!e)
    return;
  e[5] !== i && (t = e[6] ? Ii(+e[5]) : is(+e[5]));
  const r = qc(+e[2]), n = +e[3] / 100, o = +e[4] / 100;
  return e[1] === "hwb" ? i = Du(r, n, o) : e[1] === "hsv" ? i = $u(r, n, o) : i = ia(r, n, o), {
    r: i[0],
    g: i[1],
    b: i[2],
    a: t
  };
}
function Eu(s, e) {
  var t = ta(s);
  t[0] = qc(t[0] + e), t = ia(t), s.r = t[0], s.g = t[1], s.b = t[2];
}
function Tu(s) {
  if (!s)
    return;
  const e = ta(s), t = e[0], i = ol(e[1]), r = ol(e[2]);
  return s.a < 255 ? `hsla(${t}, ${i}%, ${r}%, ${Ft(s.a)})` : `hsl(${t}, ${i}%, ${r}%)`;
}
const al = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, ll = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function Lu() {
  const s = {}, e = Object.keys(ll), t = Object.keys(al);
  let i, r, n, o, a;
  for (i = 0; i < e.length; i++) {
    for (o = a = e[i], r = 0; r < t.length; r++)
      n = t[r], a = a.replace(n, al[n]);
    n = parseInt(ll[o], 16), s[a] = [n >> 16 & 255, n >> 8 & 255, n & 255];
  }
  return s;
}
let Dr;
function Mu(s) {
  Dr || (Dr = Lu(), Dr.transparent = [0, 0, 0, 0]);
  const e = Dr[s.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
const Iu = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function Ru(s) {
  const e = Iu.exec(s);
  let t = 255, i, r, n;
  if (e) {
    if (e[7] !== i) {
      const o = +e[7];
      t = e[8] ? Ii(o) : Xt(o * 255, 0, 255);
    }
    return i = +e[1], r = +e[3], n = +e[5], i = 255 & (e[2] ? Ii(i) : Xt(i, 0, 255)), r = 255 & (e[4] ? Ii(r) : Xt(r, 0, 255)), n = 255 & (e[6] ? Ii(n) : Xt(n, 0, 255)), {
      r: i,
      g: r,
      b: n,
      a: t
    };
  }
}
function Ou(s) {
  return s && (s.a < 255 ? `rgba(${s.r}, ${s.g}, ${s.b}, ${Ft(s.a)})` : `rgb(${s.r}, ${s.g}, ${s.b})`);
}
const io = (s) => s <= 31308e-7 ? s * 12.92 : Math.pow(s, 1 / 2.4) * 1.055 - 0.055, Ks = (s) => s <= 0.04045 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
function Pu(s, e, t) {
  const i = Ks(Ft(s.r)), r = Ks(Ft(s.g)), n = Ks(Ft(s.b));
  return {
    r: is(io(i + t * (Ks(Ft(e.r)) - i))),
    g: is(io(r + t * (Ks(Ft(e.g)) - r))),
    b: is(io(n + t * (Ks(Ft(e.b)) - n))),
    a: s.a + t * (e.a - s.a)
  };
}
function $r(s, e, t) {
  if (s) {
    let i = ta(s);
    i[e] = Math.max(0, Math.min(i[e] + i[e] * t, e === 0 ? 360 : 1)), i = ia(i), s.r = i[0], s.g = i[1], s.b = i[2];
  }
}
function Kc(s, e) {
  return s && Object.assign(e || {}, s);
}
function cl(s) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(s) ? s.length >= 3 && (e = { r: s[0], g: s[1], b: s[2], a: 255 }, s.length > 3 && (e.a = is(s[3]))) : (e = Kc(s, { r: 0, g: 0, b: 0, a: 1 }), e.a = is(e.a)), e;
}
function Bu(s) {
  return s.charAt(0) === "r" ? Ru(s) : Au(s);
}
class Xi {
  constructor(e) {
    if (e instanceof Xi)
      return e;
    const t = typeof e;
    let i;
    t === "object" ? i = cl(e) : t === "string" && (i = _u(e) || Mu(e) || Bu(e)), this._rgb = i, this._valid = !!i;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = Kc(this._rgb);
    return e && (e.a = Ft(e.a)), e;
  }
  set rgb(e) {
    this._rgb = cl(e);
  }
  rgbString() {
    return this._valid ? Ou(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? wu(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? Tu(this._rgb) : void 0;
  }
  mix(e, t) {
    if (e) {
      const i = this.rgb, r = e.rgb;
      let n;
      const o = t === n ? 0.5 : t, a = 2 * o - 1, l = i.a - r.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      n = 1 - c, i.r = 255 & c * i.r + n * r.r + 0.5, i.g = 255 & c * i.g + n * r.g + 0.5, i.b = 255 & c * i.b + n * r.b + 0.5, i.a = o * i.a + (1 - o) * r.a, this.rgb = i;
    }
    return this;
  }
  interpolate(e, t) {
    return e && (this._rgb = Pu(this._rgb, e._rgb, t)), this;
  }
  clone() {
    return new Xi(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = is(e), this;
  }
  clearer(e) {
    const t = this._rgb;
    return t.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, t = pr(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = t, this;
  }
  opaquer(e) {
    const t = this._rgb;
    return t.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return $r(this._rgb, 2, e), this;
  }
  darken(e) {
    return $r(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return $r(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return $r(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return Eu(this._rgb, e), this;
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function Pt() {
}
const Nu = /* @__PURE__ */ (() => {
  let s = 0;
  return () => s++;
})();
function oe(s) {
  return s == null;
}
function xe(s) {
  if (Array.isArray && Array.isArray(s))
    return !0;
  const e = Object.prototype.toString.call(s);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function ae(s) {
  return s !== null && Object.prototype.toString.call(s) === "[object Object]";
}
function Te(s) {
  return (typeof s == "number" || s instanceof Number) && isFinite(+s);
}
function ct(s, e) {
  return Te(s) ? s : e;
}
function ee(s, e) {
  return typeof s > "u" ? e : s;
}
const Fu = (s, e) => typeof s == "string" && s.endsWith("%") ? parseFloat(s) / 100 : +s / e, Qc = (s, e) => typeof s == "string" && s.endsWith("%") ? parseFloat(s) / 100 * e : +s;
function be(s, e, t) {
  if (s && typeof s.call == "function")
    return s.apply(t, e);
}
function ue(s, e, t, i) {
  let r, n, o;
  if (xe(s))
    for (n = s.length, r = 0; r < n; r++)
      e.call(t, s[r], r);
  else if (ae(s))
    for (o = Object.keys(s), n = o.length, r = 0; r < n; r++)
      e.call(t, s[o[r]], o[r]);
}
function an(s, e) {
  let t, i, r, n;
  if (!s || !e || s.length !== e.length)
    return !1;
  for (t = 0, i = s.length; t < i; ++t)
    if (r = s[t], n = e[t], r.datasetIndex !== n.datasetIndex || r.index !== n.index)
      return !1;
  return !0;
}
function ln(s) {
  if (xe(s))
    return s.map(ln);
  if (ae(s)) {
    const e = /* @__PURE__ */ Object.create(null), t = Object.keys(s), i = t.length;
    let r = 0;
    for (; r < i; ++r)
      e[t[r]] = ln(s[t[r]]);
    return e;
  }
  return s;
}
function Yc(s) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(s) === -1;
}
function zu(s, e, t, i) {
  if (!Yc(s))
    return;
  const r = e[s], n = t[s];
  ae(r) && ae(n) ? Ji(r, n, i) : e[s] = ln(n);
}
function Ji(s, e, t) {
  const i = xe(e) ? e : [
    e
  ], r = i.length;
  if (!ae(s))
    return s;
  t = t || {};
  const n = t.merger || zu;
  let o;
  for (let a = 0; a < r; ++a) {
    if (o = i[a], !ae(o))
      continue;
    const l = Object.keys(o);
    for (let c = 0, u = l.length; c < u; ++c)
      n(l[c], s, o, t);
  }
  return s;
}
function ji(s, e) {
  return Ji(s, e, {
    merger: Hu
  });
}
function Hu(s, e, t) {
  if (!Yc(s))
    return;
  const i = e[s], r = t[s];
  ae(i) && ae(r) ? ji(i, r) : Object.prototype.hasOwnProperty.call(e, s) || (e[s] = ln(r));
}
const hl = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (s) => s,
  // default resolvers
  x: (s) => s.x,
  y: (s) => s.y
};
function ju(s) {
  const e = s.split("."), t = [];
  let i = "";
  for (const r of e)
    i += r, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (t.push(i), i = "");
  return t;
}
function Uu(s) {
  const e = ju(s);
  return (t) => {
    for (const i of e) {
      if (i === "")
        break;
      t = t && t[i];
    }
    return t;
  };
}
function ns(s, e) {
  return (hl[e] || (hl[e] = Uu(e)))(s);
}
function ra(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
const Zi = (s) => typeof s < "u", os = (s) => typeof s == "function", dl = (s, e) => {
  if (s.size !== e.size)
    return !1;
  for (const t of s)
    if (!e.has(t))
      return !1;
  return !0;
};
function Wu(s) {
  return s.type === "mouseup" || s.type === "click" || s.type === "contextmenu";
}
const ce = Math.PI, _e = 2 * ce, Vu = _e + ce, cn = Number.POSITIVE_INFINITY, qu = ce / 180, Le = ce / 2, fs = ce / 4, ul = ce * 2 / 3, Jt = Math.log10, At = Math.sign;
function Ui(s, e, t) {
  return Math.abs(s - e) < t;
}
function fl(s) {
  const e = Math.round(s);
  s = Ui(s, e, s / 1e3) ? e : s;
  const t = Math.pow(10, Math.floor(Jt(s))), i = s / t;
  return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * t;
}
function Ku(s) {
  const e = [], t = Math.sqrt(s);
  let i;
  for (i = 1; i < t; i++)
    s % i === 0 && (e.push(i), e.push(s / i));
  return t === (t | 0) && e.push(t), e.sort((r, n) => r - n).pop(), e;
}
function Qu(s) {
  return typeof s == "symbol" || typeof s == "object" && s !== null && !(Symbol.toPrimitive in s || "toString" in s || "valueOf" in s);
}
function oi(s) {
  return !Qu(s) && !isNaN(parseFloat(s)) && isFinite(s);
}
function Yu(s, e) {
  const t = Math.round(s);
  return t - e <= s && t + e >= s;
}
function Gc(s, e, t) {
  let i, r, n;
  for (i = 0, r = s.length; i < r; i++)
    n = s[i][t], isNaN(n) || (e.min = Math.min(e.min, n), e.max = Math.max(e.max, n));
}
function bt(s) {
  return s * (ce / 180);
}
function na(s) {
  return s * (180 / ce);
}
function pl(s) {
  if (!Te(s))
    return;
  let e = 1, t = 0;
  for (; Math.round(s * e) / e !== s; )
    e *= 10, t++;
  return t;
}
function Xc(s, e) {
  const t = e.x - s.x, i = e.y - s.y, r = Math.sqrt(t * t + i * i);
  let n = Math.atan2(i, t);
  return n < -0.5 * ce && (n += _e), {
    angle: n,
    distance: r
  };
}
function $o(s, e) {
  return Math.sqrt(Math.pow(e.x - s.x, 2) + Math.pow(e.y - s.y, 2));
}
function Gu(s, e) {
  return (s - e + Vu) % _e - ce;
}
function Qe(s) {
  return (s % _e + _e) % _e;
}
function er(s, e, t, i) {
  const r = Qe(s), n = Qe(e), o = Qe(t), a = Qe(n - r), l = Qe(o - r), c = Qe(r - n), u = Qe(r - o);
  return r === n || r === o || i && n === o || a > l && c < u;
}
function Fe(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Xu(s) {
  return Fe(s, -32768, 32767);
}
function zt(s, e, t, i = 1e-6) {
  return s >= Math.min(e, t) - i && s <= Math.max(e, t) + i;
}
function oa(s, e, t) {
  t = t || ((o) => s[o] < e);
  let i = s.length - 1, r = 0, n;
  for (; i - r > 1; )
    n = r + i >> 1, t(n) ? r = n : i = n;
  return {
    lo: r,
    hi: i
  };
}
const Ht = (s, e, t, i) => oa(s, t, i ? (r) => {
  const n = s[r][e];
  return n < t || n === t && s[r + 1][e] === t;
} : (r) => s[r][e] < t), Ju = (s, e, t) => oa(s, t, (i) => s[i][e] >= t);
function Zu(s, e, t) {
  let i = 0, r = s.length;
  for (; i < r && s[i] < e; )
    i++;
  for (; r > i && s[r - 1] > t; )
    r--;
  return i > 0 || r < s.length ? s.slice(i, r) : s;
}
const Jc = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function ef(s, e) {
  if (s._chartjs) {
    s._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(s, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        e
      ]
    }
  }), Jc.forEach((t) => {
    const i = "_onData" + ra(t), r = s[t];
    Object.defineProperty(s, t, {
      configurable: !0,
      enumerable: !1,
      value(...n) {
        const o = r.apply(this, n);
        return s._chartjs.listeners.forEach((a) => {
          typeof a[i] == "function" && a[i](...n);
        }), o;
      }
    });
  });
}
function gl(s, e) {
  const t = s._chartjs;
  if (!t)
    return;
  const i = t.listeners, r = i.indexOf(e);
  r !== -1 && i.splice(r, 1), !(i.length > 0) && (Jc.forEach((n) => {
    delete s[n];
  }), delete s._chartjs);
}
function Zc(s) {
  const e = new Set(s);
  return e.size === s.length ? s : Array.from(e);
}
const eh = function() {
  return typeof window > "u" ? function(s) {
    return s();
  } : window.requestAnimationFrame;
}();
function th(s, e) {
  let t = [], i = !1;
  return function(...r) {
    t = r, i || (i = !0, eh.call(window, () => {
      i = !1, s.apply(e, t);
    }));
  };
}
function tf(s, e) {
  let t;
  return function(...i) {
    return e ? (clearTimeout(t), t = setTimeout(s, e, i)) : s.apply(this, i), e;
  };
}
const aa = (s) => s === "start" ? "left" : s === "end" ? "right" : "center", Ke = (s, e, t) => s === "start" ? e : s === "end" ? t : (e + t) / 2, sf = (s, e, t, i) => s === (i ? "left" : "right") ? t : s === "center" ? (e + t) / 2 : e;
function sh(s, e, t) {
  const i = e.length;
  let r = 0, n = i;
  if (s._sorted) {
    const { iScale: o, vScale: a, _parsed: l } = s, c = s.dataset && s.dataset.options ? s.dataset.options.spanGaps : null, u = o.axis, { min: h, max: f, minDefined: m, maxDefined: _ } = o.getUserBounds();
    if (m) {
      if (r = Math.min(
        // @ts-expect-error Need to type _parsed
        Ht(l, u, h).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        t ? i : Ht(e, u, o.getPixelForValue(h)).lo
      ), c) {
        const v = l.slice(0, r + 1).reverse().findIndex((d) => !oe(d[a.axis]));
        r -= Math.max(0, v);
      }
      r = Fe(r, 0, i - 1);
    }
    if (_) {
      let v = Math.max(
        // @ts-expect-error Need to type _parsed
        Ht(l, o.axis, f, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        t ? 0 : Ht(e, u, o.getPixelForValue(f), !0).hi + 1
      );
      if (c) {
        const d = l.slice(v - 1).findIndex((p) => !oe(p[a.axis]));
        v += Math.max(0, d);
      }
      n = Fe(v, r, i) - r;
    } else
      n = i - r;
  }
  return {
    start: r,
    count: n
  };
}
function ih(s) {
  const { xScale: e, yScale: t, _scaleRanges: i } = s, r = {
    xmin: e.min,
    xmax: e.max,
    ymin: t.min,
    ymax: t.max
  };
  if (!i)
    return s._scaleRanges = r, !0;
  const n = i.xmin !== e.min || i.xmax !== e.max || i.ymin !== t.min || i.ymax !== t.max;
  return Object.assign(i, r), n;
}
const Ar = (s) => s === 0 || s === 1, ml = (s, e, t) => -(Math.pow(2, 10 * (s -= 1)) * Math.sin((s - e) * _e / t)), bl = (s, e, t) => Math.pow(2, -10 * s) * Math.sin((s - e) * _e / t) + 1, Wi = {
  linear: (s) => s,
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => -s * (s - 2),
  easeInOutQuad: (s) => (s /= 0.5) < 1 ? 0.5 * s * s : -0.5 * (--s * (s - 2) - 1),
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => (s -= 1) * s * s + 1,
  easeInOutCubic: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s : 0.5 * ((s -= 2) * s * s + 2),
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => -((s -= 1) * s * s * s - 1),
  easeInOutQuart: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s * s : -0.5 * ((s -= 2) * s * s * s - 2),
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => (s -= 1) * s * s * s * s + 1,
  easeInOutQuint: (s) => (s /= 0.5) < 1 ? 0.5 * s * s * s * s * s : 0.5 * ((s -= 2) * s * s * s * s + 2),
  easeInSine: (s) => -Math.cos(s * Le) + 1,
  easeOutSine: (s) => Math.sin(s * Le),
  easeInOutSine: (s) => -0.5 * (Math.cos(ce * s) - 1),
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * (s - 1)),
  easeOutExpo: (s) => s === 1 ? 1 : -Math.pow(2, -10 * s) + 1,
  easeInOutExpo: (s) => Ar(s) ? s : s < 0.5 ? 0.5 * Math.pow(2, 10 * (s * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (s * 2 - 1)) + 2),
  easeInCirc: (s) => s >= 1 ? s : -(Math.sqrt(1 - s * s) - 1),
  easeOutCirc: (s) => Math.sqrt(1 - (s -= 1) * s),
  easeInOutCirc: (s) => (s /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - s * s) - 1) : 0.5 * (Math.sqrt(1 - (s -= 2) * s) + 1),
  easeInElastic: (s) => Ar(s) ? s : ml(s, 0.075, 0.3),
  easeOutElastic: (s) => Ar(s) ? s : bl(s, 0.075, 0.3),
  easeInOutElastic(s) {
    return Ar(s) ? s : s < 0.5 ? 0.5 * ml(s * 2, 0.1125, 0.45) : 0.5 + 0.5 * bl(s * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(s) {
    return s * s * ((1.70158 + 1) * s - 1.70158);
  },
  easeOutBack(s) {
    return (s -= 1) * s * ((1.70158 + 1) * s + 1.70158) + 1;
  },
  easeInOutBack(s) {
    let e = 1.70158;
    return (s /= 0.5) < 1 ? 0.5 * (s * s * (((e *= 1.525) + 1) * s - e)) : 0.5 * ((s -= 2) * s * (((e *= 1.525) + 1) * s + e) + 2);
  },
  easeInBounce: (s) => 1 - Wi.easeOutBounce(1 - s),
  easeOutBounce(s) {
    return s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375;
  },
  easeInOutBounce: (s) => s < 0.5 ? Wi.easeInBounce(s * 2) * 0.5 : Wi.easeOutBounce(s * 2 - 1) * 0.5 + 0.5
};
function la(s) {
  if (s && typeof s == "object") {
    const e = s.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return !1;
}
function vl(s) {
  return la(s) ? s : new Xi(s);
}
function ro(s) {
  return la(s) ? s : new Xi(s).saturate(0.5).darken(0.1).hexString();
}
const rf = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], nf = [
  "color",
  "borderColor",
  "backgroundColor"
];
function of(s) {
  s.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), s.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), s.set("animations", {
    colors: {
      type: "color",
      properties: nf
    },
    numbers: {
      type: "number",
      properties: rf
    }
  }), s.describe("animations", {
    _fallback: "animation"
  }), s.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function af(s) {
  s.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const _l = /* @__PURE__ */ new Map();
function lf(s, e) {
  e = e || {};
  const t = s + JSON.stringify(e);
  let i = _l.get(t);
  return i || (i = new Intl.NumberFormat(s, e), _l.set(t, i)), i;
}
function gr(s, e, t) {
  return lf(e, t).format(s);
}
const rh = {
  values(s) {
    return xe(s) ? s : "" + s;
  },
  numeric(s, e, t) {
    if (s === 0)
      return "0";
    const i = this.chart.options.locale;
    let r, n = s;
    if (t.length > 1) {
      const c = Math.max(Math.abs(t[0].value), Math.abs(t[t.length - 1].value));
      (c < 1e-4 || c > 1e15) && (r = "scientific"), n = cf(s, t);
    }
    const o = Jt(Math.abs(n)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
      notation: r,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(l, this.options.ticks.format), gr(s, i, l);
  },
  logarithmic(s, e, t) {
    if (s === 0)
      return "0";
    const i = t[e].significand || s / Math.pow(10, Math.floor(Jt(s)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(i) || e > 0.8 * t.length ? rh.numeric.call(this, s, e, t) : "";
  }
};
function cf(s, e) {
  let t = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
  return Math.abs(t) >= 1 && s !== Math.floor(s) && (t = s - Math.floor(s)), t;
}
var xn = {
  formatters: rh
};
function hf(s) {
  s.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (e, t) => t.lineWidth,
      tickColor: (e, t) => t.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: xn.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), s.route("scale.ticks", "color", "", "color"), s.route("scale.grid", "color", "", "borderColor"), s.route("scale.border", "color", "", "borderColor"), s.route("scale.title", "color", "", "color"), s.describe("scale", {
    _fallback: !1,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), s.describe("scales", {
    _fallback: "scale"
  }), s.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
const Ts = /* @__PURE__ */ Object.create(null), Ao = /* @__PURE__ */ Object.create(null);
function Vi(s, e) {
  if (!e)
    return s;
  const t = e.split(".");
  for (let i = 0, r = t.length; i < r; ++i) {
    const n = t[i];
    s = s[n] || (s[n] = /* @__PURE__ */ Object.create(null));
  }
  return s;
}
function no(s, e, t) {
  return typeof e == "string" ? Ji(Vi(s, e), t) : Ji(Vi(s, ""), e);
}
class df {
  constructor(e, t) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (i) => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (i, r) => ro(r.backgroundColor), this.hoverBorderColor = (i, r) => ro(r.borderColor), this.hoverColor = (i, r) => ro(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(t);
  }
  set(e, t) {
    return no(this, e, t);
  }
  get(e) {
    return Vi(this, e);
  }
  describe(e, t) {
    return no(Ao, e, t);
  }
  override(e, t) {
    return no(Ts, e, t);
  }
  route(e, t, i, r) {
    const n = Vi(this, e), o = Vi(this, i), a = "_" + t;
    Object.defineProperties(n, {
      [a]: {
        value: n[t],
        writable: !0
      },
      [t]: {
        enumerable: !0,
        get() {
          const l = this[a], c = o[r];
          return ae(l) ? Object.assign({}, c, l) : ee(l, c);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
  apply(e) {
    e.forEach((t) => t(this));
  }
}
var ke = /* @__PURE__ */ new df({
  _scriptable: (s) => !s.startsWith("on"),
  _indexable: (s) => s !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  of,
  af,
  hf
]);
function uf(s) {
  return !s || oe(s.size) || oe(s.family) ? null : (s.style ? s.style + " " : "") + (s.weight ? s.weight + " " : "") + s.size + "px " + s.family;
}
function hn(s, e, t, i, r) {
  let n = e[r];
  return n || (n = e[r] = s.measureText(r).width, t.push(r)), n > i && (i = n), i;
}
function ff(s, e, t, i) {
  i = i || {};
  let r = i.data = i.data || {}, n = i.garbageCollect = i.garbageCollect || [];
  i.font !== e && (r = i.data = {}, n = i.garbageCollect = [], i.font = e), s.save(), s.font = e;
  let o = 0;
  const a = t.length;
  let l, c, u, h, f;
  for (l = 0; l < a; l++)
    if (h = t[l], h != null && !xe(h))
      o = hn(s, r, n, o, h);
    else if (xe(h))
      for (c = 0, u = h.length; c < u; c++)
        f = h[c], f != null && !xe(f) && (o = hn(s, r, n, o, f));
  s.restore();
  const m = n.length / 2;
  if (m > t.length) {
    for (l = 0; l < m; l++)
      delete r[n[l]];
    n.splice(0, m);
  }
  return o;
}
function ps(s, e, t) {
  const i = s.currentDevicePixelRatio, r = t !== 0 ? Math.max(t / 2, 0.5) : 0;
  return Math.round((e - r) * i) / i + r;
}
function yl(s, e) {
  !e && !s || (e = e || s.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, s.width, s.height), e.restore());
}
function Eo(s, e, t, i) {
  nh(s, e, t, i, null);
}
function nh(s, e, t, i, r) {
  let n, o, a, l, c, u, h, f;
  const m = e.pointStyle, _ = e.rotation, v = e.radius;
  let d = (_ || 0) * qu;
  if (m && typeof m == "object" && (n = m.toString(), n === "[object HTMLImageElement]" || n === "[object HTMLCanvasElement]")) {
    s.save(), s.translate(t, i), s.rotate(d), s.drawImage(m, -m.width / 2, -m.height / 2, m.width, m.height), s.restore();
    return;
  }
  if (!(isNaN(v) || v <= 0)) {
    switch (s.beginPath(), m) {
      default:
        r ? s.ellipse(t, i, r / 2, v, 0, 0, _e) : s.arc(t, i, v, 0, _e), s.closePath();
        break;
      case "triangle":
        u = r ? r / 2 : v, s.moveTo(t + Math.sin(d) * u, i - Math.cos(d) * v), d += ul, s.lineTo(t + Math.sin(d) * u, i - Math.cos(d) * v), d += ul, s.lineTo(t + Math.sin(d) * u, i - Math.cos(d) * v), s.closePath();
        break;
      case "rectRounded":
        c = v * 0.516, l = v - c, o = Math.cos(d + fs) * l, h = Math.cos(d + fs) * (r ? r / 2 - c : l), a = Math.sin(d + fs) * l, f = Math.sin(d + fs) * (r ? r / 2 - c : l), s.arc(t - h, i - a, c, d - ce, d - Le), s.arc(t + f, i - o, c, d - Le, d), s.arc(t + h, i + a, c, d, d + Le), s.arc(t - f, i + o, c, d + Le, d + ce), s.closePath();
        break;
      case "rect":
        if (!_) {
          l = Math.SQRT1_2 * v, u = r ? r / 2 : l, s.rect(t - u, i - l, 2 * u, 2 * l);
          break;
        }
        d += fs;
      case "rectRot":
        h = Math.cos(d) * (r ? r / 2 : v), o = Math.cos(d) * v, a = Math.sin(d) * v, f = Math.sin(d) * (r ? r / 2 : v), s.moveTo(t - h, i - a), s.lineTo(t + f, i - o), s.lineTo(t + h, i + a), s.lineTo(t - f, i + o), s.closePath();
        break;
      case "crossRot":
        d += fs;
      case "cross":
        h = Math.cos(d) * (r ? r / 2 : v), o = Math.cos(d) * v, a = Math.sin(d) * v, f = Math.sin(d) * (r ? r / 2 : v), s.moveTo(t - h, i - a), s.lineTo(t + h, i + a), s.moveTo(t + f, i - o), s.lineTo(t - f, i + o);
        break;
      case "star":
        h = Math.cos(d) * (r ? r / 2 : v), o = Math.cos(d) * v, a = Math.sin(d) * v, f = Math.sin(d) * (r ? r / 2 : v), s.moveTo(t - h, i - a), s.lineTo(t + h, i + a), s.moveTo(t + f, i - o), s.lineTo(t - f, i + o), d += fs, h = Math.cos(d) * (r ? r / 2 : v), o = Math.cos(d) * v, a = Math.sin(d) * v, f = Math.sin(d) * (r ? r / 2 : v), s.moveTo(t - h, i - a), s.lineTo(t + h, i + a), s.moveTo(t + f, i - o), s.lineTo(t - f, i + o);
        break;
      case "line":
        o = r ? r / 2 : Math.cos(d) * v, a = Math.sin(d) * v, s.moveTo(t - o, i - a), s.lineTo(t + o, i + a);
        break;
      case "dash":
        s.moveTo(t, i), s.lineTo(t + Math.cos(d) * (r ? r / 2 : v), i + Math.sin(d) * v);
        break;
      case !1:
        s.closePath();
        break;
    }
    s.fill(), e.borderWidth > 0 && s.stroke();
  }
}
function jt(s, e, t) {
  return t = t || 0.5, !e || s && s.x > e.left - t && s.x < e.right + t && s.y > e.top - t && s.y < e.bottom + t;
}
function kn(s, e) {
  s.save(), s.beginPath(), s.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), s.clip();
}
function Sn(s) {
  s.restore();
}
function pf(s, e, t, i, r) {
  if (!e)
    return s.lineTo(t.x, t.y);
  if (r === "middle") {
    const n = (e.x + t.x) / 2;
    s.lineTo(n, e.y), s.lineTo(n, t.y);
  } else r === "after" != !!i ? s.lineTo(e.x, t.y) : s.lineTo(t.x, e.y);
  s.lineTo(t.x, t.y);
}
function gf(s, e, t, i) {
  if (!e)
    return s.lineTo(t.x, t.y);
  s.bezierCurveTo(i ? e.cp1x : e.cp2x, i ? e.cp1y : e.cp2y, i ? t.cp2x : t.cp1x, i ? t.cp2y : t.cp1y, t.x, t.y);
}
function mf(s, e) {
  e.translation && s.translate(e.translation[0], e.translation[1]), oe(e.rotation) || s.rotate(e.rotation), e.color && (s.fillStyle = e.color), e.textAlign && (s.textAlign = e.textAlign), e.textBaseline && (s.textBaseline = e.textBaseline);
}
function bf(s, e, t, i, r) {
  if (r.strikethrough || r.underline) {
    const n = s.measureText(i), o = e - n.actualBoundingBoxLeft, a = e + n.actualBoundingBoxRight, l = t - n.actualBoundingBoxAscent, c = t + n.actualBoundingBoxDescent, u = r.strikethrough ? (l + c) / 2 : c;
    s.strokeStyle = s.fillStyle, s.beginPath(), s.lineWidth = r.decorationWidth || 2, s.moveTo(o, u), s.lineTo(a, u), s.stroke();
  }
}
function vf(s, e) {
  const t = s.fillStyle;
  s.fillStyle = e.color, s.fillRect(e.left, e.top, e.width, e.height), s.fillStyle = t;
}
function Ls(s, e, t, i, r, n = {}) {
  const o = xe(e) ? e : [
    e
  ], a = n.strokeWidth > 0 && n.strokeColor !== "";
  let l, c;
  for (s.save(), s.font = r.string, mf(s, n), l = 0; l < o.length; ++l)
    c = o[l], n.backdrop && vf(s, n.backdrop), a && (n.strokeColor && (s.strokeStyle = n.strokeColor), oe(n.strokeWidth) || (s.lineWidth = n.strokeWidth), s.strokeText(c, t, i, n.maxWidth)), s.fillText(c, t, i, n.maxWidth), bf(s, t, i, c, n), i += Number(r.lineHeight);
  s.restore();
}
function tr(s, e) {
  const { x: t, y: i, w: r, h: n, radius: o } = e;
  s.arc(t + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * ce, ce, !0), s.lineTo(t, i + n - o.bottomLeft), s.arc(t + o.bottomLeft, i + n - o.bottomLeft, o.bottomLeft, ce, Le, !0), s.lineTo(t + r - o.bottomRight, i + n), s.arc(t + r - o.bottomRight, i + n - o.bottomRight, o.bottomRight, Le, 0, !0), s.lineTo(t + r, i + o.topRight), s.arc(t + r - o.topRight, i + o.topRight, o.topRight, 0, -Le, !0), s.lineTo(t + o.topLeft, i);
}
const _f = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, yf = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function wf(s, e) {
  const t = ("" + s).match(_f);
  if (!t || t[1] === "normal")
    return e * 1.2;
  switch (s = +t[2], t[3]) {
    case "px":
      return s;
    case "%":
      s /= 100;
      break;
  }
  return e * s;
}
const xf = (s) => +s || 0;
function ca(s, e) {
  const t = {}, i = ae(e), r = i ? Object.keys(e) : e, n = ae(s) ? i ? (o) => ee(s[o], s[e[o]]) : (o) => s[o] : () => s;
  for (const o of r)
    t[o] = xf(n(o));
  return t;
}
function oh(s) {
  return ca(s, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Cs(s) {
  return ca(s, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Xe(s) {
  const e = oh(s);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function Oe(s, e) {
  s = s || {}, e = e || ke.font;
  let t = ee(s.size, e.size);
  typeof t == "string" && (t = parseInt(t, 10));
  let i = ee(s.style, e.style);
  i && !("" + i).match(yf) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0);
  const r = {
    family: ee(s.family, e.family),
    lineHeight: wf(ee(s.lineHeight, e.lineHeight), t),
    size: t,
    style: i,
    weight: ee(s.weight, e.weight),
    string: ""
  };
  return r.string = uf(r), r;
}
function Ri(s, e, t, i) {
  let r, n, o;
  for (r = 0, n = s.length; r < n; ++r)
    if (o = s[r], o !== void 0 && o !== void 0)
      return o;
}
function kf(s, e, t) {
  const { min: i, max: r } = s, n = Qc(e, (r - i) / 2), o = (a, l) => t && a === 0 ? 0 : a + l;
  return {
    min: o(i, -Math.abs(n)),
    max: o(r, n)
  };
}
function cs(s, e) {
  return Object.assign(Object.create(s), e);
}
function ha(s, e = [
  ""
], t, i, r = () => s[0]) {
  const n = t || s;
  typeof i > "u" && (i = hh("_fallback", s));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: s,
    _rootScopes: n,
    _fallback: i,
    _getTarget: r,
    override: (a) => ha([
      a,
      ...s
    ], e, n, i)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, l) {
      return delete a[l], delete a._keys, delete s[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, l) {
      return lh(a, l, () => Lf(l, e, s, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, l) {
      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(s[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(a, l) {
      return xl(a).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(a) {
      return xl(a);
    },
    /**
    * A trap for setting property values.
    */
    set(a, l, c) {
      const u = a._storage || (a._storage = r());
      return a[l] = u[l] = c, delete a._keys, !0;
    }
  });
}
function ai(s, e, t, i) {
  const r = {
    _cacheable: !1,
    _proxy: s,
    _context: e,
    _subProxy: t,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: ah(s, i),
    setContext: (n) => ai(s, n, t, i),
    override: (n) => ai(s.override(n), e, t, i)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(n, o) {
      return delete n[o], delete s[o], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(n, o, a) {
      return lh(n, o, () => Cf(n, o, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(n, o) {
      return n._descriptors.allKeys ? Reflect.has(s, o) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(s, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(s);
    },
    /**
    * A trap for the in operator.
    */
    has(n, o) {
      return Reflect.has(s, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(s);
    },
    /**
    * A trap for setting property values.
    */
    set(n, o, a) {
      return s[o] = a, delete n[o], !0;
    }
  });
}
function ah(s, e = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: t = e.scriptable, _indexable: i = e.indexable, _allKeys: r = e.allKeys } = s;
  return {
    allKeys: r,
    scriptable: t,
    indexable: i,
    isScriptable: os(t) ? t : () => t,
    isIndexable: os(i) ? i : () => i
  };
}
const Sf = (s, e) => s ? s + ra(e) : e, da = (s, e) => ae(e) && s !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function lh(s, e, t) {
  if (Object.prototype.hasOwnProperty.call(s, e) || e === "constructor")
    return s[e];
  const i = t();
  return s[e] = i, i;
}
function Cf(s, e, t) {
  const { _proxy: i, _context: r, _subProxy: n, _descriptors: o } = s;
  let a = i[e];
  return os(a) && o.isScriptable(e) && (a = Df(e, a, s, t)), xe(a) && a.length && (a = $f(e, a, s, o.isIndexable)), da(e, a) && (a = ai(a, r, n && n[e], o)), a;
}
function Df(s, e, t, i) {
  const { _proxy: r, _context: n, _subProxy: o, _stack: a } = t;
  if (a.has(s))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + s);
  a.add(s);
  let l = e(n, o || i);
  return a.delete(s), da(s, l) && (l = ua(r._scopes, r, s, l)), l;
}
function $f(s, e, t, i) {
  const { _proxy: r, _context: n, _subProxy: o, _descriptors: a } = t;
  if (typeof n.index < "u" && i(s))
    return e[n.index % e.length];
  if (ae(e[0])) {
    const l = e, c = r._scopes.filter((u) => u !== l);
    e = [];
    for (const u of l) {
      const h = ua(c, r, s, u);
      e.push(ai(h, n, o && o[s], a));
    }
  }
  return e;
}
function ch(s, e, t) {
  return os(s) ? s(e, t) : s;
}
const Af = (s, e) => s === !0 ? e : typeof s == "string" ? ns(e, s) : void 0;
function Ef(s, e, t, i, r) {
  for (const n of e) {
    const o = Af(t, n);
    if (o) {
      s.add(o);
      const a = ch(o._fallback, t, r);
      if (typeof a < "u" && a !== t && a !== i)
        return a;
    } else if (o === !1 && typeof i < "u" && t !== i)
      return null;
  }
  return !1;
}
function ua(s, e, t, i) {
  const r = e._rootScopes, n = ch(e._fallback, t, i), o = [
    ...s,
    ...r
  ], a = /* @__PURE__ */ new Set();
  a.add(i);
  let l = wl(a, o, t, n || t, i);
  return l === null || typeof n < "u" && n !== t && (l = wl(a, o, n, l, i), l === null) ? !1 : ha(Array.from(a), [
    ""
  ], r, n, () => Tf(e, t, i));
}
function wl(s, e, t, i, r) {
  for (; t; )
    t = Ef(s, e, t, i, r);
  return t;
}
function Tf(s, e, t) {
  const i = s._getTarget();
  e in i || (i[e] = {});
  const r = i[e];
  return xe(r) && ae(t) ? t : r || {};
}
function Lf(s, e, t, i) {
  let r;
  for (const n of e)
    if (r = hh(Sf(n, s), t), typeof r < "u")
      return da(s, r) ? ua(t, i, s, r) : r;
}
function hh(s, e) {
  for (const t of e) {
    if (!t)
      continue;
    const i = t[s];
    if (typeof i < "u")
      return i;
  }
}
function xl(s) {
  let e = s._keys;
  return e || (e = s._keys = Mf(s._scopes)), e;
}
function Mf(s) {
  const e = /* @__PURE__ */ new Set();
  for (const t of s)
    for (const i of Object.keys(t).filter((r) => !r.startsWith("_")))
      e.add(i);
  return Array.from(e);
}
function dh(s, e, t, i) {
  const { iScale: r } = s, { key: n = "r" } = this._parsing, o = new Array(i);
  let a, l, c, u;
  for (a = 0, l = i; a < l; ++a)
    c = a + t, u = e[c], o[a] = {
      r: r.parse(ns(u, n), c)
    };
  return o;
}
const If = Number.EPSILON || 1e-14, li = (s, e) => e < s.length && !s[e].skip && s[e], uh = (s) => s === "x" ? "y" : "x";
function Rf(s, e, t, i) {
  const r = s.skip ? e : s, n = e, o = t.skip ? e : t, a = $o(n, r), l = $o(o, n);
  let c = a / (a + l), u = l / (a + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const h = i * c, f = i * u;
  return {
    previous: {
      x: n.x - h * (o.x - r.x),
      y: n.y - h * (o.y - r.y)
    },
    next: {
      x: n.x + f * (o.x - r.x),
      y: n.y + f * (o.y - r.y)
    }
  };
}
function Of(s, e, t) {
  const i = s.length;
  let r, n, o, a, l, c = li(s, 0);
  for (let u = 0; u < i - 1; ++u)
    if (l = c, c = li(s, u + 1), !(!l || !c)) {
      if (Ui(e[u], 0, If)) {
        t[u] = t[u + 1] = 0;
        continue;
      }
      r = t[u] / e[u], n = t[u + 1] / e[u], a = Math.pow(r, 2) + Math.pow(n, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), t[u] = r * o * e[u], t[u + 1] = n * o * e[u]);
    }
}
function Pf(s, e, t = "x") {
  const i = uh(t), r = s.length;
  let n, o, a, l = li(s, 0);
  for (let c = 0; c < r; ++c) {
    if (o = a, a = l, l = li(s, c + 1), !a)
      continue;
    const u = a[t], h = a[i];
    o && (n = (u - o[t]) / 3, a[`cp1${t}`] = u - n, a[`cp1${i}`] = h - n * e[c]), l && (n = (l[t] - u) / 3, a[`cp2${t}`] = u + n, a[`cp2${i}`] = h + n * e[c]);
  }
}
function Bf(s, e = "x") {
  const t = uh(e), i = s.length, r = Array(i).fill(0), n = Array(i);
  let o, a, l, c = li(s, 0);
  for (o = 0; o < i; ++o)
    if (a = l, l = c, c = li(s, o + 1), !!l) {
      if (c) {
        const u = c[e] - l[e];
        r[o] = u !== 0 ? (c[t] - l[t]) / u : 0;
      }
      n[o] = a ? c ? At(r[o - 1]) !== At(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o];
    }
  Of(s, r, n), Pf(s, n, e);
}
function Er(s, e, t) {
  return Math.max(Math.min(s, t), e);
}
function Nf(s, e) {
  let t, i, r, n, o, a = jt(s[0], e);
  for (t = 0, i = s.length; t < i; ++t)
    o = n, n = a, a = t < i - 1 && jt(s[t + 1], e), n && (r = s[t], o && (r.cp1x = Er(r.cp1x, e.left, e.right), r.cp1y = Er(r.cp1y, e.top, e.bottom)), a && (r.cp2x = Er(r.cp2x, e.left, e.right), r.cp2y = Er(r.cp2y, e.top, e.bottom)));
}
function Ff(s, e, t, i, r) {
  let n, o, a, l;
  if (e.spanGaps && (s = s.filter((c) => !c.skip)), e.cubicInterpolationMode === "monotone")
    Bf(s, r);
  else {
    let c = i ? s[s.length - 1] : s[0];
    for (n = 0, o = s.length; n < o; ++n)
      a = s[n], l = Rf(c, a, s[Math.min(n + 1, o - (i ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
  }
  e.capBezierPoints && Nf(s, t);
}
function fa() {
  return typeof window < "u" && typeof document < "u";
}
function pa(s) {
  let e = s.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function dn(s, e, t) {
  let i;
  return typeof s == "string" ? (i = parseInt(s, 10), s.indexOf("%") !== -1 && (i = i / 100 * e.parentNode[t])) : i = s, i;
}
const Cn = (s) => s.ownerDocument.defaultView.getComputedStyle(s, null);
function zf(s, e) {
  return Cn(s).getPropertyValue(e);
}
const Hf = [
  "top",
  "right",
  "bottom",
  "left"
];
function Ds(s, e, t) {
  const i = {};
  t = t ? "-" + t : "";
  for (let r = 0; r < 4; r++) {
    const n = Hf[r];
    i[n] = parseFloat(s[e + "-" + n + t]) || 0;
  }
  return i.width = i.left + i.right, i.height = i.top + i.bottom, i;
}
const jf = (s, e, t) => (s > 0 || e > 0) && (!t || !t.shadowRoot);
function Uf(s, e) {
  const t = s.touches, i = t && t.length ? t[0] : s, { offsetX: r, offsetY: n } = i;
  let o = !1, a, l;
  if (jf(r, n, s.target))
    a = r, l = n;
  else {
    const c = e.getBoundingClientRect();
    a = i.clientX - c.left, l = i.clientY - c.top, o = !0;
  }
  return {
    x: a,
    y: l,
    box: o
  };
}
function bs(s, e) {
  if ("native" in s)
    return s;
  const { canvas: t, currentDevicePixelRatio: i } = e, r = Cn(t), n = r.boxSizing === "border-box", o = Ds(r, "padding"), a = Ds(r, "border", "width"), { x: l, y: c, box: u } = Uf(s, t), h = o.left + (u && a.left), f = o.top + (u && a.top);
  let { width: m, height: _ } = e;
  return n && (m -= o.width + a.width, _ -= o.height + a.height), {
    x: Math.round((l - h) / m * t.width / i),
    y: Math.round((c - f) / _ * t.height / i)
  };
}
function Wf(s, e, t) {
  let i, r;
  if (e === void 0 || t === void 0) {
    const n = s && pa(s);
    if (!n)
      e = s.clientWidth, t = s.clientHeight;
    else {
      const o = n.getBoundingClientRect(), a = Cn(n), l = Ds(a, "border", "width"), c = Ds(a, "padding");
      e = o.width - c.width - l.width, t = o.height - c.height - l.height, i = dn(a.maxWidth, n, "clientWidth"), r = dn(a.maxHeight, n, "clientHeight");
    }
  }
  return {
    width: e,
    height: t,
    maxWidth: i || cn,
    maxHeight: r || cn
  };
}
const Tr = (s) => Math.round(s * 10) / 10;
function Vf(s, e, t, i) {
  const r = Cn(s), n = Ds(r, "margin"), o = dn(r.maxWidth, s, "clientWidth") || cn, a = dn(r.maxHeight, s, "clientHeight") || cn, l = Wf(s, e, t);
  let { width: c, height: u } = l;
  if (r.boxSizing === "content-box") {
    const f = Ds(r, "border", "width"), m = Ds(r, "padding");
    c -= m.width + f.width, u -= m.height + f.height;
  }
  return c = Math.max(0, c - n.width), u = Math.max(0, i ? c / i : u - n.height), c = Tr(Math.min(c, o, l.maxWidth)), u = Tr(Math.min(u, a, l.maxHeight)), c && !u && (u = Tr(c / 2)), (e !== void 0 || t !== void 0) && i && l.height && u > l.height && (u = l.height, c = Tr(Math.floor(u * i))), {
    width: c,
    height: u
  };
}
function kl(s, e, t) {
  const i = e || 1, r = Math.floor(s.height * i), n = Math.floor(s.width * i);
  s.height = Math.floor(s.height), s.width = Math.floor(s.width);
  const o = s.canvas;
  return o.style && (t || !o.style.height && !o.style.width) && (o.style.height = `${s.height}px`, o.style.width = `${s.width}px`), s.currentDevicePixelRatio !== i || o.height !== r || o.width !== n ? (s.currentDevicePixelRatio = i, o.height = r, o.width = n, s.ctx.setTransform(i, 0, 0, i, 0, 0), !0) : !1;
}
const qf = function() {
  let s = !1;
  try {
    const e = {
      get passive() {
        return s = !0, !1;
      }
    };
    fa() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return s;
}();
function Sl(s, e) {
  const t = zf(s, e), i = t && t.match(/^(\d+)(\.\d+)?px$/);
  return i ? +i[1] : void 0;
}
function vs(s, e, t, i) {
  return {
    x: s.x + t * (e.x - s.x),
    y: s.y + t * (e.y - s.y)
  };
}
function Kf(s, e, t, i) {
  return {
    x: s.x + t * (e.x - s.x),
    y: i === "middle" ? t < 0.5 ? s.y : e.y : i === "after" ? t < 1 ? s.y : e.y : t > 0 ? e.y : s.y
  };
}
function Qf(s, e, t, i) {
  const r = {
    x: s.cp2x,
    y: s.cp2y
  }, n = {
    x: e.cp1x,
    y: e.cp1y
  }, o = vs(s, r, t), a = vs(r, n, t), l = vs(n, e, t), c = vs(o, a, t), u = vs(a, l, t);
  return vs(c, u, t);
}
const Yf = function(s, e) {
  return {
    x(t) {
      return s + s + e - t;
    },
    setWidth(t) {
      e = t;
    },
    textAlign(t) {
      return t === "center" ? t : t === "right" ? "left" : "right";
    },
    xPlus(t, i) {
      return t - i;
    },
    leftForLtr(t, i) {
      return t - i;
    }
  };
}, Gf = function() {
  return {
    x(s) {
      return s;
    },
    setWidth(s) {
    },
    textAlign(s) {
      return s;
    },
    xPlus(s, e) {
      return s + e;
    },
    leftForLtr(s, e) {
      return s;
    }
  };
};
function si(s, e, t) {
  return s ? Yf(e, t) : Gf();
}
function fh(s, e) {
  let t, i;
  (e === "ltr" || e === "rtl") && (t = s.canvas.style, i = [
    t.getPropertyValue("direction"),
    t.getPropertyPriority("direction")
  ], t.setProperty("direction", e, "important"), s.prevTextDirection = i);
}
function ph(s, e) {
  e !== void 0 && (delete s.prevTextDirection, s.canvas.style.setProperty("direction", e[0], e[1]));
}
function gh(s) {
  return s === "angle" ? {
    between: er,
    compare: Gu,
    normalize: Qe
  } : {
    between: zt,
    compare: (e, t) => e - t,
    normalize: (e) => e
  };
}
function Cl({ start: s, end: e, count: t, loop: i, style: r }) {
  return {
    start: s % t,
    end: e % t,
    loop: i && (e - s + 1) % t === 0,
    style: r
  };
}
function Xf(s, e, t) {
  const { property: i, start: r, end: n } = t, { between: o, normalize: a } = gh(i), l = e.length;
  let { start: c, end: u, loop: h } = s, f, m;
  if (h) {
    for (c += l, u += l, f = 0, m = l; f < m && o(a(e[c % l][i]), r, n); ++f)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: h,
    style: s.style
  };
}
function mh(s, e, t) {
  if (!t)
    return [
      s
    ];
  const { property: i, start: r, end: n } = t, o = e.length, { compare: a, between: l, normalize: c } = gh(i), { start: u, end: h, loop: f, style: m } = Xf(s, e, t), _ = [];
  let v = !1, d = null, p, g, b;
  const y = () => l(r, b, p) && a(r, b) !== 0, w = () => a(n, p) === 0 || l(n, b, p), k = () => v || y(), C = () => !v || w();
  for (let x = u, S = u; x <= h; ++x)
    g = e[x % o], !g.skip && (p = c(g[i]), p !== b && (v = l(p, r, n), d === null && k() && (d = a(p, r) === 0 ? x : S), d !== null && C() && (_.push(Cl({
      start: d,
      end: x,
      loop: f,
      count: o,
      style: m
    })), d = null), S = x, b = p));
  return d !== null && _.push(Cl({
    start: d,
    end: h,
    loop: f,
    count: o,
    style: m
  })), _;
}
function bh(s, e) {
  const t = [], i = s.segments;
  for (let r = 0; r < i.length; r++) {
    const n = mh(i[r], s.points, e);
    n.length && t.push(...n);
  }
  return t;
}
function Jf(s, e, t, i) {
  let r = 0, n = e - 1;
  if (t && !i)
    for (; r < e && !s[r].skip; )
      r++;
  for (; r < e && s[r].skip; )
    r++;
  for (r %= e, t && (n += r); n > r && s[n % e].skip; )
    n--;
  return n %= e, {
    start: r,
    end: n
  };
}
function Zf(s, e, t, i) {
  const r = s.length, n = [];
  let o = e, a = s[e], l;
  for (l = e + 1; l <= t; ++l) {
    const c = s[l % r];
    c.skip || c.stop ? a.skip || (i = !1, n.push({
      start: e % r,
      end: (l - 1) % r,
      loop: i
    }), e = o = c.stop ? l : null) : (o = l, a.skip && (e = l)), a = c;
  }
  return o !== null && n.push({
    start: e % r,
    end: o % r,
    loop: i
  }), n;
}
function ep(s, e) {
  const t = s.points, i = s.options.spanGaps, r = t.length;
  if (!r)
    return [];
  const n = !!s._loop, { start: o, end: a } = Jf(t, r, n, i);
  if (i === !0)
    return Dl(s, [
      {
        start: o,
        end: a,
        loop: n
      }
    ], t, e);
  const l = a < o ? a + r : a, c = !!s._fullLoop && o === 0 && a === r - 1;
  return Dl(s, Zf(t, o, l, c), t, e);
}
function Dl(s, e, t, i) {
  return !i || !i.setContext || !t ? e : tp(s, e, t, i);
}
function tp(s, e, t, i) {
  const r = s._chart.getContext(), n = $l(s.options), { _datasetIndex: o, options: { spanGaps: a } } = s, l = t.length, c = [];
  let u = n, h = e[0].start, f = h;
  function m(_, v, d, p) {
    const g = a ? -1 : 1;
    if (_ !== v) {
      for (_ += l; t[_ % l].skip; )
        _ -= g;
      for (; t[v % l].skip; )
        v += g;
      _ % l !== v % l && (c.push({
        start: _ % l,
        end: v % l,
        loop: d,
        style: p
      }), u = p, h = v % l);
    }
  }
  for (const _ of e) {
    h = a ? h : _.start;
    let v = t[h % l], d;
    for (f = h + 1; f <= _.end; f++) {
      const p = t[f % l];
      d = $l(i.setContext(cs(r, {
        type: "segment",
        p0: v,
        p1: p,
        p0DataIndex: (f - 1) % l,
        p1DataIndex: f % l,
        datasetIndex: o
      }))), sp(d, u) && m(h, f - 1, _.loop, u), v = p, u = d;
    }
    h < f - 1 && m(h, f - 1, _.loop, u);
  }
  return c;
}
function $l(s) {
  return {
    backgroundColor: s.backgroundColor,
    borderCapStyle: s.borderCapStyle,
    borderDash: s.borderDash,
    borderDashOffset: s.borderDashOffset,
    borderJoinStyle: s.borderJoinStyle,
    borderWidth: s.borderWidth,
    borderColor: s.borderColor
  };
}
function sp(s, e) {
  if (!e)
    return !1;
  const t = [], i = function(r, n) {
    return la(n) ? (t.includes(n) || t.push(n), t.indexOf(n)) : n;
  };
  return JSON.stringify(s, i) !== JSON.stringify(e, i);
}
function Lr(s, e, t) {
  return s.options.clip ? s[t] : e[t];
}
function ip(s, e) {
  const { xScale: t, yScale: i } = s;
  return t && i ? {
    left: Lr(t, e, "left"),
    right: Lr(t, e, "right"),
    top: Lr(i, e, "top"),
    bottom: Lr(i, e, "bottom")
  } : e;
}
function vh(s, e) {
  const t = e._clip;
  if (t.disabled)
    return !1;
  const i = ip(e, s.chartArea);
  return {
    left: t.left === !1 ? 0 : i.left - (t.left === !0 ? 0 : t.left),
    right: t.right === !1 ? s.width : i.right + (t.right === !0 ? 0 : t.right),
    top: t.top === !1 ? 0 : i.top - (t.top === !0 ? 0 : t.top),
    bottom: t.bottom === !1 ? s.height : i.bottom + (t.bottom === !0 ? 0 : t.bottom)
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class rp {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(e, t, i, r) {
    const n = t.listeners[r], o = t.duration;
    n.forEach((a) => a({
      chart: e,
      initial: t.initial,
      numSteps: o,
      currentStep: Math.min(i - t.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = eh.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let t = 0;
    this._charts.forEach((i, r) => {
      if (!i.running || !i.items.length)
        return;
      const n = i.items;
      let o = n.length - 1, a = !1, l;
      for (; o >= 0; --o)
        l = n[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(e), a = !0) : (n[o] = n[n.length - 1], n.pop());
      a && (r.draw(), this._notify(r, i, e, "progress")), n.length || (i.running = !1, this._notify(r, i, e, "complete"), i.initial = !1), t += n.length;
    }), this._lastDate = e, t === 0 && (this._running = !1);
  }
  _getAnims(e) {
    const t = this._charts;
    let i = t.get(e);
    return i || (i = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, t.set(e, i)), i;
  }
  listen(e, t, i) {
    this._getAnims(e).listeners[t].push(i);
  }
  add(e, t) {
    !t || !t.length || this._getAnims(e).items.push(...t);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const t = this._charts.get(e);
    t && (t.running = !0, t.start = Date.now(), t.duration = t.items.reduce((i, r) => Math.max(i, r._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return !1;
    const t = this._charts.get(e);
    return !(!t || !t.running || !t.items.length);
  }
  stop(e) {
    const t = this._charts.get(e);
    if (!t || !t.items.length)
      return;
    const i = t.items;
    let r = i.length - 1;
    for (; r >= 0; --r)
      i[r].cancel();
    t.items = [], this._notify(e, t, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
}
var Bt = /* @__PURE__ */ new rp();
const Al = "transparent", np = {
  boolean(s, e, t) {
    return t > 0.5 ? e : s;
  },
  color(s, e, t) {
    const i = vl(s || Al), r = i.valid && vl(e || Al);
    return r && r.valid ? r.mix(i, t).hexString() : e;
  },
  number(s, e, t) {
    return s + (e - s) * t;
  }
};
class op {
  constructor(e, t, i, r) {
    const n = t[i];
    r = Ri([
      e.to,
      r,
      n,
      e.from
    ]);
    const o = Ri([
      e.from,
      n,
      r
    ]);
    this._active = !0, this._fn = e.fn || np[e.type || typeof o], this._easing = Wi[e.easing] || Wi.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = t, this._prop = i, this._from = o, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, t, i) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], n = i - this._start, o = this._duration - n;
      this._start = i, this._duration = Math.floor(Math.max(o, e.duration)), this._total += n, this._loop = !!e.loop, this._to = Ri([
        e.to,
        t,
        r,
        e.from
      ]), this._from = Ri([
        e.from,
        r,
        t
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(e) {
    const t = e - this._start, i = this._duration, r = this._prop, n = this._from, o = this._loop, a = this._to;
    let l;
    if (this._active = n !== a && (o || t < i), !this._active) {
      this._target[r] = a, this._notify(!0);
      return;
    }
    if (t < 0) {
      this._target[r] = n;
      return;
    }
    l = t / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(n, a, l);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((t, i) => {
      e.push({
        res: t,
        rej: i
      });
    });
  }
  _notify(e) {
    const t = e ? "res" : "rej", i = this._promises || [];
    for (let r = 0; r < i.length; r++)
      i[r][t]();
  }
}
class _h {
  constructor(e, t) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(t);
  }
  configure(e) {
    if (!ae(e))
      return;
    const t = Object.keys(ke.animation), i = this._properties;
    Object.getOwnPropertyNames(e).forEach((r) => {
      const n = e[r];
      if (!ae(n))
        return;
      const o = {};
      for (const a of t)
        o[a] = n[a];
      (xe(n.properties) && n.properties || [
        r
      ]).forEach((a) => {
        (a === r || !i.has(a)) && i.set(a, o);
      });
    });
  }
  _animateOptions(e, t) {
    const i = t.options, r = lp(e, i);
    if (!r)
      return [];
    const n = this._createAnimations(r, i);
    return i.$shared && ap(e.options.$animations, i).then(() => {
      e.options = i;
    }, () => {
    }), n;
  }
  _createAnimations(e, t) {
    const i = this._properties, r = [], n = e.$animations || (e.$animations = {}), o = Object.keys(t), a = Date.now();
    let l;
    for (l = o.length - 1; l >= 0; --l) {
      const c = o[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        r.push(...this._animateOptions(e, t));
        continue;
      }
      const u = t[c];
      let h = n[c];
      const f = i.get(c);
      if (h)
        if (f && h.active()) {
          h.update(f, u, a);
          continue;
        } else
          h.cancel();
      if (!f || !f.duration) {
        e[c] = u;
        continue;
      }
      n[c] = h = new op(f, e, c, u), r.push(h);
    }
    return r;
  }
  update(e, t) {
    if (this._properties.size === 0) {
      Object.assign(e, t);
      return;
    }
    const i = this._createAnimations(e, t);
    if (i.length)
      return Bt.add(this._chart, i), !0;
  }
}
function ap(s, e) {
  const t = [], i = Object.keys(e);
  for (let r = 0; r < i.length; r++) {
    const n = s[i[r]];
    n && n.active() && t.push(n.wait());
  }
  return Promise.all(t);
}
function lp(s, e) {
  if (!e)
    return;
  let t = s.options;
  if (!t) {
    s.options = e;
    return;
  }
  return t.$shared && (s.options = t = Object.assign({}, t, {
    $shared: !1,
    $animations: {}
  })), t;
}
function El(s, e) {
  const t = s && s.options || {}, i = t.reverse, r = t.min === void 0 ? e : 0, n = t.max === void 0 ? e : 0;
  return {
    start: i ? n : r,
    end: i ? r : n
  };
}
function cp(s, e, t) {
  if (t === !1)
    return !1;
  const i = El(s, t), r = El(e, t);
  return {
    top: r.end,
    right: i.end,
    bottom: r.start,
    left: i.start
  };
}
function hp(s) {
  let e, t, i, r;
  return ae(s) ? (e = s.top, t = s.right, i = s.bottom, r = s.left) : e = t = i = r = s, {
    top: e,
    right: t,
    bottom: i,
    left: r,
    disabled: s === !1
  };
}
function yh(s, e) {
  const t = [], i = s._getSortedDatasetMetas(e);
  let r, n;
  for (r = 0, n = i.length; r < n; ++r)
    t.push(i[r].index);
  return t;
}
function Tl(s, e, t, i = {}) {
  const r = s.keys, n = i.mode === "single";
  let o, a, l, c;
  if (e === null)
    return;
  let u = !1;
  for (o = 0, a = r.length; o < a; ++o) {
    if (l = +r[o], l === t) {
      if (u = !0, i.all)
        continue;
      break;
    }
    c = s.values[l], Te(c) && (n || e === 0 || At(e) === At(c)) && (e += c);
  }
  return !u && !i.all ? 0 : e;
}
function dp(s, e) {
  const { iScale: t, vScale: i } = e, r = t.axis === "x" ? "x" : "y", n = i.axis === "x" ? "x" : "y", o = Object.keys(s), a = new Array(o.length);
  let l, c, u;
  for (l = 0, c = o.length; l < c; ++l)
    u = o[l], a[l] = {
      [r]: u,
      [n]: s[u]
    };
  return a;
}
function oo(s, e) {
  const t = s && s.options.stacked;
  return t || t === void 0 && e.stack !== void 0;
}
function up(s, e, t) {
  return `${s.id}.${e.id}.${t.stack || t.type}`;
}
function fp(s) {
  const { min: e, max: t, minDefined: i, maxDefined: r } = s.getUserBounds();
  return {
    min: i ? e : Number.NEGATIVE_INFINITY,
    max: r ? t : Number.POSITIVE_INFINITY
  };
}
function pp(s, e, t) {
  const i = s[e] || (s[e] = {});
  return i[t] || (i[t] = {});
}
function Ll(s, e, t, i) {
  for (const r of e.getMatchingVisibleMetas(i).reverse()) {
    const n = s[r.index];
    if (t && n > 0 || !t && n < 0)
      return r.index;
  }
  return null;
}
function Ml(s, e) {
  const { chart: t, _cachedMeta: i } = s, r = t._stacks || (t._stacks = {}), { iScale: n, vScale: o, index: a } = i, l = n.axis, c = o.axis, u = up(n, o, i), h = e.length;
  let f;
  for (let m = 0; m < h; ++m) {
    const _ = e[m], { [l]: v, [c]: d } = _, p = _._stacks || (_._stacks = {});
    f = p[c] = pp(r, u, v), f[a] = d, f._top = Ll(f, o, !0, i.type), f._bottom = Ll(f, o, !1, i.type);
    const g = f._visualValues || (f._visualValues = {});
    g[a] = d;
  }
}
function ao(s, e) {
  const t = s.scales;
  return Object.keys(t).filter((i) => t[i].axis === e).shift();
}
function gp(s, e) {
  return cs(s, {
    active: !1,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function mp(s, e, t) {
  return cs(s, {
    active: !1,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: t,
    index: e,
    mode: "default",
    type: "data"
  });
}
function Di(s, e) {
  const t = s.controller.index, i = s.vScale && s.vScale.axis;
  if (i) {
    e = e || s._parsed;
    for (const r of e) {
      const n = r._stacks;
      if (!n || n[i] === void 0 || n[i][t] === void 0)
        return;
      delete n[i][t], n[i]._visualValues !== void 0 && n[i]._visualValues[t] !== void 0 && delete n[i]._visualValues[t];
    }
  }
}
const lo = (s) => s === "reset" || s === "none", Il = (s, e) => e ? s : Object.assign({}, s), bp = (s, e, t) => s && !e.hidden && e._stacked && {
  keys: yh(t, !0),
  values: null
};
class vt {
  constructor(e, t) {
    this.chart = e, this._ctx = e.ctx, this.index = t, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = oo(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && Di(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, t = this._cachedMeta, i = this.getDataset(), r = (h, f, m, _) => h === "x" ? f : h === "r" ? _ : m, n = t.xAxisID = ee(i.xAxisID, ao(e, "x")), o = t.yAxisID = ee(i.yAxisID, ao(e, "y")), a = t.rAxisID = ee(i.rAxisID, ao(e, "r")), l = t.indexAxis, c = t.iAxisID = r(l, n, o, a), u = t.vAxisID = r(l, o, n, a);
    t.xScale = this.getScaleForId(n), t.yScale = this.getScaleForId(o), t.rScale = this.getScaleForId(a), t.iScale = this.getScaleForId(c), t.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const t = this._cachedMeta;
    return e === t.iScale ? t.vScale : t.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && gl(this._data, this), e._stacked && Di(e);
  }
  _dataCheck() {
    const e = this.getDataset(), t = e.data || (e.data = []), i = this._data;
    if (ae(t)) {
      const r = this._cachedMeta;
      this._data = dp(t, r);
    } else if (i !== t) {
      if (i) {
        gl(i, this);
        const r = this._cachedMeta;
        Di(r), r._parsed = [];
      }
      t && Object.isExtensible(t) && ef(t, this), this._syncList = [], this._data = t;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const t = this._cachedMeta, i = this.getDataset();
    let r = !1;
    this._dataCheck();
    const n = t._stacked;
    t._stacked = oo(t.vScale, t), t.stack !== i.stack && (r = !0, Di(t), t.stack = i.stack), this._resyncElements(e), (r || n !== t._stacked) && (Ml(this, t._parsed), t._stacked = oo(t.vScale, t));
  }
  configure() {
    const e = this.chart.config, t = e.datasetScopeKeys(this._type), i = e.getOptionScopes(this.getDataset(), t, !0);
    this.options = e.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, t) {
    const { _cachedMeta: i, _data: r } = this, { iScale: n, _stacked: o } = i, a = n.axis;
    let l = e === 0 && t === r.length ? !0 : i._sorted, c = e > 0 && i._parsed[e - 1], u, h, f;
    if (this._parsing === !1)
      i._parsed = r, i._sorted = !0, f = r;
    else {
      xe(r[e]) ? f = this.parseArrayData(i, r, e, t) : ae(r[e]) ? f = this.parseObjectData(i, r, e, t) : f = this.parsePrimitiveData(i, r, e, t);
      const m = () => h[a] === null || c && h[a] < c[a];
      for (u = 0; u < t; ++u)
        i._parsed[u + e] = h = f[u], l && (m() && (l = !1), c = h);
      i._sorted = l;
    }
    o && Ml(this, f);
  }
  parsePrimitiveData(e, t, i, r) {
    const { iScale: n, vScale: o } = e, a = n.axis, l = o.axis, c = n.getLabels(), u = n === o, h = new Array(r);
    let f, m, _;
    for (f = 0, m = r; f < m; ++f)
      _ = f + i, h[f] = {
        [a]: u || n.parse(c[_], _),
        [l]: o.parse(t[_], _)
      };
    return h;
  }
  parseArrayData(e, t, i, r) {
    const { xScale: n, yScale: o } = e, a = new Array(r);
    let l, c, u, h;
    for (l = 0, c = r; l < c; ++l)
      u = l + i, h = t[u], a[l] = {
        x: n.parse(h[0], u),
        y: o.parse(h[1], u)
      };
    return a;
  }
  parseObjectData(e, t, i, r) {
    const { xScale: n, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(r);
    let u, h, f, m;
    for (u = 0, h = r; u < h; ++u)
      f = u + i, m = t[f], c[u] = {
        x: n.parse(ns(m, a), f),
        y: o.parse(ns(m, l), f)
      };
    return c;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, t, i) {
    const r = this.chart, n = this._cachedMeta, o = t[e.axis], a = {
      keys: yh(r, !0),
      values: t._stacks[e.axis]._visualValues
    };
    return Tl(a, o, n.index, {
      mode: i
    });
  }
  updateRangeFromParsed(e, t, i, r) {
    const n = i[t.axis];
    let o = n === null ? NaN : n;
    const a = r && i._stacks[t.axis];
    r && a && (r.values = a, o = Tl(r, n, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o);
  }
  getMinMax(e, t) {
    const i = this._cachedMeta, r = i._parsed, n = i._sorted && e === i.iScale, o = r.length, a = this._getOtherScale(e), l = bp(t, i, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: h } = fp(a);
    let f, m;
    function _() {
      m = r[f];
      const v = m[a.axis];
      return !Te(m[e.axis]) || u > v || h < v;
    }
    for (f = 0; f < o && !(!_() && (this.updateRangeFromParsed(c, e, m, l), n)); ++f)
      ;
    if (n) {
      for (f = o - 1; f >= 0; --f)
        if (!_()) {
          this.updateRangeFromParsed(c, e, m, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(e) {
    const t = this._cachedMeta._parsed, i = [];
    let r, n, o;
    for (r = 0, n = t.length; r < n; ++r)
      o = t[r][e.axis], Te(o) && i.push(o);
    return i;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(e) {
    const t = this._cachedMeta, i = t.iScale, r = t.vScale, n = this.getParsed(e);
    return {
      label: i ? "" + i.getLabelForValue(n[i.axis]) : "",
      value: r ? "" + r.getLabelForValue(n[r.axis]) : ""
    };
  }
  _update(e) {
    const t = this._cachedMeta;
    this.update(e || "default"), t._clip = hp(ee(this.options.clip, cp(t.xScale, t.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, t = this.chart, i = this._cachedMeta, r = i.data || [], n = t.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || r.length - a, c = this.options.drawActiveElementsOnTop;
    let u;
    for (i.dataset && i.dataset.draw(e, n, a, l), u = a; u < a + l; ++u) {
      const h = r[u];
      h.hidden || (h.active && c ? o.push(h) : h.draw(e, n));
    }
    for (u = 0; u < o.length; ++u)
      o[u].draw(e, n);
  }
  getStyle(e, t) {
    const i = t ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(e || 0, i);
  }
  getContext(e, t, i) {
    const r = this.getDataset();
    let n;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[e];
      n = o.$context || (o.$context = mp(this.getContext(), e, o)), n.parsed = this.getParsed(e), n.raw = r.data[e], n.index = n.dataIndex = e;
    } else
      n = this.$context || (this.$context = gp(this.chart.getContext(), this.index)), n.dataset = r, n.index = n.datasetIndex = this.index;
    return n.active = !!t, n.mode = i, n;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, t) {
    return this._resolveElementOptions(this.dataElementType.id, t, e);
  }
  _resolveElementOptions(e, t = "default", i) {
    const r = t === "active", n = this._cachedDataOpts, o = e + "-" + t, a = n[o], l = this.enableOptionSharing && Zi(i);
    if (a)
      return Il(a, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, e), h = r ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], f = c.getOptionScopes(this.getDataset(), u), m = Object.keys(ke.elements[e]), _ = () => this.getContext(i, r, t), v = c.resolveNamedOptions(f, m, _, h);
    return v.$shared && (v.$shared = l, n[o] = Object.freeze(Il(v, l))), v;
  }
  _resolveAnimations(e, t, i) {
    const r = this.chart, n = this._cachedDataOpts, o = `animation-${t}`, a = n[o];
    if (a)
      return a;
    let l;
    if (r.options.animation !== !1) {
      const u = this.chart.config, h = u.datasetAnimationScopeKeys(this._type, t), f = u.getOptionScopes(this.getDataset(), h);
      l = u.createResolver(f, this.getContext(e, i, t));
    }
    const c = new _h(r, l && l.animations);
    return l && l._cacheable && (n[o] = Object.freeze(c)), c;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, t) {
    return !t || lo(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, t) {
    const i = this.resolveDataElementOptions(e, t), r = this._sharedOptions, n = this.getSharedOptions(i), o = this.includeOptions(t, n) || n !== r;
    return this.updateSharedOptions(n, t, i), {
      sharedOptions: n,
      includeOptions: o
    };
  }
  updateElement(e, t, i, r) {
    lo(r) ? Object.assign(e, i) : this._resolveAnimations(t, r).update(e, i);
  }
  updateSharedOptions(e, t, i) {
    e && !lo(t) && this._resolveAnimations(void 0, t).update(e, i);
  }
  _setStyle(e, t, i, r) {
    e.active = r;
    const n = this.getStyle(t, r);
    this._resolveAnimations(t, i, r).update(e, {
      options: !r && this.getSharedOptions(n) || n
    });
  }
  removeHoverStyle(e, t, i) {
    this._setStyle(e, i, "active", !1);
  }
  setHoverStyle(e, t, i) {
    this._setStyle(e, i, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", !0);
  }
  _resyncElements(e) {
    const t = this._data, i = this._cachedMeta.data;
    for (const [a, l, c] of this._syncList)
      this[a](l, c);
    this._syncList = [];
    const r = i.length, n = t.length, o = Math.min(n, r);
    o && this.parse(0, o), n > r ? this._insertElements(r, n - r, e) : n < r && this._removeElements(n, r - n);
  }
  _insertElements(e, t, i = !0) {
    const r = this._cachedMeta, n = r.data, o = e + t;
    let a;
    const l = (c) => {
      for (c.length += t, a = c.length - 1; a >= o; a--)
        c[a] = c[a - t];
    };
    for (l(n), a = e; a < o; ++a)
      n[a] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(e, t), i && this.updateElements(n, e, t, "reset");
  }
  updateElements(e, t, i, r) {
  }
  _removeElements(e, t) {
    const i = this._cachedMeta;
    if (this._parsing) {
      const r = i._parsed.splice(e, t);
      i._stacked && Di(i, r);
    }
    i.data.splice(e, t);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [t, i, r] = e;
      this[t](i, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, t) {
    t && this._sync([
      "_removeElements",
      e,
      t
    ]);
    const i = arguments.length - 2;
    i && this._sync([
      "_insertElements",
      e,
      i
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
K(vt, "defaults", {}), K(vt, "datasetElementType", null), K(vt, "dataElementType", null);
function vp(s, e) {
  if (!s._cache.$bar) {
    const t = s.getMatchingVisibleMetas(e);
    let i = [];
    for (let r = 0, n = t.length; r < n; r++)
      i = i.concat(t[r].controller.getAllParsedValues(s));
    s._cache.$bar = Zc(i.sort((r, n) => r - n));
  }
  return s._cache.$bar;
}
function _p(s) {
  const e = s.iScale, t = vp(e, s.type);
  let i = e._length, r, n, o, a;
  const l = () => {
    o === 32767 || o === -32768 || (Zi(a) && (i = Math.min(i, Math.abs(o - a) || i)), a = o);
  };
  for (r = 0, n = t.length; r < n; ++r)
    o = e.getPixelForValue(t[r]), l();
  for (a = void 0, r = 0, n = e.ticks.length; r < n; ++r)
    o = e.getPixelForTick(r), l();
  return i;
}
function yp(s, e, t, i) {
  const r = t.barThickness;
  let n, o;
  return oe(r) ? (n = e.min * t.categoryPercentage, o = t.barPercentage) : (n = r * i, o = 1), {
    chunk: n / i,
    ratio: o,
    start: e.pixels[s] - n / 2
  };
}
function wp(s, e, t, i) {
  const r = e.pixels, n = r[s];
  let o = s > 0 ? r[s - 1] : null, a = s < r.length - 1 ? r[s + 1] : null;
  const l = t.categoryPercentage;
  o === null && (o = n - (a === null ? e.end - e.start : a - n)), a === null && (a = n + n - o);
  const c = n - (n - Math.min(o, a)) / 2 * l;
  return {
    chunk: Math.abs(a - o) / 2 * l / i,
    ratio: t.barPercentage,
    start: c
  };
}
function xp(s, e, t, i) {
  const r = t.parse(s[0], i), n = t.parse(s[1], i), o = Math.min(r, n), a = Math.max(r, n);
  let l = o, c = a;
  Math.abs(o) > Math.abs(a) && (l = a, c = o), e[t.axis] = c, e._custom = {
    barStart: l,
    barEnd: c,
    start: r,
    end: n,
    min: o,
    max: a
  };
}
function wh(s, e, t, i) {
  return xe(s) ? xp(s, e, t, i) : e[t.axis] = t.parse(s, i), e;
}
function Rl(s, e, t, i) {
  const r = s.iScale, n = s.vScale, o = r.getLabels(), a = r === n, l = [];
  let c, u, h, f;
  for (c = t, u = t + i; c < u; ++c)
    f = e[c], h = {}, h[r.axis] = a || r.parse(o[c], c), l.push(wh(f, h, n, c));
  return l;
}
function co(s) {
  return s && s.barStart !== void 0 && s.barEnd !== void 0;
}
function kp(s, e, t) {
  return s !== 0 ? At(s) : (e.isHorizontal() ? 1 : -1) * (e.min >= t ? 1 : -1);
}
function Sp(s) {
  let e, t, i, r, n;
  return s.horizontal ? (e = s.base > s.x, t = "left", i = "right") : (e = s.base < s.y, t = "bottom", i = "top"), e ? (r = "end", n = "start") : (r = "start", n = "end"), {
    start: t,
    end: i,
    reverse: e,
    top: r,
    bottom: n
  };
}
function Cp(s, e, t, i) {
  let r = e.borderSkipped;
  const n = {};
  if (!r) {
    s.borderSkipped = n;
    return;
  }
  if (r === !0) {
    s.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: o, end: a, reverse: l, top: c, bottom: u } = Sp(s);
  r === "middle" && t && (s.enableBorderRadius = !0, (t._top || 0) === i ? r = c : (t._bottom || 0) === i ? r = u : (n[Ol(u, o, a, l)] = !0, r = c)), n[Ol(r, o, a, l)] = !0, s.borderSkipped = n;
}
function Ol(s, e, t, i) {
  return i ? (s = Dp(s, e, t), s = Pl(s, t, e)) : s = Pl(s, e, t), s;
}
function Dp(s, e, t) {
  return s === e ? t : s === t ? e : s;
}
function Pl(s, e, t) {
  return s === "start" ? e : s === "end" ? t : s;
}
function $p(s, { inflateAmount: e }, t) {
  s.inflateAmount = e === "auto" ? t === 1 ? 0.33 : 0 : e;
}
class Vr extends vt {
  parsePrimitiveData(e, t, i, r) {
    return Rl(e, t, i, r);
  }
  parseArrayData(e, t, i, r) {
    return Rl(e, t, i, r);
  }
  parseObjectData(e, t, i, r) {
    const { iScale: n, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = n.axis === "x" ? a : l, u = o.axis === "x" ? a : l, h = [];
    let f, m, _, v;
    for (f = i, m = i + r; f < m; ++f)
      v = t[f], _ = {}, _[n.axis] = n.parse(ns(v, c), f), h.push(wh(ns(v, u), _, o, f));
    return h;
  }
  updateRangeFromParsed(e, t, i, r) {
    super.updateRangeFromParsed(e, t, i, r);
    const n = i._custom;
    n && t === this._cachedMeta.vScale && (e.min = Math.min(e.min, n.min), e.max = Math.max(e.max, n.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(e) {
    const t = this._cachedMeta, { iScale: i, vScale: r } = t, n = this.getParsed(e), o = n._custom, a = co(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(n[r.axis]);
    return {
      label: "" + i.getLabelForValue(n[i.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const e = this._cachedMeta;
    e.stack = this.getDataset().stack;
  }
  update(e) {
    const t = this._cachedMeta;
    this.updateElements(t.data, 0, t.data.length, e);
  }
  updateElements(e, t, i, r) {
    const n = r === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: h, includeOptions: f } = this._getSharedOptions(t, r);
    for (let m = t; m < t + i; m++) {
      const _ = this.getParsed(m), v = n || oe(_[a.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(m), d = this._calculateBarIndexPixels(m, u), p = (_._stacks || {})[a.axis], g = {
        horizontal: c,
        base: v.base,
        enableBorderRadius: !p || co(_._custom) || o === p._top || o === p._bottom,
        x: c ? v.head : d.center,
        y: c ? d.center : v.head,
        height: c ? d.size : Math.abs(v.size),
        width: c ? Math.abs(v.size) : d.size
      };
      f && (g.options = h || this.resolveDataElementOptions(m, e[m].active ? "active" : r));
      const b = g.options || e[m].options;
      Cp(g, b, p, o), $p(g, b, u.ratio), this.updateElement(e[m], m, g, r);
    }
  }
  _getStacks(e, t) {
    const { iScale: i } = this._cachedMeta, r = i.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), n = i.options.stacked, o = [], a = this._cachedMeta.controller.getParsed(t), l = a && a[i.axis], c = (u) => {
      const h = u._parsed.find((m) => m[i.axis] === l), f = h && h[u.vScale.axis];
      if (oe(f) || isNaN(f))
        return !0;
    };
    for (const u of r)
      if (!(t !== void 0 && c(u)) && ((n === !1 || o.indexOf(u.stack) === -1 || n === void 0 && u.stack === void 0) && o.push(u.stack), u.index === e))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const e = this.chart.scales, t = this.chart.options.indexAxis;
    return Object.keys(e).filter((i) => e[i].axis === t).shift();
  }
  _getAxis() {
    const e = {}, t = this.getFirstScaleIdForIndexAxis();
    for (const i of this.chart.data.datasets)
      e[ee(this.chart.options.indexAxis === "x" ? i.xAxisID : i.yAxisID, t)] = !0;
    return Object.keys(e);
  }
  _getStackIndex(e, t, i) {
    const r = this._getStacks(e, i), n = t !== void 0 ? r.indexOf(t) : -1;
    return n === -1 ? r.length - 1 : n;
  }
  _getRuler() {
    const e = this.options, t = this._cachedMeta, i = t.iScale, r = [];
    let n, o;
    for (n = 0, o = t.data.length; n < o; ++n)
      r.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));
    const a = e.barThickness;
    return {
      min: a || _p(t),
      pixels: r,
      start: i._startPixel,
      end: i._endPixel,
      stackCount: this._getStackCount(),
      scale: i,
      grouped: e.grouped,
      ratio: a ? 1 : e.categoryPercentage * e.barPercentage
    };
  }
  _calculateBarValuePixels(e) {
    const { _cachedMeta: { vScale: t, _stacked: i, index: r }, options: { base: n, minBarLength: o } } = this, a = n || 0, l = this.getParsed(e), c = l._custom, u = co(c);
    let h = l[t.axis], f = 0, m = i ? this.applyStack(t, l, i) : h, _, v;
    m !== h && (f = m - h, m = h), u && (h = c.barStart, m = c.barEnd - c.barStart, h !== 0 && At(h) !== At(c.barEnd) && (f = 0), f += h);
    const d = !oe(n) && !u ? n : f;
    let p = t.getPixelForValue(d);
    if (this.chart.getDataVisibility(e) ? _ = t.getPixelForValue(f + m) : _ = p, v = _ - p, Math.abs(v) < o) {
      v = kp(v, t, a) * o, h === a && (p -= v / 2);
      const g = t.getPixelForDecimal(0), b = t.getPixelForDecimal(1), y = Math.min(g, b), w = Math.max(g, b);
      p = Math.max(Math.min(p, w), y), _ = p + v, i && !u && (l._stacks[t.axis]._visualValues[r] = t.getValueForPixel(_) - t.getValueForPixel(p));
    }
    if (p === t.getPixelForValue(a)) {
      const g = At(v) * t.getLineWidthForValue(a) / 2;
      p += g, v -= g;
    }
    return {
      size: v,
      base: p,
      head: _,
      center: _ + v / 2
    };
  }
  _calculateBarIndexPixels(e, t) {
    const i = t.scale, r = this.options, n = r.skipNull, o = ee(r.maxBarThickness, 1 / 0);
    let a, l;
    const c = this._getAxisCount();
    if (t.grouped) {
      const u = n ? this._getStackCount(e) : t.stackCount, h = r.barThickness === "flex" ? wp(e, t, r, u * c) : yp(e, t, r, u * c), f = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, m = this._getAxis().indexOf(ee(f, this.getFirstScaleIdForIndexAxis())), _ = this._getStackIndex(this.index, this._cachedMeta.stack, n ? e : void 0) + m;
      a = h.start + h.chunk * _ + h.chunk / 2, l = Math.min(o, h.chunk * h.ratio);
    } else
      a = i.getPixelForValue(this.getParsed(e)[i.axis], e), l = Math.min(o, t.min * t.ratio);
    return {
      base: a - l / 2,
      head: a + l / 2,
      center: a,
      size: l
    };
  }
  draw() {
    const e = this._cachedMeta, t = e.vScale, i = e.data, r = i.length;
    let n = 0;
    for (; n < r; ++n)
      this.getParsed(n)[t.axis] !== null && !i[n].hidden && i[n].draw(this._ctx);
  }
}
K(Vr, "id", "bar"), K(Vr, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), K(Vr, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class qr extends vt {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(e, t, i, r) {
    const n = super.parsePrimitiveData(e, t, i, r);
    for (let o = 0; o < n.length; o++)
      n[o]._custom = this.resolveDataElementOptions(o + i).radius;
    return n;
  }
  parseArrayData(e, t, i, r) {
    const n = super.parseArrayData(e, t, i, r);
    for (let o = 0; o < n.length; o++) {
      const a = t[i + o];
      n[o]._custom = ee(a[2], this.resolveDataElementOptions(o + i).radius);
    }
    return n;
  }
  parseObjectData(e, t, i, r) {
    const n = super.parseObjectData(e, t, i, r);
    for (let o = 0; o < n.length; o++) {
      const a = t[i + o];
      n[o]._custom = ee(a && a.r && +a.r, this.resolveDataElementOptions(o + i).radius);
    }
    return n;
  }
  getMaxOverflow() {
    const e = this._cachedMeta.data;
    let t = 0;
    for (let i = e.length - 1; i >= 0; --i)
      t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);
    return t > 0 && t;
  }
  getLabelAndValue(e) {
    const t = this._cachedMeta, i = this.chart.data.labels || [], { xScale: r, yScale: n } = t, o = this.getParsed(e), a = r.getLabelForValue(o.x), l = n.getLabelForValue(o.y), c = o._custom;
    return {
      label: i[e] || "",
      value: "(" + a + ", " + l + (c ? ", " + c : "") + ")"
    };
  }
  update(e) {
    const t = this._cachedMeta.data;
    this.updateElements(t, 0, t.length, e);
  }
  updateElements(e, t, i, r) {
    const n = r === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(t, r), u = o.axis, h = a.axis;
    for (let f = t; f < t + i; f++) {
      const m = e[f], _ = !n && this.getParsed(f), v = {}, d = v[u] = n ? o.getPixelForDecimal(0.5) : o.getPixelForValue(_[u]), p = v[h] = n ? a.getBasePixel() : a.getPixelForValue(_[h]);
      v.skip = isNaN(d) || isNaN(p), c && (v.options = l || this.resolveDataElementOptions(f, m.active ? "active" : r), n && (v.options.radius = 0)), this.updateElement(m, f, v, r);
    }
  }
  resolveDataElementOptions(e, t) {
    const i = this.getParsed(e);
    let r = super.resolveDataElementOptions(e, t);
    r.$shared && (r = Object.assign({}, r, {
      $shared: !1
    }));
    const n = r.radius;
    return t !== "active" && (r.radius = 0), r.radius += ee(i && i._custom, n), r;
  }
}
K(qr, "id", "bubble"), K(qr, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), K(qr, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function Ap(s, e, t) {
  let i = 1, r = 1, n = 0, o = 0;
  if (e < _e) {
    const a = s, l = a + e, c = Math.cos(a), u = Math.sin(a), h = Math.cos(l), f = Math.sin(l), m = (b, y, w) => er(b, a, l, !0) ? 1 : Math.max(y, y * t, w, w * t), _ = (b, y, w) => er(b, a, l, !0) ? -1 : Math.min(y, y * t, w, w * t), v = m(0, c, h), d = m(Le, u, f), p = _(ce, c, h), g = _(ce + Le, u, f);
    i = (v - p) / 2, r = (d - g) / 2, n = -(v + p) / 2, o = -(d + g) / 2;
  }
  return {
    ratioX: i,
    ratioY: r,
    offsetX: n,
    offsetY: o
  };
}
class ys extends vt {
  constructor(e, t) {
    super(e, t), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, t) {
    const i = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = i;
    else {
      let n = (l) => +i[l];
      if (ae(i[e])) {
        const { key: l = "value" } = this._parsing;
        n = (c) => +ns(i[c], l);
      }
      let o, a;
      for (o = e, a = e + t; o < a; ++o)
        r._parsed[o] = n(o);
    }
  }
  _getRotation() {
    return bt(this.options.rotation - 90);
  }
  _getCircumference() {
    return bt(this.options.circumference);
  }
  _getRotationExtents() {
    let e = _e, t = -_e;
    for (let i = 0; i < this.chart.data.datasets.length; ++i)
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const r = this.chart.getDatasetMeta(i).controller, n = r._getRotation(), o = r._getCircumference();
        e = Math.min(e, n), t = Math.max(t, n + o);
      }
    return {
      rotation: e,
      circumference: t - e
    };
  }
  update(e) {
    const t = this.chart, { chartArea: i } = t, r = this._cachedMeta, n = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), l = Math.min(Fu(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: h } = this._getRotationExtents(), { ratioX: f, ratioY: m, offsetX: _, offsetY: v } = Ap(h, u, l), d = (i.width - o) / f, p = (i.height - o) / m, g = Math.max(Math.min(d, p) / 2, 0), b = Qc(this.options.radius, g), y = Math.max(b * l, 0), w = (b - y) / this._getVisibleDatasetWeightTotal();
    this.offsetX = _ * b, this.offsetY = v * b, r.total = this.calculateTotal(), this.outerRadius = b - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * c, 0), this.updateElements(n, 0, n.length, e);
  }
  _circumference(e, t) {
    const i = this.options, r = this._cachedMeta, n = this._getCircumference();
    return t && i.animation.animateRotate || !this.chart.getDataVisibility(e) || r._parsed[e] === null || r.data[e].hidden ? 0 : this.calculateCircumference(r._parsed[e] * n / _e);
  }
  updateElements(e, t, i, r) {
    const n = r === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, u = (a.left + a.right) / 2, h = (a.top + a.bottom) / 2, f = n && c.animateScale, m = f ? 0 : this.innerRadius, _ = f ? 0 : this.outerRadius, { sharedOptions: v, includeOptions: d } = this._getSharedOptions(t, r);
    let p = this._getRotation(), g;
    for (g = 0; g < t; ++g)
      p += this._circumference(g, n);
    for (g = t; g < t + i; ++g) {
      const b = this._circumference(g, n), y = e[g], w = {
        x: u + this.offsetX,
        y: h + this.offsetY,
        startAngle: p,
        endAngle: p + b,
        circumference: b,
        outerRadius: _,
        innerRadius: m
      };
      d && (w.options = v || this.resolveDataElementOptions(g, y.active ? "active" : r)), p += b, this.updateElement(y, g, w, r);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, t = e.data;
    let i = 0, r;
    for (r = 0; r < t.length; r++) {
      const n = e._parsed[r];
      n !== null && !isNaN(n) && this.chart.getDataVisibility(r) && !t[r].hidden && (i += Math.abs(n));
    }
    return i;
  }
  calculateCircumference(e) {
    const t = this._cachedMeta.total;
    return t > 0 && !isNaN(e) ? _e * (Math.abs(e) / t) : 0;
  }
  getLabelAndValue(e) {
    const t = this._cachedMeta, i = this.chart, r = i.data.labels || [], n = gr(t._parsed[e], i.options.locale);
    return {
      label: r[e] || "",
      value: n
    };
  }
  getMaxBorderWidth(e) {
    let t = 0;
    const i = this.chart;
    let r, n, o, a, l;
    if (!e) {
      for (r = 0, n = i.data.datasets.length; r < n; ++r)
        if (i.isDatasetVisible(r)) {
          o = i.getDatasetMeta(r), e = o.data, a = o.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (r = 0, n = e.length; r < n; ++r)
      l = a.resolveDataElementOptions(r), l.borderAlign !== "inner" && (t = Math.max(t, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return t;
  }
  getMaxOffset(e) {
    let t = 0;
    for (let i = 0, r = e.length; i < r; ++i) {
      const n = this.resolveDataElementOptions(i);
      t = Math.max(t, n.offset || 0, n.hoverOffset || 0);
    }
    return t;
  }
  _getRingWeightOffset(e) {
    let t = 0;
    for (let i = 0; i < e; ++i)
      this.chart.isDatasetVisible(i) && (t += this._getRingWeight(i));
    return t;
  }
  _getRingWeight(e) {
    return Math.max(ee(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
K(ys, "id", "doughnut"), K(ys, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), K(ys, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), K(ys, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const t = e.data;
          if (t.labels.length && t.datasets.length) {
            const { labels: { pointStyle: i, color: r } } = e.legend.options;
            return t.labels.map((n, o) => {
              const l = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: n,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: r,
                lineWidth: l.borderWidth,
                pointStyle: i,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, t, i) {
        i.chart.toggleDataVisibility(t.index), i.chart.update();
      }
    }
  }
});
class Kr extends vt {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(e) {
    const t = this._cachedMeta, { dataset: i, data: r = [], _dataset: n } = t, o = this.chart._animationsDisabled;
    let { start: a, count: l } = sh(t, r, o);
    this._drawStart = a, this._drawCount = l, ih(t) && (a = 0, l = r.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = r;
    const c = this.resolveDatasetElementOptions(e);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(i, void 0, {
      animated: !o,
      options: c
    }, e), this.updateElements(r, a, l, e);
  }
  updateElements(e, t, i, r) {
    const n = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: h } = this._getSharedOptions(t, r), f = o.axis, m = a.axis, { spanGaps: _, segment: v } = this.options, d = oi(_) ? _ : Number.POSITIVE_INFINITY, p = this.chart._animationsDisabled || n || r === "none", g = t + i, b = e.length;
    let y = t > 0 && this.getParsed(t - 1);
    for (let w = 0; w < b; ++w) {
      const k = e[w], C = p ? k : {};
      if (w < t || w >= g) {
        C.skip = !0;
        continue;
      }
      const x = this.getParsed(w), S = oe(x[m]), T = C[f] = o.getPixelForValue(x[f], w), M = C[m] = n || S ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, x, l) : x[m], w);
      C.skip = isNaN(T) || isNaN(M) || S, C.stop = w > 0 && Math.abs(x[f] - y[f]) > d, v && (C.parsed = x, C.raw = c.data[w]), h && (C.options = u || this.resolveDataElementOptions(w, k.active ? "active" : r)), p || this.updateElement(k, w, C, r), y = x;
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta, t = e.dataset, i = t.options && t.options.borderWidth || 0, r = e.data || [];
    if (!r.length)
      return i;
    const n = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(i, n, o) / 2;
  }
  draw() {
    const e = this._cachedMeta;
    e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
  }
}
K(Kr, "id", "line"), K(Kr, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), K(Kr, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class qi extends vt {
  constructor(e, t) {
    super(e, t), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(e) {
    const t = this._cachedMeta, i = this.chart, r = i.data.labels || [], n = gr(t._parsed[e].r, i.options.locale);
    return {
      label: r[e] || "",
      value: n
    };
  }
  parseObjectData(e, t, i, r) {
    return dh.bind(this)(e, t, i, r);
  }
  update(e) {
    const t = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(t, 0, t.length, e);
  }
  getMinMax() {
    const e = this._cachedMeta, t = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return e.data.forEach((i, r) => {
      const n = this.getParsed(r).r;
      !isNaN(n) && this.chart.getDataVisibility(r) && (n < t.min && (t.min = n), n > t.max && (t.max = n));
    }), t;
  }
  _updateRadius() {
    const e = this.chart, t = e.chartArea, i = e.options, r = Math.min(t.right - t.left, t.bottom - t.top), n = Math.max(r / 2, 0), o = Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0), a = (n - o) / e.getVisibleDatasetCount();
    this.outerRadius = n - a * this.index, this.innerRadius = this.outerRadius - a;
  }
  updateElements(e, t, i, r) {
    const n = r === "reset", o = this.chart, l = o.options.animation, c = this._cachedMeta.rScale, u = c.xCenter, h = c.yCenter, f = c.getIndexAngle(0) - 0.5 * ce;
    let m = f, _;
    const v = 360 / this.countVisibleElements();
    for (_ = 0; _ < t; ++_)
      m += this._computeAngle(_, r, v);
    for (_ = t; _ < t + i; _++) {
      const d = e[_];
      let p = m, g = m + this._computeAngle(_, r, v), b = o.getDataVisibility(_) ? c.getDistanceFromCenterForValue(this.getParsed(_).r) : 0;
      m = g, n && (l.animateScale && (b = 0), l.animateRotate && (p = g = f));
      const y = {
        x: u,
        y: h,
        innerRadius: 0,
        outerRadius: b,
        startAngle: p,
        endAngle: g,
        options: this.resolveDataElementOptions(_, d.active ? "active" : r)
      };
      this.updateElement(d, _, y, r);
    }
  }
  countVisibleElements() {
    const e = this._cachedMeta;
    let t = 0;
    return e.data.forEach((i, r) => {
      !isNaN(this.getParsed(r).r) && this.chart.getDataVisibility(r) && t++;
    }), t;
  }
  _computeAngle(e, t, i) {
    return this.chart.getDataVisibility(e) ? bt(this.resolveDataElementOptions(e, t).angle || i) : 0;
  }
}
K(qi, "id", "polarArea"), K(qi, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), K(qi, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const t = e.data;
          if (t.labels.length && t.datasets.length) {
            const { labels: { pointStyle: i, color: r } } = e.legend.options;
            return t.labels.map((n, o) => {
              const l = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: n,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: r,
                lineWidth: l.borderWidth,
                pointStyle: i,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, t, i) {
        i.chart.toggleDataVisibility(t.index), i.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class To extends ys {
}
K(To, "id", "pie"), K(To, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class Qr extends vt {
  getLabelAndValue(e) {
    const t = this._cachedMeta.vScale, i = this.getParsed(e);
    return {
      label: t.getLabels()[e],
      value: "" + t.getLabelForValue(i[t.axis])
    };
  }
  parseObjectData(e, t, i, r) {
    return dh.bind(this)(e, t, i, r);
  }
  update(e) {
    const t = this._cachedMeta, i = t.dataset, r = t.data || [], n = t.iScale.getLabels();
    if (i.points = r, e !== "resize") {
      const o = this.resolveDatasetElementOptions(e);
      this.options.showLine || (o.borderWidth = 0);
      const a = {
        _loop: !0,
        _fullLoop: n.length === r.length,
        options: o
      };
      this.updateElement(i, void 0, a, e);
    }
    this.updateElements(r, 0, r.length, e);
  }
  updateElements(e, t, i, r) {
    const n = this._cachedMeta.rScale, o = r === "reset";
    for (let a = t; a < t + i; a++) {
      const l = e[a], c = this.resolveDataElementOptions(a, l.active ? "active" : r), u = n.getPointPositionForValue(a, this.getParsed(a).r), h = o ? n.xCenter : u.x, f = o ? n.yCenter : u.y, m = {
        x: h,
        y: f,
        angle: u.angle,
        skip: isNaN(h) || isNaN(f),
        options: c
      };
      this.updateElement(l, a, m, r);
    }
  }
}
K(Qr, "id", "radar"), K(Qr, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), K(Qr, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class Yr extends vt {
  getLabelAndValue(e) {
    const t = this._cachedMeta, i = this.chart.data.labels || [], { xScale: r, yScale: n } = t, o = this.getParsed(e), a = r.getLabelForValue(o.x), l = n.getLabelForValue(o.y);
    return {
      label: i[e] || "",
      value: "(" + a + ", " + l + ")"
    };
  }
  update(e) {
    const t = this._cachedMeta, { data: i = [] } = t, r = this.chart._animationsDisabled;
    let { start: n, count: o } = sh(t, i, r);
    if (this._drawStart = n, this._drawCount = o, ih(t) && (n = 0, o = i.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: a, _dataset: l } = t;
      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = i;
      const c = this.resolveDatasetElementOptions(e);
      c.segment = this.options.segment, this.updateElement(a, void 0, {
        animated: !r,
        options: c
      }, e);
    } else this.datasetElementType && (delete t.dataset, this.datasetElementType = !1);
    this.updateElements(i, n, o, e);
  }
  addElements() {
    const { showLine: e } = this.options;
    !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(e, t, i, r) {
    const n = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, u = this.resolveDataElementOptions(t, r), h = this.getSharedOptions(u), f = this.includeOptions(r, h), m = o.axis, _ = a.axis, { spanGaps: v, segment: d } = this.options, p = oi(v) ? v : Number.POSITIVE_INFINITY, g = this.chart._animationsDisabled || n || r === "none";
    let b = t > 0 && this.getParsed(t - 1);
    for (let y = t; y < t + i; ++y) {
      const w = e[y], k = this.getParsed(y), C = g ? w : {}, x = oe(k[_]), S = C[m] = o.getPixelForValue(k[m], y), T = C[_] = n || x ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, k, l) : k[_], y);
      C.skip = isNaN(S) || isNaN(T) || x, C.stop = y > 0 && Math.abs(k[m] - b[m]) > p, d && (C.parsed = k, C.raw = c.data[y]), f && (C.options = h || this.resolveDataElementOptions(y, w.active ? "active" : r)), g || this.updateElement(w, y, C, r), b = k;
    }
    this.updateSharedOptions(h, r, u);
  }
  getMaxOverflow() {
    const e = this._cachedMeta, t = e.data || [];
    if (!this.options.showLine) {
      let a = 0;
      for (let l = t.length - 1; l >= 0; --l)
        a = Math.max(a, t[l].size(this.resolveDataElementOptions(l)) / 2);
      return a > 0 && a;
    }
    const i = e.dataset, r = i.options && i.options.borderWidth || 0;
    if (!t.length)
      return r;
    const n = t[0].size(this.resolveDataElementOptions(0)), o = t[t.length - 1].size(this.resolveDataElementOptions(t.length - 1));
    return Math.max(r, n, o) / 2;
  }
}
K(Yr, "id", "scatter"), K(Yr, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), K(Yr, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var Ep = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: Vr,
  BubbleController: qr,
  DoughnutController: ys,
  LineController: Kr,
  PieController: To,
  PolarAreaController: qi,
  RadarController: Qr,
  ScatterController: Yr
});
function gs() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class ga {
  constructor(e) {
    K(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(ga.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return gs();
  }
  parse() {
    return gs();
  }
  format() {
    return gs();
  }
  add() {
    return gs();
  }
  diff() {
    return gs();
  }
  startOf() {
    return gs();
  }
  endOf() {
    return gs();
  }
}
var Tp = {
  _date: ga
};
function Lp(s, e, t, i) {
  const { controller: r, data: n, _sorted: o } = s, a = r._cachedMeta.iScale, l = s.dataset && s.dataset.options ? s.dataset.options.spanGaps : null;
  if (a && e === a.axis && e !== "r" && o && n.length) {
    const c = a._reversePixels ? Ju : Ht;
    if (i) {
      if (r._sharedOptions) {
        const u = n[0], h = typeof u.getRange == "function" && u.getRange(e);
        if (h) {
          const f = c(n, e, t - h), m = c(n, e, t + h);
          return {
            lo: f.lo,
            hi: m.hi
          };
        }
      }
    } else {
      const u = c(n, e, t);
      if (l) {
        const { vScale: h } = r._cachedMeta, { _parsed: f } = s, m = f.slice(0, u.lo + 1).reverse().findIndex((v) => !oe(v[h.axis]));
        u.lo -= Math.max(0, m);
        const _ = f.slice(u.hi).findIndex((v) => !oe(v[h.axis]));
        u.hi += Math.max(0, _);
      }
      return u;
    }
  }
  return {
    lo: 0,
    hi: n.length - 1
  };
}
function Dn(s, e, t, i, r) {
  const n = s.getSortedVisibleDatasetMetas(), o = t[e];
  for (let a = 0, l = n.length; a < l; ++a) {
    const { index: c, data: u } = n[a], { lo: h, hi: f } = Lp(n[a], e, o, r);
    for (let m = h; m <= f; ++m) {
      const _ = u[m];
      _.skip || i(_, c, m);
    }
  }
}
function Mp(s) {
  const e = s.indexOf("x") !== -1, t = s.indexOf("y") !== -1;
  return function(i, r) {
    const n = e ? Math.abs(i.x - r.x) : 0, o = t ? Math.abs(i.y - r.y) : 0;
    return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));
  };
}
function ho(s, e, t, i, r) {
  const n = [];
  return !r && !s.isPointInArea(e) || Dn(s, t, e, function(a, l, c) {
    !r && !jt(a, s.chartArea, 0) || a.inRange(e.x, e.y, i) && n.push({
      element: a,
      datasetIndex: l,
      index: c
    });
  }, !0), n;
}
function Ip(s, e, t, i) {
  let r = [];
  function n(o, a, l) {
    const { startAngle: c, endAngle: u } = o.getProps([
      "startAngle",
      "endAngle"
    ], i), { angle: h } = Xc(o, {
      x: e.x,
      y: e.y
    });
    er(h, c, u) && r.push({
      element: o,
      datasetIndex: a,
      index: l
    });
  }
  return Dn(s, t, e, n), r;
}
function Rp(s, e, t, i, r, n) {
  let o = [];
  const a = Mp(t);
  let l = Number.POSITIVE_INFINITY;
  function c(u, h, f) {
    const m = u.inRange(e.x, e.y, r);
    if (i && !m)
      return;
    const _ = u.getCenterPoint(r);
    if (!(!!n || s.isPointInArea(_)) && !m)
      return;
    const d = a(e, _);
    d < l ? (o = [
      {
        element: u,
        datasetIndex: h,
        index: f
      }
    ], l = d) : d === l && o.push({
      element: u,
      datasetIndex: h,
      index: f
    });
  }
  return Dn(s, t, e, c), o;
}
function uo(s, e, t, i, r, n) {
  return !n && !s.isPointInArea(e) ? [] : t === "r" && !i ? Ip(s, e, t, r) : Rp(s, e, t, i, r, n);
}
function Bl(s, e, t, i, r) {
  const n = [], o = t === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return Dn(s, t, e, (l, c, u) => {
    l[o] && l[o](e[t], r) && (n.push({
      element: l,
      datasetIndex: c,
      index: u
    }), a = a || l.inRange(e.x, e.y, r));
  }), i && !a ? [] : n;
}
var Op = {
  modes: {
    index(s, e, t, i) {
      const r = bs(e, s), n = t.axis || "x", o = t.includeInvisible || !1, a = t.intersect ? ho(s, r, n, i, o) : uo(s, r, n, !1, i, o), l = [];
      return a.length ? (s.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = a[0].index, h = c.data[u];
        h && !h.skip && l.push({
          element: h,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(s, e, t, i) {
      const r = bs(e, s), n = t.axis || "xy", o = t.includeInvisible || !1;
      let a = t.intersect ? ho(s, r, n, i, o) : uo(s, r, n, !1, i, o);
      if (a.length > 0) {
        const l = a[0].datasetIndex, c = s.getDatasetMeta(l).data;
        a = [];
        for (let u = 0; u < c.length; ++u)
          a.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return a;
    },
    point(s, e, t, i) {
      const r = bs(e, s), n = t.axis || "xy", o = t.includeInvisible || !1;
      return ho(s, r, n, i, o);
    },
    nearest(s, e, t, i) {
      const r = bs(e, s), n = t.axis || "xy", o = t.includeInvisible || !1;
      return uo(s, r, n, t.intersect, i, o);
    },
    x(s, e, t, i) {
      const r = bs(e, s);
      return Bl(s, r, "x", t.intersect, i);
    },
    y(s, e, t, i) {
      const r = bs(e, s);
      return Bl(s, r, "y", t.intersect, i);
    }
  }
};
const xh = [
  "left",
  "top",
  "right",
  "bottom"
];
function $i(s, e) {
  return s.filter((t) => t.pos === e);
}
function Nl(s, e) {
  return s.filter((t) => xh.indexOf(t.pos) === -1 && t.box.axis === e);
}
function Ai(s, e) {
  return s.sort((t, i) => {
    const r = e ? i : t, n = e ? t : i;
    return r.weight === n.weight ? r.index - n.index : r.weight - n.weight;
  });
}
function Pp(s) {
  const e = [];
  let t, i, r, n, o, a;
  for (t = 0, i = (s || []).length; t < i; ++t)
    r = s[t], { position: n, options: { stack: o, stackWeight: a = 1 } } = r, e.push({
      index: t,
      box: r,
      pos: n,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: o && n + o,
      stackWeight: a
    });
  return e;
}
function Bp(s) {
  const e = {};
  for (const t of s) {
    const { stack: i, pos: r, stackWeight: n } = t;
    if (!i || !xh.includes(r))
      continue;
    const o = e[i] || (e[i] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += n;
  }
  return e;
}
function Np(s, e) {
  const t = Bp(s), { vBoxMaxWidth: i, hBoxMaxHeight: r } = e;
  let n, o, a;
  for (n = 0, o = s.length; n < o; ++n) {
    a = s[n];
    const { fullSize: l } = a.box, c = t[a.stack], u = c && a.stackWeight / c.weight;
    a.horizontal ? (a.width = u ? u * i : l && e.availableWidth, a.height = r) : (a.width = i, a.height = u ? u * r : l && e.availableHeight);
  }
  return t;
}
function Fp(s) {
  const e = Pp(s), t = Ai(e.filter((c) => c.box.fullSize), !0), i = Ai($i(e, "left"), !0), r = Ai($i(e, "right")), n = Ai($i(e, "top"), !0), o = Ai($i(e, "bottom")), a = Nl(e, "x"), l = Nl(e, "y");
  return {
    fullSize: t,
    leftAndTop: i.concat(n),
    rightAndBottom: r.concat(l).concat(o).concat(a),
    chartArea: $i(e, "chartArea"),
    vertical: i.concat(r).concat(l),
    horizontal: n.concat(o).concat(a)
  };
}
function Fl(s, e, t, i) {
  return Math.max(s[t], e[t]) + Math.max(s[i], e[i]);
}
function kh(s, e) {
  s.top = Math.max(s.top, e.top), s.left = Math.max(s.left, e.left), s.bottom = Math.max(s.bottom, e.bottom), s.right = Math.max(s.right, e.right);
}
function zp(s, e, t, i) {
  const { pos: r, box: n } = t, o = s.maxPadding;
  if (!ae(r)) {
    t.size && (s[r] -= t.size);
    const h = i[t.stack] || {
      size: 0,
      count: 1
    };
    h.size = Math.max(h.size, t.horizontal ? n.height : n.width), t.size = h.size / h.count, s[r] += t.size;
  }
  n.getPadding && kh(o, n.getPadding());
  const a = Math.max(0, e.outerWidth - Fl(o, s, "left", "right")), l = Math.max(0, e.outerHeight - Fl(o, s, "top", "bottom")), c = a !== s.w, u = l !== s.h;
  return s.w = a, s.h = l, t.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function Hp(s) {
  const e = s.maxPadding;
  function t(i) {
    const r = Math.max(e[i] - s[i], 0);
    return s[i] += r, r;
  }
  s.y += t("top"), s.x += t("left"), t("right"), t("bottom");
}
function jp(s, e) {
  const t = e.maxPadding;
  function i(r) {
    const n = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((o) => {
      n[o] = Math.max(e[o], t[o]);
    }), n;
  }
  return i(s ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Oi(s, e, t, i) {
  const r = [];
  let n, o, a, l, c, u;
  for (n = 0, o = s.length, c = 0; n < o; ++n) {
    a = s[n], l = a.box, l.update(a.width || e.w, a.height || e.h, jp(a.horizontal, e));
    const { same: h, other: f } = zp(e, t, a, i);
    c |= h && r.length, u = u || f, l.fullSize || r.push(a);
  }
  return c && Oi(r, e, t, i) || u;
}
function Mr(s, e, t, i, r) {
  s.top = t, s.left = e, s.right = e + i, s.bottom = t + r, s.width = i, s.height = r;
}
function zl(s, e, t, i) {
  const r = t.padding;
  let { x: n, y: o } = e;
  for (const a of s) {
    const l = a.box, c = i[a.stack] || {
      placed: 0,
      weight: 1
    }, u = a.stackWeight / c.weight || 1;
    if (a.horizontal) {
      const h = e.w * u, f = c.size || l.height;
      Zi(c.start) && (o = c.start), l.fullSize ? Mr(l, r.left, o, t.outerWidth - r.right - r.left, f) : Mr(l, e.left + c.placed, o, h, f), c.start = o, c.placed += h, o = l.bottom;
    } else {
      const h = e.h * u, f = c.size || l.width;
      Zi(c.start) && (n = c.start), l.fullSize ? Mr(l, n, r.top, f, t.outerHeight - r.bottom - r.top) : Mr(l, n, e.top + c.placed, f, h), c.start = n, c.placed += h, n = l.right;
    }
  }
  e.x = n, e.y = o;
}
var Ye = {
  addBox(s, e) {
    s.boxes || (s.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(t) {
            e.draw(t);
          }
        }
      ];
    }, s.boxes.push(e);
  },
  removeBox(s, e) {
    const t = s.boxes ? s.boxes.indexOf(e) : -1;
    t !== -1 && s.boxes.splice(t, 1);
  },
  configure(s, e, t) {
    e.fullSize = t.fullSize, e.position = t.position, e.weight = t.weight;
  },
  update(s, e, t, i) {
    if (!s)
      return;
    const r = Xe(s.options.layout.padding), n = Math.max(e - r.width, 0), o = Math.max(t - r.height, 0), a = Fp(s.boxes), l = a.vertical, c = a.horizontal;
    ue(s.boxes, (v) => {
      typeof v.beforeLayout == "function" && v.beforeLayout();
    });
    const u = l.reduce((v, d) => d.box.options && d.box.options.display === !1 ? v : v + 1, 0) || 1, h = Object.freeze({
      outerWidth: e,
      outerHeight: t,
      padding: r,
      availableWidth: n,
      availableHeight: o,
      vBoxMaxWidth: n / 2 / u,
      hBoxMaxHeight: o / 2
    }), f = Object.assign({}, r);
    kh(f, Xe(i));
    const m = Object.assign({
      maxPadding: f,
      w: n,
      h: o,
      x: r.left,
      y: r.top
    }, r), _ = Np(l.concat(c), h);
    Oi(a.fullSize, m, h, _), Oi(l, m, h, _), Oi(c, m, h, _) && Oi(l, m, h, _), Hp(m), zl(a.leftAndTop, m, h, _), m.x += m.w, m.y += m.h, zl(a.rightAndBottom, m, h, _), s.chartArea = {
      left: m.left,
      top: m.top,
      right: m.left + m.w,
      bottom: m.top + m.h,
      height: m.h,
      width: m.w
    }, ue(a.chartArea, (v) => {
      const d = v.box;
      Object.assign(d, s.chartArea), d.update(m.w, m.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Sh {
  acquireContext(e, t) {
  }
  releaseContext(e) {
    return !1;
  }
  addEventListener(e, t, i) {
  }
  removeEventListener(e, t, i) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, t, i, r) {
    return t = Math.max(0, t || e.width), i = i || e.height, {
      width: t,
      height: Math.max(0, r ? Math.floor(t / r) : i)
    };
  }
  isAttached(e) {
    return !0;
  }
  updateConfig(e) {
  }
}
class Up extends Sh {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = !1;
  }
}
const Gr = "$chartjs", Wp = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Hl = (s) => s === null || s === "";
function Vp(s, e) {
  const t = s.style, i = s.getAttribute("height"), r = s.getAttribute("width");
  if (s[Gr] = {
    initial: {
      height: i,
      width: r,
      style: {
        display: t.display,
        height: t.height,
        width: t.width
      }
    }
  }, t.display = t.display || "block", t.boxSizing = t.boxSizing || "border-box", Hl(r)) {
    const n = Sl(s, "width");
    n !== void 0 && (s.width = n);
  }
  if (Hl(i))
    if (s.style.height === "")
      s.height = s.width / (e || 2);
    else {
      const n = Sl(s, "height");
      n !== void 0 && (s.height = n);
    }
  return s;
}
const Ch = qf ? {
  passive: !0
} : !1;
function qp(s, e, t) {
  s && s.addEventListener(e, t, Ch);
}
function Kp(s, e, t) {
  s && s.canvas && s.canvas.removeEventListener(e, t, Ch);
}
function Qp(s, e) {
  const t = Wp[s.type] || s.type, { x: i, y: r } = bs(s, e);
  return {
    type: t,
    chart: e,
    native: s,
    x: i !== void 0 ? i : null,
    y: r !== void 0 ? r : null
  };
}
function un(s, e) {
  for (const t of s)
    if (t === e || t.contains(e))
      return !0;
}
function Yp(s, e, t) {
  const i = s.canvas, r = new MutationObserver((n) => {
    let o = !1;
    for (const a of n)
      o = o || un(a.addedNodes, i), o = o && !un(a.removedNodes, i);
    o && t();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function Gp(s, e, t) {
  const i = s.canvas, r = new MutationObserver((n) => {
    let o = !1;
    for (const a of n)
      o = o || un(a.removedNodes, i), o = o && !un(a.addedNodes, i);
    o && t();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const sr = /* @__PURE__ */ new Map();
let jl = 0;
function Dh() {
  const s = window.devicePixelRatio;
  s !== jl && (jl = s, sr.forEach((e, t) => {
    t.currentDevicePixelRatio !== s && e();
  }));
}
function Xp(s, e) {
  sr.size || window.addEventListener("resize", Dh), sr.set(s, e);
}
function Jp(s) {
  sr.delete(s), sr.size || window.removeEventListener("resize", Dh);
}
function Zp(s, e, t) {
  const i = s.canvas, r = i && pa(i);
  if (!r)
    return;
  const n = th((a, l) => {
    const c = r.clientWidth;
    t(a, l), c < r.clientWidth && t();
  }, window), o = new ResizeObserver((a) => {
    const l = a[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || n(c, u);
  });
  return o.observe(r), Xp(s, n), o;
}
function fo(s, e, t) {
  t && t.disconnect(), e === "resize" && Jp(s);
}
function eg(s, e, t) {
  const i = s.canvas, r = th((n) => {
    s.ctx !== null && t(Qp(n, s));
  }, s);
  return qp(i, e, r), r;
}
class tg extends Sh {
  acquireContext(e, t) {
    const i = e && e.getContext && e.getContext("2d");
    return i && i.canvas === e ? (Vp(e, t), i) : null;
  }
  releaseContext(e) {
    const t = e.canvas;
    if (!t[Gr])
      return !1;
    const i = t[Gr].initial;
    [
      "height",
      "width"
    ].forEach((n) => {
      const o = i[n];
      oe(o) ? t.removeAttribute(n) : t.setAttribute(n, o);
    });
    const r = i.style || {};
    return Object.keys(r).forEach((n) => {
      t.style[n] = r[n];
    }), t.width = t.width, delete t[Gr], !0;
  }
  addEventListener(e, t, i) {
    this.removeEventListener(e, t);
    const r = e.$proxies || (e.$proxies = {}), o = {
      attach: Yp,
      detach: Gp,
      resize: Zp
    }[t] || eg;
    r[t] = o(e, t, i);
  }
  removeEventListener(e, t) {
    const i = e.$proxies || (e.$proxies = {}), r = i[t];
    if (!r)
      return;
    ({
      attach: fo,
      detach: fo,
      resize: fo
    }[t] || Kp)(e, t, r), i[t] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, t, i, r) {
    return Vf(e, t, i, r);
  }
  isAttached(e) {
    const t = e && pa(e);
    return !!(t && t.isConnected);
  }
}
function sg(s) {
  return !fa() || typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas ? Up : tg;
}
class _t {
  constructor() {
    K(this, "x");
    K(this, "y");
    K(this, "active", !1);
    K(this, "options");
    K(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: t, y: i } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: t,
      y: i
    };
  }
  hasValue() {
    return oi(this.x) && oi(this.y);
  }
  getProps(e, t) {
    const i = this.$animations;
    if (!t || !i)
      return this;
    const r = {};
    return e.forEach((n) => {
      r[n] = i[n] && i[n].active() ? i[n]._to : this[n];
    }), r;
  }
}
K(_t, "defaults", {}), K(_t, "defaultRoutes");
function ig(s, e) {
  const t = s.options.ticks, i = rg(s), r = Math.min(t.maxTicksLimit || i, i), n = t.major.enabled ? og(e) : [], o = n.length, a = n[0], l = n[o - 1], c = [];
  if (o > r)
    return ag(e, c, n, o / r), c;
  const u = ng(n, e, r);
  if (o > 0) {
    let h, f;
    const m = o > 1 ? Math.round((l - a) / (o - 1)) : null;
    for (Ir(e, c, u, oe(m) ? 0 : a - m, a), h = 0, f = o - 1; h < f; h++)
      Ir(e, c, u, n[h], n[h + 1]);
    return Ir(e, c, u, l, oe(m) ? e.length : l + m), c;
  }
  return Ir(e, c, u), c;
}
function rg(s) {
  const e = s.options.offset, t = s._tickSize(), i = s._length / t + (e ? 0 : 1), r = s._maxLength / t;
  return Math.floor(Math.min(i, r));
}
function ng(s, e, t) {
  const i = lg(s), r = e.length / t;
  if (!i)
    return Math.max(r, 1);
  const n = Ku(i);
  for (let o = 0, a = n.length - 1; o < a; o++) {
    const l = n[o];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function og(s) {
  const e = [];
  let t, i;
  for (t = 0, i = s.length; t < i; t++)
    s[t].major && e.push(t);
  return e;
}
function ag(s, e, t, i) {
  let r = 0, n = t[0], o;
  for (i = Math.ceil(i), o = 0; o < s.length; o++)
    o === n && (e.push(s[o]), r++, n = t[r * i]);
}
function Ir(s, e, t, i, r) {
  const n = ee(i, 0), o = Math.min(ee(r, s.length), s.length);
  let a = 0, l, c, u;
  for (t = Math.ceil(t), r && (l = r - i, t = l / Math.floor(l / t)), u = n; u < 0; )
    a++, u = Math.round(n + a * t);
  for (c = Math.max(n, 0); c < o; c++)
    c === u && (e.push(s[c]), a++, u = Math.round(n + a * t));
}
function lg(s) {
  const e = s.length;
  let t, i;
  if (e < 2)
    return !1;
  for (i = s[0], t = 1; t < e; ++t)
    if (s[t] - s[t - 1] !== i)
      return !1;
  return i;
}
const cg = (s) => s === "left" ? "right" : s === "right" ? "left" : s, Ul = (s, e, t) => e === "top" || e === "left" ? s[e] + t : s[e] - t, Wl = (s, e) => Math.min(e || s, s);
function Vl(s, e) {
  const t = [], i = s.length / e, r = s.length;
  let n = 0;
  for (; n < r; n += i)
    t.push(s[Math.floor(n)]);
  return t;
}
function hg(s, e, t) {
  const i = s.ticks.length, r = Math.min(e, i - 1), n = s._startPixel, o = s._endPixel, a = 1e-6;
  let l = s.getPixelForTick(r), c;
  if (!(t && (i === 1 ? c = Math.max(l - n, o - l) : e === 0 ? c = (s.getPixelForTick(1) - l) / 2 : c = (l - s.getPixelForTick(r - 1)) / 2, l += r < e ? c : -c, l < n - a || l > o + a)))
    return l;
}
function dg(s, e) {
  ue(s, (t) => {
    const i = t.gc, r = i.length / 2;
    let n;
    if (r > e) {
      for (n = 0; n < r; ++n)
        delete t.data[i[n]];
      i.splice(0, r);
    }
  });
}
function Ei(s) {
  return s.drawTicks ? s.tickLength : 0;
}
function ql(s, e) {
  if (!s.display)
    return 0;
  const t = Oe(s.font, e), i = Xe(s.padding);
  return (xe(s.text) ? s.text.length : 1) * t.lineHeight + i.height;
}
function ug(s, e) {
  return cs(s, {
    scale: e,
    type: "scale"
  });
}
function fg(s, e, t) {
  return cs(s, {
    tick: t,
    index: e,
    type: "tick"
  });
}
function pg(s, e, t) {
  let i = aa(s);
  return (t && e !== "right" || !t && e === "right") && (i = cg(i)), i;
}
function gg(s, e, t, i) {
  const { top: r, left: n, bottom: o, right: a, chart: l } = s, { chartArea: c, scales: u } = l;
  let h = 0, f, m, _;
  const v = o - r, d = a - n;
  if (s.isHorizontal()) {
    if (m = Ke(i, n, a), ae(t)) {
      const p = Object.keys(t)[0], g = t[p];
      _ = u[p].getPixelForValue(g) + v - e;
    } else t === "center" ? _ = (c.bottom + c.top) / 2 + v - e : _ = Ul(s, t, e);
    f = a - n;
  } else {
    if (ae(t)) {
      const p = Object.keys(t)[0], g = t[p];
      m = u[p].getPixelForValue(g) - d + e;
    } else t === "center" ? m = (c.left + c.right) / 2 - d + e : m = Ul(s, t, e);
    _ = Ke(i, o, r), h = t === "left" ? -Le : Le;
  }
  return {
    titleX: m,
    titleY: _,
    maxWidth: f,
    rotation: h
  };
}
class zs extends _t {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, t) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: t, _suggestedMin: i, _suggestedMax: r } = this;
    return e = ct(e, Number.POSITIVE_INFINITY), t = ct(t, Number.NEGATIVE_INFINITY), i = ct(i, Number.POSITIVE_INFINITY), r = ct(r, Number.NEGATIVE_INFINITY), {
      min: ct(e, i),
      max: ct(t, r),
      minDefined: Te(e),
      maxDefined: Te(t)
    };
  }
  getMinMax(e) {
    let { min: t, max: i, minDefined: r, maxDefined: n } = this.getUserBounds(), o;
    if (r && n)
      return {
        min: t,
        max: i
      };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, c = a.length; l < c; ++l)
      o = a[l].controller.getMinMax(this, e), r || (t = Math.min(t, o.min)), n || (i = Math.max(i, o.max));
    return t = n && t > i ? i : t, i = r && t > i ? t : i, {
      min: ct(t, ct(i, t)),
      max: ct(i, ct(t, i))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    be(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, t, i) {
    const { beginAtZero: r, grace: n, ticks: o } = this.options, a = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = t, this._margins = i = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = kf(this, n, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? Vl(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = ig(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, t, i;
    this.isHorizontal() ? (t = this.left, i = this.right) : (t = this.top, i = this.bottom, e = !e), this._startPixel = t, this._endPixel = i, this._reversePixels = e, this._length = i - t, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    be(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    be(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    be(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), be(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    be(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const t = this.options.ticks;
    let i, r, n;
    for (i = 0, r = e.length; i < r; i++)
      n = e[i], n.label = be(t.callback, [
        n.value,
        i,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    be(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    be(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, t = e.ticks, i = Wl(this.ticks.length, e.ticks.maxTicksLimit), r = t.minRotation || 0, n = t.maxRotation;
    let o = r, a, l, c;
    if (!this._isVisible() || !t.display || r >= n || i <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const u = this._getLabelSizes(), h = u.widest.width, f = u.highest.height, m = Fe(this.chart.width - h, 0, this.maxWidth);
    a = e.offset ? this.maxWidth / i : m / (i - 1), h + 6 > a && (a = m / (i - (e.offset ? 0.5 : 1)), l = this.maxHeight - Ei(e.grid) - t.padding - ql(e.title, this.chart.options.font), c = Math.sqrt(h * h + f * f), o = na(Math.min(Math.asin(Fe((u.highest.height + 6) / a, -1, 1)), Math.asin(Fe(l / c, -1, 1)) - Math.asin(Fe(f / c, -1, 1)))), o = Math.max(r, Math.min(n, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    be(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    be(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: t, options: { ticks: i, title: r, grid: n } } = this, o = this._isVisible(), a = this.isHorizontal();
    if (o) {
      const l = ql(r, t.options.font);
      if (a ? (e.width = this.maxWidth, e.height = Ei(n) + l) : (e.height = this.maxHeight, e.width = Ei(n) + l), i.display && this.ticks.length) {
        const { first: c, last: u, widest: h, highest: f } = this._getLabelSizes(), m = i.padding * 2, _ = bt(this.labelRotation), v = Math.cos(_), d = Math.sin(_);
        if (a) {
          const p = i.mirror ? 0 : d * h.width + v * f.height;
          e.height = Math.min(this.maxHeight, e.height + p + m);
        } else {
          const p = i.mirror ? 0 : v * h.width + d * f.height;
          e.width = Math.min(this.maxWidth, e.width + p + m);
        }
        this._calculatePadding(c, u, d, v);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = t.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = t.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, t, i, r) {
    const { ticks: { align: n, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, m = 0;
      l ? c ? (f = r * e.width, m = i * t.height) : (f = i * e.height, m = r * t.width) : n === "start" ? m = t.width : n === "end" ? f = e.width : n !== "inner" && (f = e.width / 2, m = t.width / 2), this.paddingLeft = Math.max((f - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((m - h + o) * this.width / (this.width - h), 0);
    } else {
      let u = t.height / 2, h = e.height / 2;
      n === "start" ? (u = 0, h = e.height) : n === "end" && (u = t.height, h = 0), this.paddingTop = u + o, this.paddingBottom = h + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    be(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: t } = this.options;
    return t === "top" || t === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let t, i;
    for (t = 0, i = e.length; t < i; t++)
      oe(e[t].label) && (e.splice(t, 1), i--, t--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const t = this.options.ticks.sampleSize;
      let i = this.ticks;
      t < i.length && (i = Vl(i, t)), this._labelSizes = e = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, t, i) {
    const { ctx: r, _longestTextCache: n } = this, o = [], a = [], l = Math.floor(t / Wl(t, i));
    let c = 0, u = 0, h, f, m, _, v, d, p, g, b, y, w;
    for (h = 0; h < t; h += l) {
      if (_ = e[h].label, v = this._resolveTickFontOptions(h), r.font = d = v.string, p = n[d] = n[d] || {
        data: {},
        gc: []
      }, g = v.lineHeight, b = y = 0, !oe(_) && !xe(_))
        b = hn(r, p.data, p.gc, b, _), y = g;
      else if (xe(_))
        for (f = 0, m = _.length; f < m; ++f)
          w = _[f], !oe(w) && !xe(w) && (b = hn(r, p.data, p.gc, b, w), y += g);
      o.push(b), a.push(y), c = Math.max(b, c), u = Math.max(y, u);
    }
    dg(n, t);
    const k = o.indexOf(c), C = a.indexOf(u), x = (S) => ({
      width: o[S] || 0,
      height: a[S] || 0
    });
    return {
      first: x(0),
      last: x(t - 1),
      widest: x(k),
      highest: x(C),
      widths: o,
      heights: a
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, t) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const t = this.ticks;
    return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const t = this._startPixel + e * this._length;
    return Xu(this._alignToPixels ? ps(this.chart, t, 0) : t);
  }
  getDecimalForPixel(e) {
    const t = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - t : t;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: t } = this;
    return e < 0 && t < 0 ? t : e > 0 && t > 0 ? e : 0;
  }
  getContext(e) {
    const t = this.ticks || [];
    if (e >= 0 && e < t.length) {
      const i = t[e];
      return i.$context || (i.$context = fg(this.getContext(), e, i));
    }
    return this.$context || (this.$context = ug(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, t = bt(this.labelRotation), i = Math.abs(Math.cos(t)), r = Math.abs(Math.sin(t)), n = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = n ? n.widest.width + o : 0, l = n ? n.highest.height + o : 0;
    return this.isHorizontal() ? l * i > a * r ? a / i : l / r : l * r < a * i ? l / i : a / r;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const t = this.axis, i = this.chart, r = this.options, { grid: n, position: o, border: a } = r, l = n.offset, c = this.isHorizontal(), h = this.ticks.length + (l ? 1 : 0), f = Ei(n), m = [], _ = a.setContext(this.getContext()), v = _.display ? _.width : 0, d = v / 2, p = function(j) {
      return ps(i, j, v);
    };
    let g, b, y, w, k, C, x, S, T, M, E, R;
    if (o === "top")
      g = p(this.bottom), C = this.bottom - f, S = g - d, M = p(e.top) + d, R = e.bottom;
    else if (o === "bottom")
      g = p(this.top), M = e.top, R = p(e.bottom) - d, C = g + d, S = this.top + f;
    else if (o === "left")
      g = p(this.right), k = this.right - f, x = g - d, T = p(e.left) + d, E = e.right;
    else if (o === "right")
      g = p(this.left), T = e.left, E = p(e.right) - d, k = g + d, x = this.left + f;
    else if (t === "x") {
      if (o === "center")
        g = p((e.top + e.bottom) / 2 + 0.5);
      else if (ae(o)) {
        const j = Object.keys(o)[0], U = o[j];
        g = p(this.chart.scales[j].getPixelForValue(U));
      }
      M = e.top, R = e.bottom, C = g + d, S = C + f;
    } else if (t === "y") {
      if (o === "center")
        g = p((e.left + e.right) / 2);
      else if (ae(o)) {
        const j = Object.keys(o)[0], U = o[j];
        g = p(this.chart.scales[j].getPixelForValue(U));
      }
      k = g - d, x = k - f, T = e.left, E = e.right;
    }
    const z = ee(r.ticks.maxTicksLimit, h), F = Math.max(1, Math.ceil(h / z));
    for (b = 0; b < h; b += F) {
      const j = this.getContext(b), U = n.setContext(j), $ = a.setContext(j), I = U.lineWidth, O = U.color, P = $.dash || [], q = $.dashOffset, Q = U.tickWidth, X = U.tickColor, G = U.tickBorderDash || [], he = U.tickBorderDashOffset;
      y = hg(this, b, l), y !== void 0 && (w = ps(i, y, I), c ? k = x = T = E = w : C = S = M = R = w, m.push({
        tx1: k,
        ty1: C,
        tx2: x,
        ty2: S,
        x1: T,
        y1: M,
        x2: E,
        y2: R,
        width: I,
        color: O,
        borderDash: P,
        borderDashOffset: q,
        tickWidth: Q,
        tickColor: X,
        tickBorderDash: G,
        tickBorderDashOffset: he
      }));
    }
    return this._ticksLength = h, this._borderValue = g, m;
  }
  _computeLabelItems(e) {
    const t = this.axis, i = this.options, { position: r, ticks: n } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: h } = n, f = Ei(i.grid), m = f + u, _ = h ? -u : m, v = -bt(this.labelRotation), d = [];
    let p, g, b, y, w, k, C, x, S, T, M, E, R = "middle";
    if (r === "top")
      k = this.bottom - _, C = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      k = this.top + _, C = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const F = this._getYAxisLabelAlignment(f);
      C = F.textAlign, w = F.x;
    } else if (r === "right") {
      const F = this._getYAxisLabelAlignment(f);
      C = F.textAlign, w = F.x;
    } else if (t === "x") {
      if (r === "center")
        k = (e.top + e.bottom) / 2 + m;
      else if (ae(r)) {
        const F = Object.keys(r)[0], j = r[F];
        k = this.chart.scales[F].getPixelForValue(j) + m;
      }
      C = this._getXAxisLabelAlignment();
    } else if (t === "y") {
      if (r === "center")
        w = (e.left + e.right) / 2 - m;
      else if (ae(r)) {
        const F = Object.keys(r)[0], j = r[F];
        w = this.chart.scales[F].getPixelForValue(j);
      }
      C = this._getYAxisLabelAlignment(f).textAlign;
    }
    t === "y" && (l === "start" ? R = "top" : l === "end" && (R = "bottom"));
    const z = this._getLabelSizes();
    for (p = 0, g = a.length; p < g; ++p) {
      b = a[p], y = b.label;
      const F = n.setContext(this.getContext(p));
      x = this.getPixelForTick(p) + n.labelOffset, S = this._resolveTickFontOptions(p), T = S.lineHeight, M = xe(y) ? y.length : 1;
      const j = M / 2, U = F.color, $ = F.textStrokeColor, I = F.textStrokeWidth;
      let O = C;
      o ? (w = x, C === "inner" && (p === g - 1 ? O = this.options.reverse ? "left" : "right" : p === 0 ? O = this.options.reverse ? "right" : "left" : O = "center"), r === "top" ? c === "near" || v !== 0 ? E = -M * T + T / 2 : c === "center" ? E = -z.highest.height / 2 - j * T + T : E = -z.highest.height + T / 2 : c === "near" || v !== 0 ? E = T / 2 : c === "center" ? E = z.highest.height / 2 - j * T : E = z.highest.height - M * T, h && (E *= -1), v !== 0 && !F.showLabelBackdrop && (w += T / 2 * Math.sin(v))) : (k = x, E = (1 - M) * T / 2);
      let P;
      if (F.showLabelBackdrop) {
        const q = Xe(F.backdropPadding), Q = z.heights[p], X = z.widths[p];
        let G = E - q.top, he = 0 - q.left;
        switch (R) {
          case "middle":
            G -= Q / 2;
            break;
          case "bottom":
            G -= Q;
            break;
        }
        switch (C) {
          case "center":
            he -= X / 2;
            break;
          case "right":
            he -= X;
            break;
          case "inner":
            p === g - 1 ? he -= X : p > 0 && (he -= X / 2);
            break;
        }
        P = {
          left: he,
          top: G,
          width: X + q.width,
          height: Q + q.height,
          color: F.backdropColor
        };
      }
      d.push({
        label: y,
        font: S,
        textOffset: E,
        options: {
          rotation: v,
          color: U,
          strokeColor: $,
          strokeWidth: I,
          textAlign: O,
          textBaseline: R,
          translation: [
            w,
            k
          ],
          backdrop: P
        }
      });
    }
    return d;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: t } = this.options;
    if (-bt(this.labelRotation))
      return e === "top" ? "left" : "right";
    let r = "center";
    return t.align === "start" ? r = "left" : t.align === "end" ? r = "right" : t.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(e) {
    const { position: t, ticks: { crossAlign: i, mirror: r, padding: n } } = this.options, o = this._getLabelSizes(), a = e + n, l = o.widest.width;
    let c, u;
    return t === "left" ? r ? (u = this.right + n, i === "near" ? c = "left" : i === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, i === "near" ? c = "right" : i === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : t === "right" ? r ? (u = this.left + n, i === "near" ? c = "right" : i === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, i === "near" ? c = "left" : i === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, t = this.options.position;
    if (t === "left" || t === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (t === "top" || t === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: t }, left: i, top: r, width: n, height: o } = this;
    t && (e.save(), e.fillStyle = t, e.fillRect(i, r, n, o), e.restore());
  }
  getLineWidthForValue(e) {
    const t = this.options.grid;
    if (!this._isVisible() || !t.display)
      return 0;
    const r = this.ticks.findIndex((n) => n.value === e);
    return r >= 0 ? t.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(e) {
    const t = this.options.grid, i = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let n, o;
    const a = (l, c, u) => {
      !u.width || !u.color || (i.save(), i.lineWidth = u.width, i.strokeStyle = u.color, i.setLineDash(u.borderDash || []), i.lineDashOffset = u.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore());
    };
    if (t.display)
      for (n = 0, o = r.length; n < o; ++n) {
        const l = r[n];
        t.drawOnChartArea && a({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), t.drawTicks && a({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: t, options: { border: i, grid: r } } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;
    if (!o)
      return;
    const a = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, h, f;
    this.isHorizontal() ? (c = ps(e, this.left, o) - o / 2, u = ps(e, this.right, a) + a / 2, h = f = l) : (h = ps(e, this.top, o) - o / 2, f = ps(e, this.bottom, a) + a / 2, c = u = l), t.save(), t.lineWidth = n.width, t.strokeStyle = n.color, t.beginPath(), t.moveTo(c, h), t.lineTo(u, f), t.stroke(), t.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const i = this.ctx, r = this._computeLabelArea();
    r && kn(i, r);
    const n = this.getLabelItems(e);
    for (const o of n) {
      const a = o.options, l = o.font, c = o.label, u = o.textOffset;
      Ls(i, c, 0, u, l, a);
    }
    r && Sn(i);
  }
  drawTitle() {
    const { ctx: e, options: { position: t, title: i, reverse: r } } = this;
    if (!i.display)
      return;
    const n = Oe(i.font), o = Xe(i.padding), a = i.align;
    let l = n.lineHeight / 2;
    t === "bottom" || t === "center" || ae(t) ? (l += o.bottom, xe(i.text) && (l += n.lineHeight * (i.text.length - 1))) : l += o.top;
    const { titleX: c, titleY: u, maxWidth: h, rotation: f } = gg(this, l, t, a);
    Ls(e, i.text, 0, 0, n, {
      color: i.color,
      maxWidth: h,
      rotation: f,
      textAlign: pg(a, t, r),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, t = e.ticks && e.ticks.z || 0, i = ee(e.grid && e.grid.z, -1), r = ee(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== zs.prototype.draw ? [
      {
        z: t,
        draw: (n) => {
          this.draw(n);
        }
      }
    ] : [
      {
        z: i,
        draw: (n) => {
          this.drawBackground(), this.drawGrid(n), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: t,
        draw: (n) => {
          this.drawLabels(n);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const t = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", r = [];
    let n, o;
    for (n = 0, o = t.length; n < o; ++n) {
      const a = t[n];
      a[i] === this.id && (!e || a.type === e) && r.push(a);
    }
    return r;
  }
  _resolveTickFontOptions(e) {
    const t = this.options.ticks.setContext(this.getContext(e));
    return Oe(t.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
}
class Rr {
  constructor(e, t, i) {
    this.type = e, this.scope = t, this.override = i, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const t = Object.getPrototypeOf(e);
    let i;
    vg(t) && (i = this.register(t));
    const r = this.items, n = e.id, o = this.scope + "." + n;
    if (!n)
      throw new Error("class does not have id: " + e);
    return n in r || (r[n] = e, mg(e, o, i), this.override && ke.override(e.id, e.overrides)), o;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const t = this.items, i = e.id, r = this.scope;
    i in t && delete t[i], r && i in ke[r] && (delete ke[r][i], this.override && delete Ts[i]);
  }
}
function mg(s, e, t) {
  const i = Ji(/* @__PURE__ */ Object.create(null), [
    t ? ke.get(t) : {},
    ke.get(e),
    s.defaults
  ]);
  ke.set(e, i), s.defaultRoutes && bg(e, s.defaultRoutes), s.descriptors && ke.describe(e, s.descriptors);
}
function bg(s, e) {
  Object.keys(e).forEach((t) => {
    const i = t.split("."), r = i.pop(), n = [
      s
    ].concat(i).join("."), o = e[t].split("."), a = o.pop(), l = o.join(".");
    ke.route(n, r, l, a);
  });
}
function vg(s) {
  return "id" in s && "defaults" in s;
}
class _g {
  constructor() {
    this.controllers = new Rr(vt, "datasets", !0), this.elements = new Rr(_t, "elements"), this.plugins = new Rr(Object, "plugins"), this.scales = new Rr(zs, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, t, i) {
    [
      ...t
    ].forEach((r) => {
      const n = i || this._getRegistryForType(r);
      i || n.isForType(r) || n === this.plugins && r.id ? this._exec(e, n, r) : ue(r, (o) => {
        const a = i || this._getRegistryForType(o);
        this._exec(e, a, o);
      });
    });
  }
  _exec(e, t, i) {
    const r = ra(e);
    be(i["before" + r], [], i), t[e](i), be(i["after" + r], [], i);
  }
  _getRegistryForType(e) {
    for (let t = 0; t < this._typedRegistries.length; t++) {
      const i = this._typedRegistries[t];
      if (i.isForType(e))
        return i;
    }
    return this.plugins;
  }
  _get(e, t, i) {
    const r = t.get(e);
    if (r === void 0)
      throw new Error('"' + e + '" is not a registered ' + i + ".");
    return r;
  }
}
var Dt = /* @__PURE__ */ new _g();
class yg {
  constructor() {
    this._init = [];
  }
  notify(e, t, i, r) {
    t === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install"));
    const n = r ? this._descriptors(e).filter(r) : this._descriptors(e), o = this._notify(n, e, t, i);
    return t === "afterDestroy" && (this._notify(n, e, "stop"), this._notify(this._init, e, "uninstall")), o;
  }
  _notify(e, t, i, r) {
    r = r || {};
    for (const n of e) {
      const o = n.plugin, a = o[i], l = [
        t,
        r,
        n.options
      ];
      if (be(a, l, o) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    oe(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const t = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), t;
  }
  _createDescriptors(e, t) {
    const i = e && e.config, r = ee(i.options && i.options.plugins, {}), n = wg(i);
    return r === !1 && !t ? [] : kg(e, n, r, t);
  }
  _notifyStateChanges(e) {
    const t = this._oldCache || [], i = this._cache, r = (n, o) => n.filter((a) => !o.some((l) => a.plugin.id === l.plugin.id));
    this._notify(r(t, i), e, "stop"), this._notify(r(i, t), e, "start");
  }
}
function wg(s) {
  const e = {}, t = [], i = Object.keys(Dt.plugins.items);
  for (let n = 0; n < i.length; n++)
    t.push(Dt.getPlugin(i[n]));
  const r = s.plugins || [];
  for (let n = 0; n < r.length; n++) {
    const o = r[n];
    t.indexOf(o) === -1 && (t.push(o), e[o.id] = !0);
  }
  return {
    plugins: t,
    localIds: e
  };
}
function xg(s, e) {
  return !e && s === !1 ? null : s === !0 ? {} : s;
}
function kg(s, { plugins: e, localIds: t }, i, r) {
  const n = [], o = s.getContext();
  for (const a of e) {
    const l = a.id, c = xg(i[l], r);
    c !== null && n.push({
      plugin: a,
      options: Sg(s.config, {
        plugin: a,
        local: t[l]
      }, c, o)
    });
  }
  return n;
}
function Sg(s, { plugin: e, local: t }, i, r) {
  const n = s.pluginScopeKeys(e), o = s.getOptionScopes(i, n);
  return t && e.defaults && o.push(e.defaults), s.createResolver(o, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Lo(s, e) {
  const t = ke.datasets[s] || {};
  return ((e.datasets || {})[s] || {}).indexAxis || e.indexAxis || t.indexAxis || "x";
}
function Cg(s, e) {
  let t = s;
  return s === "_index_" ? t = e : s === "_value_" && (t = e === "x" ? "y" : "x"), t;
}
function Dg(s, e) {
  return s === e ? "_index_" : "_value_";
}
function Kl(s) {
  if (s === "x" || s === "y" || s === "r")
    return s;
}
function $g(s) {
  if (s === "top" || s === "bottom")
    return "x";
  if (s === "left" || s === "right")
    return "y";
}
function Mo(s, ...e) {
  if (Kl(s))
    return s;
  for (const t of e) {
    const i = t.axis || $g(t.position) || s.length > 1 && Kl(s[0].toLowerCase());
    if (i)
      return i;
  }
  throw new Error(`Cannot determine type of '${s}' axis. Please provide 'axis' or 'position' option.`);
}
function Ql(s, e, t) {
  if (t[e + "AxisID"] === s)
    return {
      axis: e
    };
}
function Ag(s, e) {
  if (e.data && e.data.datasets) {
    const t = e.data.datasets.filter((i) => i.xAxisID === s || i.yAxisID === s);
    if (t.length)
      return Ql(s, "x", t[0]) || Ql(s, "y", t[0]);
  }
  return {};
}
function Eg(s, e) {
  const t = Ts[s.type] || {
    scales: {}
  }, i = e.scales || {}, r = Lo(s.type, e), n = /* @__PURE__ */ Object.create(null);
  return Object.keys(i).forEach((o) => {
    const a = i[o];
    if (!ae(a))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (a._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const l = Mo(o, a, Ag(o, s), ke.scales[a.type]), c = Dg(l, r), u = t.scales || {};
    n[o] = ji(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      a,
      u[l],
      u[c]
    ]);
  }), s.data.datasets.forEach((o) => {
    const a = o.type || s.type, l = o.indexAxis || Lo(a, e), u = (Ts[a] || {}).scales || {};
    Object.keys(u).forEach((h) => {
      const f = Cg(h, l), m = o[f + "AxisID"] || f;
      n[m] = n[m] || /* @__PURE__ */ Object.create(null), ji(n[m], [
        {
          axis: f
        },
        i[m],
        u[h]
      ]);
    });
  }), Object.keys(n).forEach((o) => {
    const a = n[o];
    ji(a, [
      ke.scales[a.type],
      ke.scale
    ]);
  }), n;
}
function $h(s) {
  const e = s.options || (s.options = {});
  e.plugins = ee(e.plugins, {}), e.scales = Eg(s, e);
}
function Ah(s) {
  return s = s || {}, s.datasets = s.datasets || [], s.labels = s.labels || [], s;
}
function Tg(s) {
  return s = s || {}, s.data = Ah(s.data), $h(s), s;
}
const Yl = /* @__PURE__ */ new Map(), Eh = /* @__PURE__ */ new Set();
function Or(s, e) {
  let t = Yl.get(s);
  return t || (t = e(), Yl.set(s, t), Eh.add(t)), t;
}
const Ti = (s, e, t) => {
  const i = ns(e, t);
  i !== void 0 && s.add(i);
};
class Lg {
  constructor(e) {
    this._config = Tg(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = Ah(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), $h(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return Or(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, t) {
    return Or(`${e}.transition.${t}`, () => [
      [
        `datasets.${e}.transitions.${t}`,
        `transitions.${t}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, t) {
    return Or(`${e}-${t}`, () => [
      [
        `datasets.${e}.elements.${t}`,
        `datasets.${e}`,
        `elements.${t}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const t = e.id, i = this.type;
    return Or(`${i}-plugin-${t}`, () => [
      [
        `plugins.${t}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, t) {
    const i = this._scopeCache;
    let r = i.get(e);
    return (!r || t) && (r = /* @__PURE__ */ new Map(), i.set(e, r)), r;
  }
  getOptionScopes(e, t, i) {
    const { options: r, type: n } = this, o = this._cachedScopes(e, i), a = o.get(t);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    t.forEach((u) => {
      e && (l.add(e), u.forEach((h) => Ti(l, e, h))), u.forEach((h) => Ti(l, r, h)), u.forEach((h) => Ti(l, Ts[n] || {}, h)), u.forEach((h) => Ti(l, ke, h)), u.forEach((h) => Ti(l, Ao, h));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Eh.has(t) && o.set(t, c), c;
  }
  chartOptionScopes() {
    const { options: e, type: t } = this;
    return [
      e,
      Ts[t] || {},
      ke.datasets[t] || {},
      {
        type: t
      },
      ke,
      Ao
    ];
  }
  resolveNamedOptions(e, t, i, r = [
    ""
  ]) {
    const n = {
      $shared: !0
    }, { resolver: o, subPrefixes: a } = Gl(this._resolverCache, e, r);
    let l = o;
    if (Ig(o, t)) {
      n.$shared = !1, i = os(i) ? i() : i;
      const c = this.createResolver(e, i, a);
      l = ai(o, i, c);
    }
    for (const c of t)
      n[c] = l[c];
    return n;
  }
  createResolver(e, t, i = [
    ""
  ], r) {
    const { resolver: n } = Gl(this._resolverCache, e, i);
    return ae(t) ? ai(n, t, void 0, r) : n;
  }
}
function Gl(s, e, t) {
  let i = s.get(e);
  i || (i = /* @__PURE__ */ new Map(), s.set(e, i));
  const r = t.join();
  let n = i.get(r);
  return n || (n = {
    resolver: ha(e, t),
    subPrefixes: t.filter((a) => !a.toLowerCase().includes("hover"))
  }, i.set(r, n)), n;
}
const Mg = (s) => ae(s) && Object.getOwnPropertyNames(s).some((e) => os(s[e]));
function Ig(s, e) {
  const { isScriptable: t, isIndexable: i } = ah(s);
  for (const r of e) {
    const n = t(r), o = i(r), a = (o || n) && s[r];
    if (n && (os(a) || Mg(a)) || o && xe(a))
      return !0;
  }
  return !1;
}
var Rg = "4.5.0";
const Og = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Xl(s, e) {
  return s === "top" || s === "bottom" || Og.indexOf(s) === -1 && e === "x";
}
function Jl(s, e) {
  return function(t, i) {
    return t[s] === i[s] ? t[e] - i[e] : t[s] - i[s];
  };
}
function Zl(s) {
  const e = s.chart, t = e.options.animation;
  e.notifyPlugins("afterRender"), be(t && t.onComplete, [
    s
  ], e);
}
function Pg(s) {
  const e = s.chart, t = e.options.animation;
  be(t && t.onProgress, [
    s
  ], e);
}
function Th(s) {
  return fa() && typeof s == "string" ? s = document.getElementById(s) : s && s.length && (s = s[0]), s && s.canvas && (s = s.canvas), s;
}
const Xr = {}, ec = (s) => {
  const e = Th(s);
  return Object.values(Xr).filter((t) => t.canvas === e).pop();
};
function Bg(s, e, t) {
  const i = Object.keys(s);
  for (const r of i) {
    const n = +r;
    if (n >= e) {
      const o = s[r];
      delete s[r], (t > 0 || n > e) && (s[n + t] = o);
    }
  }
}
function Ng(s, e, t, i) {
  return !t || s.type === "mouseout" ? null : i ? e : s;
}
class $t {
  static register(...e) {
    Dt.add(...e), tc();
  }
  static unregister(...e) {
    Dt.remove(...e), tc();
  }
  constructor(e, t) {
    const i = this.config = new Lg(t), r = Th(e), n = ec(r);
    if (n)
      throw new Error("Canvas is already in use. Chart with ID '" + n.id + "' must be destroyed before the canvas with ID '" + n.canvas.id + "' can be reused.");
    const o = i.createResolver(i.chartOptionScopes(), this.getContext());
    this.platform = new (i.platform || sg(r))(), this.platform.updateConfig(i);
    const a = this.platform.acquireContext(r, o.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width;
    if (this.id = Nu(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new yg(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = tf((h) => this.update(h), o.resizeDelay || 0), this._dataChanges = [], Xr[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Bt.listen(this, "complete", Zl), Bt.listen(this, "progress", Pg), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: t }, width: i, height: r, _aspectRatio: n } = this;
    return oe(e) ? t && n ? n : r ? i / r : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return Dt;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : kl(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return yl(this.canvas, this.ctx), this;
  }
  stop() {
    return Bt.stop(this), this;
  }
  resize(e, t) {
    Bt.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: t
    } : this._resize(e, t);
  }
  _resize(e, t) {
    const i = this.options, r = this.canvas, n = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, e, t, n), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, kl(this, a, !0) && (this.notifyPlugins("resize", {
      size: o
    }), be(i.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const t = this.options.scales || {};
    ue(t, (i, r) => {
      i.id = r;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, t = e.scales, i = this.scales, r = Object.keys(i).reduce((o, a) => (o[a] = !1, o), {});
    let n = [];
    t && (n = n.concat(Object.keys(t).map((o) => {
      const a = t[o], l = Mo(o, a), c = l === "r", u = l === "x";
      return {
        options: a,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), ue(n, (o) => {
      const a = o.options, l = a.id, c = Mo(l, a), u = ee(a.type, o.dtype);
      (a.position === void 0 || Xl(a.position, c) !== Xl(o.dposition)) && (a.position = o.dposition), r[l] = !0;
      let h = null;
      if (l in i && i[l].type === u)
        h = i[l];
      else {
        const f = Dt.getScale(u);
        h = new f({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), i[h.id] = h;
      }
      h.init(a, e);
    }), ue(r, (o, a) => {
      o || delete i[a];
    }), ue(i, (o) => {
      Ye.configure(this, o, o.options), Ye.addBox(this, o);
    });
  }
  _updateMetasets() {
    const e = this._metasets, t = this.data.datasets.length, i = e.length;
    if (e.sort((r, n) => r.index - n.index), i > t) {
      for (let r = t; r < i; ++r)
        this._destroyDatasetMeta(r);
      e.splice(t, i - t);
    }
    this._sortedMetasets = e.slice(0).sort(Jl("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: t } } = this;
    e.length > t.length && delete this._stacks, e.forEach((i, r) => {
      t.filter((n) => n === i._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const e = [], t = this.data.datasets;
    let i, r;
    for (this._removeUnreferencedMetasets(), i = 0, r = t.length; i < r; i++) {
      const n = t[i];
      let o = this.getDatasetMeta(i);
      const a = n.type || this.config.type;
      if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = n.indexAxis || Lo(a, this.options), o.order = n.order || 0, o.index = i, o.label = "" + n.label, o.visible = this.isDatasetVisible(i), o.controller)
        o.controller.updateIndex(i), o.controller.linkScales();
      else {
        const l = Dt.getController(a), { datasetElementType: c, dataElementType: u } = ke.datasets[a];
        Object.assign(l, {
          dataElementType: Dt.getElement(u),
          datasetElementType: c && Dt.getElement(c)
        }), o.controller = new l(this, i), e.push(o.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    ue(this.data.datasets, (e, t) => {
      this.getDatasetMeta(t).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const t = this.config;
    t.update();
    const i = this._options = t.createResolver(t.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !i.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: !0
    }) === !1)
      return;
    const n = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: h } = this.getDatasetMeta(c), f = !r && n.indexOf(h) === -1;
      h.buildOrUpdateElements(f), o = Math.max(+h.getMaxOverflow(), o);
    }
    o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), r || ue(n, (c) => {
      c.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(Jl("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    ue(this.scales, (e) => {
      Ye.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, t = new Set(Object.keys(this._listeners)), i = new Set(e.events);
    (!dl(t, i) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, t = this._getUniformDataChanges() || [];
    for (const { method: i, start: r, count: n } of t) {
      const o = i === "_removeElements" ? -n : n;
      Bg(e, r, o);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const t = this.data.datasets.length, i = (n) => new Set(e.filter((o) => o[0] === n).map((o, a) => a + "," + o.splice(1).join(","))), r = i(0);
    for (let n = 1; n < t; n++)
      if (!dl(r, i(n)))
        return;
    return Array.from(r).map((n) => n.split(",")).map((n) => ({
      method: n[1],
      start: +n[2],
      count: +n[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Ye.update(this, this.width, this.height, e);
    const t = this.chartArea, i = t.width <= 0 || t.height <= 0;
    this._layers = [], ue(this.boxes, (r) => {
      i && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, n) => {
      r._idx = n;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: !0
    }) !== !1) {
      for (let t = 0, i = this.data.datasets.length; t < i; ++t)
        this.getDatasetMeta(t).controller.configure();
      for (let t = 0, i = this.data.datasets.length; t < i; ++t)
        this._updateDataset(t, os(e) ? e({
          datasetIndex: t
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, t) {
    const i = this.getDatasetMeta(e), r = {
      meta: i,
      index: e,
      mode: t,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(t), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Bt.has(this) ? this.attached && !Bt.running(this) && Bt.start(this) : (this.draw(), Zl({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: i, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(i, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this._layers;
    for (e = 0; e < t.length && t[e].z <= 0; ++e)
      t[e].draw(this.chartArea);
    for (this._drawDatasets(); e < t.length; ++e)
      t[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const t = this._sortedMetasets, i = [];
    let r, n;
    for (r = 0, n = t.length; r < n; ++r) {
      const o = t[r];
      (!e || o.visible) && i.push(o);
    }
    return i;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let t = e.length - 1; t >= 0; --t)
      this._drawDataset(e[t]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const t = this.ctx, i = {
      meta: e,
      index: e.index,
      cancelable: !0
    }, r = vh(this, e);
    this.notifyPlugins("beforeDatasetDraw", i) !== !1 && (r && kn(t, r), e.controller.draw(), r && Sn(t), i.cancelable = !1, this.notifyPlugins("afterDatasetDraw", i));
  }
  isPointInArea(e) {
    return jt(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, t, i, r) {
    const n = Op.modes[t];
    return typeof n == "function" ? n(this, e, i, r) : [];
  }
  getDatasetMeta(e) {
    const t = this.data.datasets[e], i = this._metasets;
    let r = i.filter((n) => n && n._dataset === t).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: t && t.order || 0,
      index: e,
      _dataset: t,
      _parsed: [],
      _sorted: !1
    }, i.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = cs(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const t = this.data.datasets[e];
    if (!t)
      return !1;
    const i = this.getDatasetMeta(e);
    return typeof i.hidden == "boolean" ? !i.hidden : !t.hidden;
  }
  setDatasetVisibility(e, t) {
    const i = this.getDatasetMeta(e);
    i.hidden = !t;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, t, i) {
    const r = i ? "show" : "hide", n = this.getDatasetMeta(e), o = n.controller._resolveAnimations(void 0, r);
    Zi(t) ? (n.data[t].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), o.update(n, {
      visible: i
    }), this.update((a) => a.datasetIndex === e ? r : void 0));
  }
  hide(e, t) {
    this._updateVisibility(e, t, !1);
  }
  show(e, t) {
    this._updateVisibility(e, t, !0);
  }
  _destroyDatasetMeta(e) {
    const t = this._metasets[e];
    t && t.controller && t.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, t;
    for (this.stop(), Bt.remove(this), e = 0, t = this.data.datasets.length; e < t; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: t } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), yl(e, t), this.platform.releaseContext(t), this.canvas = null, this.ctx = null), delete Xr[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const e = this._listeners, t = this.platform, i = (n, o) => {
      t.addEventListener(this, n, o), e[n] = o;
    }, r = (n, o, a) => {
      n.offsetX = o, n.offsetY = a, this._eventHandler(n);
    };
    ue(this.options.events, (n) => i(n, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, t = this.platform, i = (l, c) => {
      t.addEventListener(this, l, c), e[l] = c;
    }, r = (l, c) => {
      e[l] && (t.removeEventListener(this, l, c), delete e[l]);
    }, n = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let o;
    const a = () => {
      r("attach", a), this.attached = !0, this.resize(), i("resize", n), i("detach", o);
    };
    o = () => {
      this.attached = !1, r("resize", n), this._stop(), this._resize(0, 0), i("attach", a);
    }, t.isAttached(this.canvas) ? a() : o();
  }
  unbindEvents() {
    ue(this._listeners, (e, t) => {
      this.platform.removeEventListener(this, t, e);
    }), this._listeners = {}, ue(this._responsiveListeners, (e, t) => {
      this.platform.removeEventListener(this, t, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, t, i) {
    const r = i ? "set" : "remove";
    let n, o, a, l;
    for (t === "dataset" && (n = this.getDatasetMeta(e[0].datasetIndex), n.controller["_" + r + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) {
      o = e[a];
      const c = o && this.getDatasetMeta(o.datasetIndex).controller;
      c && c[r + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const t = this._active || [], i = e.map(({ datasetIndex: n, index: o }) => {
      const a = this.getDatasetMeta(n);
      if (!a)
        throw new Error("No dataset found at index " + n);
      return {
        datasetIndex: n,
        element: a.data[o],
        index: o
      };
    });
    !an(i, t) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, t));
  }
  notifyPlugins(e, t, i) {
    return this._plugins.notify(this, e, t, i);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((t) => t.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, t, i) {
    const r = this.options.hover, n = (l, c) => l.filter((u) => !c.some((h) => u.datasetIndex === h.datasetIndex && u.index === h.index)), o = n(t, e), a = i ? e : n(e, t);
    o.length && this.updateHoverStyle(o, r.mode, !1), a.length && r.mode && this.updateHoverStyle(a, r.mode, !0);
  }
  _eventHandler(e, t) {
    const i = {
      event: e,
      replay: t,
      cancelable: !0,
      inChartArea: this.isPointInArea(e)
    }, r = (o) => (o.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", i, r) === !1)
      return;
    const n = this._handleEvent(e, t, i.inChartArea);
    return i.cancelable = !1, this.notifyPlugins("afterEvent", i, r), (n || i.changed) && this.render(), this;
  }
  _handleEvent(e, t, i) {
    const { _active: r = [], options: n } = this, o = t, a = this._getActiveElements(e, r, i, o), l = Wu(e), c = Ng(e, this._lastEvent, i, l);
    i && (this._lastEvent = null, be(n.onHover, [
      e,
      a,
      this
    ], this), l && be(n.onClick, [
      e,
      a,
      this
    ], this));
    const u = !an(a, r);
    return (u || t) && (this._active = a, this._updateHoverStyles(a, r, t)), this._lastEvent = c, u;
  }
  _getActiveElements(e, t, i, r) {
    if (e.type === "mouseout")
      return [];
    if (!i)
      return t;
    const n = this.options.hover;
    return this.getElementsAtEventForMode(e, n.mode, n, r);
  }
}
K($t, "defaults", ke), K($t, "instances", Xr), K($t, "overrides", Ts), K($t, "registry", Dt), K($t, "version", Rg), K($t, "getChart", ec);
function tc() {
  return ue($t.instances, (s) => s._plugins.invalidate());
}
function Fg(s, e, t) {
  const { startAngle: i, x: r, y: n, outerRadius: o, innerRadius: a, options: l } = e, { borderWidth: c, borderJoinStyle: u } = l, h = Math.min(c / o, Qe(i - t));
  if (s.beginPath(), s.arc(r, n, o - c / 2, i + h / 2, t - h / 2), a > 0) {
    const f = Math.min(c / a, Qe(i - t));
    s.arc(r, n, a + c / 2, t - f / 2, i + f / 2, !0);
  } else {
    const f = Math.min(c / 2, o * Qe(i - t));
    if (u === "round")
      s.arc(r, n, f, t - ce / 2, i + ce / 2, !0);
    else if (u === "bevel") {
      const m = 2 * f * f, _ = -m * Math.cos(t + ce / 2) + r, v = -m * Math.sin(t + ce / 2) + n, d = m * Math.cos(i + ce / 2) + r, p = m * Math.sin(i + ce / 2) + n;
      s.lineTo(_, v), s.lineTo(d, p);
    }
  }
  s.closePath(), s.moveTo(0, 0), s.rect(0, 0, s.canvas.width, s.canvas.height), s.clip("evenodd");
}
function zg(s, e, t) {
  const { startAngle: i, pixelMargin: r, x: n, y: o, outerRadius: a, innerRadius: l } = e;
  let c = r / a;
  s.beginPath(), s.arc(n, o, a, i - c, t + c), l > r ? (c = r / l, s.arc(n, o, l, t + c, i - c, !0)) : s.arc(n, o, r, t + Le, i - Le), s.closePath(), s.clip();
}
function Hg(s) {
  return ca(s, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function jg(s, e, t, i) {
  const r = Hg(s.options.borderRadius), n = (t - e) / 2, o = Math.min(n, i * e / 2), a = (l) => {
    const c = (t - Math.min(n, l)) * i / 2;
    return Fe(l, 0, Math.min(n, c));
  };
  return {
    outerStart: a(r.outerStart),
    outerEnd: a(r.outerEnd),
    innerStart: Fe(r.innerStart, 0, o),
    innerEnd: Fe(r.innerEnd, 0, o)
  };
}
function Qs(s, e, t, i) {
  return {
    x: t + s * Math.cos(e),
    y: i + s * Math.sin(e)
  };
}
function fn(s, e, t, i, r, n) {
  const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = e, h = Math.max(e.outerRadius + i + t - c, 0), f = u > 0 ? u + i + t + c : 0;
  let m = 0;
  const _ = r - l;
  if (i) {
    const F = u > 0 ? u - i : 0, j = h > 0 ? h - i : 0, U = (F + j) / 2, $ = U !== 0 ? _ * U / (U + i) : _;
    m = (_ - $) / 2;
  }
  const v = Math.max(1e-3, _ * h - t / ce) / h, d = (_ - v) / 2, p = l + d + m, g = r - d - m, { outerStart: b, outerEnd: y, innerStart: w, innerEnd: k } = jg(e, f, h, g - p), C = h - b, x = h - y, S = p + b / C, T = g - y / x, M = f + w, E = f + k, R = p + w / M, z = g - k / E;
  if (s.beginPath(), n) {
    const F = (S + T) / 2;
    if (s.arc(o, a, h, S, F), s.arc(o, a, h, F, T), y > 0) {
      const I = Qs(x, T, o, a);
      s.arc(I.x, I.y, y, T, g + Le);
    }
    const j = Qs(E, g, o, a);
    if (s.lineTo(j.x, j.y), k > 0) {
      const I = Qs(E, z, o, a);
      s.arc(I.x, I.y, k, g + Le, z + Math.PI);
    }
    const U = (g - k / f + (p + w / f)) / 2;
    if (s.arc(o, a, f, g - k / f, U, !0), s.arc(o, a, f, U, p + w / f, !0), w > 0) {
      const I = Qs(M, R, o, a);
      s.arc(I.x, I.y, w, R + Math.PI, p - Le);
    }
    const $ = Qs(C, p, o, a);
    if (s.lineTo($.x, $.y), b > 0) {
      const I = Qs(C, S, o, a);
      s.arc(I.x, I.y, b, p - Le, S);
    }
  } else {
    s.moveTo(o, a);
    const F = Math.cos(S) * h + o, j = Math.sin(S) * h + a;
    s.lineTo(F, j);
    const U = Math.cos(T) * h + o, $ = Math.sin(T) * h + a;
    s.lineTo(U, $);
  }
  s.closePath();
}
function Ug(s, e, t, i, r) {
  const { fullCircles: n, startAngle: o, circumference: a } = e;
  let l = e.endAngle;
  if (n) {
    fn(s, e, t, i, l, r);
    for (let c = 0; c < n; ++c)
      s.fill();
    isNaN(a) || (l = o + (a % _e || _e));
  }
  return fn(s, e, t, i, l, r), s.fill(), l;
}
function Wg(s, e, t, i, r) {
  const { fullCircles: n, startAngle: o, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: u, borderDash: h, borderDashOffset: f, borderRadius: m } = l, _ = l.borderAlign === "inner";
  if (!c)
    return;
  s.setLineDash(h || []), s.lineDashOffset = f, _ ? (s.lineWidth = c * 2, s.lineJoin = u || "round") : (s.lineWidth = c, s.lineJoin = u || "bevel");
  let v = e.endAngle;
  if (n) {
    fn(s, e, t, i, v, r);
    for (let d = 0; d < n; ++d)
      s.stroke();
    isNaN(a) || (v = o + (a % _e || _e));
  }
  _ && zg(s, e, v), l.selfJoin && v - o >= ce && m === 0 && u !== "miter" && Fg(s, e, v), n || (fn(s, e, t, i, v, r), s.stroke());
}
class Pi extends _t {
  constructor(t) {
    super();
    K(this, "circumference");
    K(this, "endAngle");
    K(this, "fullCircles");
    K(this, "innerRadius");
    K(this, "outerRadius");
    K(this, "pixelMargin");
    K(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, i, r) {
    const n = this.getProps([
      "x",
      "y"
    ], r), { angle: o, distance: a } = Xc(n, {
      x: t,
      y: i
    }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: h, circumference: f } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], r), m = (this.options.spacing + this.options.borderWidth) / 2, _ = ee(f, c - l), v = er(o, l, c) && l !== c, d = _ >= _e || v, p = zt(a, u + m, h + m);
    return d && p;
  }
  getCenterPoint(t) {
    const { x: i, y: r, startAngle: n, endAngle: o, innerRadius: a, outerRadius: l } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: c, spacing: u } = this.options, h = (n + o) / 2, f = (a + l + u + c) / 2;
    return {
      x: i + Math.cos(h) * f,
      y: r + Math.sin(h) * f
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: i, circumference: r } = this, n = (i.offset || 0) / 4, o = (i.spacing || 0) / 2, a = i.circular;
    if (this.pixelMargin = i.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = r > _e ? Math.floor(r / _e) : 0, r === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const l = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(l) * n, Math.sin(l) * n);
    const c = 1 - Math.sin(Math.min(ce, r || 0)), u = n * c;
    t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor, Ug(t, this, u, o, a), Wg(t, this, u, o, a), t.restore();
  }
}
K(Pi, "id", "arc"), K(Pi, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0,
  selfJoin: !1
}), K(Pi, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), K(Pi, "descriptors", {
  _scriptable: !0,
  _indexable: (t) => t !== "borderDash"
});
function Lh(s, e, t = e) {
  s.lineCap = ee(t.borderCapStyle, e.borderCapStyle), s.setLineDash(ee(t.borderDash, e.borderDash)), s.lineDashOffset = ee(t.borderDashOffset, e.borderDashOffset), s.lineJoin = ee(t.borderJoinStyle, e.borderJoinStyle), s.lineWidth = ee(t.borderWidth, e.borderWidth), s.strokeStyle = ee(t.borderColor, e.borderColor);
}
function Vg(s, e, t) {
  s.lineTo(t.x, t.y);
}
function qg(s) {
  return s.stepped ? pf : s.tension || s.cubicInterpolationMode === "monotone" ? gf : Vg;
}
function Mh(s, e, t = {}) {
  const i = s.length, { start: r = 0, end: n = i - 1 } = t, { start: o, end: a } = e, l = Math.max(r, o), c = Math.min(n, a), u = r < o && n < o || r > a && n > a;
  return {
    count: i,
    start: l,
    loop: e.loop,
    ilen: c < l && !u ? i + c - l : c - l
  };
}
function Kg(s, e, t, i) {
  const { points: r, options: n } = e, { count: o, start: a, loop: l, ilen: c } = Mh(r, t, i), u = qg(n);
  let { move: h = !0, reverse: f } = i || {}, m, _, v;
  for (m = 0; m <= c; ++m)
    _ = r[(a + (f ? c - m : m)) % o], !_.skip && (h ? (s.moveTo(_.x, _.y), h = !1) : u(s, v, _, f, n.stepped), v = _);
  return l && (_ = r[(a + (f ? c : 0)) % o], u(s, v, _, f, n.stepped)), !!l;
}
function Qg(s, e, t, i) {
  const r = e.points, { count: n, start: o, ilen: a } = Mh(r, t, i), { move: l = !0, reverse: c } = i || {};
  let u = 0, h = 0, f, m, _, v, d, p;
  const g = (y) => (o + (c ? a - y : y)) % n, b = () => {
    v !== d && (s.lineTo(u, d), s.lineTo(u, v), s.lineTo(u, p));
  };
  for (l && (m = r[g(0)], s.moveTo(m.x, m.y)), f = 0; f <= a; ++f) {
    if (m = r[g(f)], m.skip)
      continue;
    const y = m.x, w = m.y, k = y | 0;
    k === _ ? (w < v ? v = w : w > d && (d = w), u = (h * u + y) / ++h) : (b(), s.lineTo(y, w), _ = k, h = 0, v = d = w), p = w;
  }
  b();
}
function Io(s) {
  const e = s.options, t = e.borderDash && e.borderDash.length;
  return !s._decimated && !s._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !t ? Qg : Kg;
}
function Yg(s) {
  return s.stepped ? Kf : s.tension || s.cubicInterpolationMode === "monotone" ? Qf : vs;
}
function Gg(s, e, t, i) {
  let r = e._path;
  r || (r = e._path = new Path2D(), e.path(r, t, i) && r.closePath()), Lh(s, e.options), s.stroke(r);
}
function Xg(s, e, t, i) {
  const { segments: r, options: n } = e, o = Io(e);
  for (const a of r)
    Lh(s, n, a.style), s.beginPath(), o(s, e, a, {
      start: t,
      end: t + i - 1
    }) && s.closePath(), s.stroke();
}
const Jg = typeof Path2D == "function";
function Zg(s, e, t, i) {
  Jg && !e.options.segment ? Gg(s, e, t, i) : Xg(s, e, t, i);
}
class Zt extends _t {
  constructor(e) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e);
  }
  updateControlPoints(e, t) {
    const i = this.options;
    if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) {
      const r = i.spanGaps ? this._loop : this._fullLoop;
      Ff(this._points, i, e, r, t), this._pointsUpdated = !0;
    }
  }
  set points(e) {
    this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = ep(this, this.options.segment));
  }
  first() {
    const e = this.segments, t = this.points;
    return e.length && t[e[0].start];
  }
  last() {
    const e = this.segments, t = this.points, i = e.length;
    return i && t[e[i - 1].end];
  }
  interpolate(e, t) {
    const i = this.options, r = e[t], n = this.points, o = bh(this, {
      property: t,
      start: r,
      end: r
    });
    if (!o.length)
      return;
    const a = [], l = Yg(i);
    let c, u;
    for (c = 0, u = o.length; c < u; ++c) {
      const { start: h, end: f } = o[c], m = n[h], _ = n[f];
      if (m === _) {
        a.push(m);
        continue;
      }
      const v = Math.abs((r - m[t]) / (_[t] - m[t])), d = l(m, _, v, i.stepped);
      d[t] = e[t], a.push(d);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(e, t, i) {
    return Io(this)(e, this, t, i);
  }
  path(e, t, i) {
    const r = this.segments, n = Io(this);
    let o = this._loop;
    t = t || 0, i = i || this.points.length - t;
    for (const a of r)
      o &= n(e, this, a, {
        start: t,
        end: t + i - 1
      });
    return !!o;
  }
  draw(e, t, i, r) {
    const n = this.options || {};
    (this.points || []).length && n.borderWidth && (e.save(), Zg(e, this, i, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
K(Zt, "id", "line"), K(Zt, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), K(Zt, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), K(Zt, "descriptors", {
  _scriptable: !0,
  _indexable: (e) => e !== "borderDash" && e !== "fill"
});
function sc(s, e, t, i) {
  const r = s.options, { [t]: n } = s.getProps([
    t
  ], i);
  return Math.abs(e - n) < r.radius + r.hitRadius;
}
class Jr extends _t {
  constructor(t) {
    super();
    K(this, "parsed");
    K(this, "skip");
    K(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, i, r) {
    const n = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], r);
    return Math.pow(t - o, 2) + Math.pow(i - a, 2) < Math.pow(n.hitRadius + n.radius, 2);
  }
  inXRange(t, i) {
    return sc(this, t, "x", i);
  }
  inYRange(t, i) {
    return sc(this, t, "y", i);
  }
  getCenterPoint(t) {
    const { x: i, y: r } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: r
    };
  }
  size(t) {
    t = t || this.options || {};
    let i = t.radius || 0;
    i = Math.max(i, i && t.hoverRadius || 0);
    const r = i && t.borderWidth || 0;
    return (i + r) * 2;
  }
  draw(t, i) {
    const r = this.options;
    this.skip || r.radius < 0.1 || !jt(this, i, this.size(r) / 2) || (t.strokeStyle = r.borderColor, t.lineWidth = r.borderWidth, t.fillStyle = r.backgroundColor, Eo(t, r, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
K(Jr, "id", "point"), /**
* @type {any}
*/
K(Jr, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
K(Jr, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function Ih(s, e) {
  const { x: t, y: i, base: r, width: n, height: o } = s.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], e);
  let a, l, c, u, h;
  return s.horizontal ? (h = o / 2, a = Math.min(t, r), l = Math.max(t, r), c = i - h, u = i + h) : (h = n / 2, a = t - h, l = t + h, c = Math.min(i, r), u = Math.max(i, r)), {
    left: a,
    top: c,
    right: l,
    bottom: u
  };
}
function es(s, e, t, i) {
  return s ? 0 : Fe(e, t, i);
}
function em(s, e, t) {
  const i = s.options.borderWidth, r = s.borderSkipped, n = oh(i);
  return {
    t: es(r.top, n.top, 0, t),
    r: es(r.right, n.right, 0, e),
    b: es(r.bottom, n.bottom, 0, t),
    l: es(r.left, n.left, 0, e)
  };
}
function tm(s, e, t) {
  const { enableBorderRadius: i } = s.getProps([
    "enableBorderRadius"
  ]), r = s.options.borderRadius, n = Cs(r), o = Math.min(e, t), a = s.borderSkipped, l = i || ae(r);
  return {
    topLeft: es(!l || a.top || a.left, n.topLeft, 0, o),
    topRight: es(!l || a.top || a.right, n.topRight, 0, o),
    bottomLeft: es(!l || a.bottom || a.left, n.bottomLeft, 0, o),
    bottomRight: es(!l || a.bottom || a.right, n.bottomRight, 0, o)
  };
}
function sm(s) {
  const e = Ih(s), t = e.right - e.left, i = e.bottom - e.top, r = em(s, t / 2, i / 2), n = tm(s, t / 2, i / 2);
  return {
    outer: {
      x: e.left,
      y: e.top,
      w: t,
      h: i,
      radius: n
    },
    inner: {
      x: e.left + r.l,
      y: e.top + r.t,
      w: t - r.l - r.r,
      h: i - r.t - r.b,
      radius: {
        topLeft: Math.max(0, n.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, n.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, n.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, n.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function po(s, e, t, i) {
  const r = e === null, n = t === null, a = s && !(r && n) && Ih(s, i);
  return a && (r || zt(e, a.left, a.right)) && (n || zt(t, a.top, a.bottom));
}
function im(s) {
  return s.topLeft || s.topRight || s.bottomLeft || s.bottomRight;
}
function rm(s, e) {
  s.rect(e.x, e.y, e.w, e.h);
}
function go(s, e, t = {}) {
  const i = s.x !== t.x ? -e : 0, r = s.y !== t.y ? -e : 0, n = (s.x + s.w !== t.x + t.w ? e : 0) - i, o = (s.y + s.h !== t.y + t.h ? e : 0) - r;
  return {
    x: s.x + i,
    y: s.y + r,
    w: s.w + n,
    h: s.h + o,
    radius: s.radius
  };
}
class Zr extends _t {
  constructor(e) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
  }
  draw(e) {
    const { inflateAmount: t, options: { borderColor: i, backgroundColor: r } } = this, { inner: n, outer: o } = sm(this), a = im(o.radius) ? tr : rm;
    e.save(), (o.w !== n.w || o.h !== n.h) && (e.beginPath(), a(e, go(o, t, n)), e.clip(), a(e, go(n, -t, o)), e.fillStyle = i, e.fill("evenodd")), e.beginPath(), a(e, go(n, t)), e.fillStyle = r, e.fill(), e.restore();
  }
  inRange(e, t, i) {
    return po(this, e, t, i);
  }
  inXRange(e, t) {
    return po(this, e, null, t);
  }
  inYRange(e, t) {
    return po(this, null, e, t);
  }
  getCenterPoint(e) {
    const { x: t, y: i, base: r, horizontal: n } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], e);
    return {
      x: n ? (t + r) / 2 : t,
      y: n ? i : (i + r) / 2
    };
  }
  getRange(e) {
    return e === "x" ? this.width / 2 : this.height / 2;
  }
}
K(Zr, "id", "bar"), K(Zr, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), K(Zr, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var nm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: Pi,
  BarElement: Zr,
  LineElement: Zt,
  PointElement: Jr
});
const Ro = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], ic = /* @__PURE__ */ Ro.map((s) => s.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function Rh(s) {
  return Ro[s % Ro.length];
}
function Oh(s) {
  return ic[s % ic.length];
}
function om(s, e) {
  return s.borderColor = Rh(e), s.backgroundColor = Oh(e), ++e;
}
function am(s, e) {
  return s.backgroundColor = s.data.map(() => Rh(e++)), e;
}
function lm(s, e) {
  return s.backgroundColor = s.data.map(() => Oh(e++)), e;
}
function cm(s) {
  let e = 0;
  return (t, i) => {
    const r = s.getDatasetMeta(i).controller;
    r instanceof ys ? e = am(t, e) : r instanceof qi ? e = lm(t, e) : r && (e = om(t, e));
  };
}
function rc(s) {
  let e;
  for (e in s)
    if (s[e].borderColor || s[e].backgroundColor)
      return !0;
  return !1;
}
function hm(s) {
  return s && (s.borderColor || s.backgroundColor);
}
function dm() {
  return ke.borderColor !== "rgba(0,0,0,0.1)" || ke.backgroundColor !== "rgba(0,0,0,0.1)";
}
var um = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(s, e, t) {
    if (!t.enabled)
      return;
    const { data: { datasets: i }, options: r } = s.config, { elements: n } = r, o = rc(i) || hm(r) || n && rc(n) || dm();
    if (!t.forceOverride && o)
      return;
    const a = cm(s);
    i.forEach(a);
  }
};
function fm(s, e, t, i, r) {
  const n = r.samples || i;
  if (n >= t)
    return s.slice(e, e + t);
  const o = [], a = (t - 2) / (n - 2);
  let l = 0;
  const c = e + t - 1;
  let u = e, h, f, m, _, v;
  for (o[l++] = s[u], h = 0; h < n - 2; h++) {
    let d = 0, p = 0, g;
    const b = Math.floor((h + 1) * a) + 1 + e, y = Math.min(Math.floor((h + 2) * a) + 1, t) + e, w = y - b;
    for (g = b; g < y; g++)
      d += s[g].x, p += s[g].y;
    d /= w, p /= w;
    const k = Math.floor(h * a) + 1 + e, C = Math.min(Math.floor((h + 1) * a) + 1, t) + e, { x, y: S } = s[u];
    for (m = _ = -1, g = k; g < C; g++)
      _ = 0.5 * Math.abs((x - d) * (s[g].y - S) - (x - s[g].x) * (p - S)), _ > m && (m = _, f = s[g], v = g);
    o[l++] = f, u = v;
  }
  return o[l++] = s[c], o;
}
function pm(s, e, t, i) {
  let r = 0, n = 0, o, a, l, c, u, h, f, m, _, v;
  const d = [], p = e + t - 1, g = s[e].x, y = s[p].x - g;
  for (o = e; o < e + t; ++o) {
    a = s[o], l = (a.x - g) / y * i, c = a.y;
    const w = l | 0;
    if (w === u)
      c < _ ? (_ = c, h = o) : c > v && (v = c, f = o), r = (n * r + a.x) / ++n;
    else {
      const k = o - 1;
      if (!oe(h) && !oe(f)) {
        const C = Math.min(h, f), x = Math.max(h, f);
        C !== m && C !== k && d.push({
          ...s[C],
          x: r
        }), x !== m && x !== k && d.push({
          ...s[x],
          x: r
        });
      }
      o > 0 && k !== m && d.push(s[k]), d.push(a), u = w, n = 0, _ = v = c, h = f = m = o;
    }
  }
  return d;
}
function Ph(s) {
  if (s._decimated) {
    const e = s._data;
    delete s._decimated, delete s._data, Object.defineProperty(s, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: e
    });
  }
}
function nc(s) {
  s.data.datasets.forEach((e) => {
    Ph(e);
  });
}
function gm(s, e) {
  const t = e.length;
  let i = 0, r;
  const { iScale: n } = s, { min: o, max: a, minDefined: l, maxDefined: c } = n.getUserBounds();
  return l && (i = Fe(Ht(e, n.axis, o).lo, 0, t - 1)), c ? r = Fe(Ht(e, n.axis, a).hi + 1, i, t) - i : r = t - i, {
    start: i,
    count: r
  };
}
var mm = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (s, e, t) => {
    if (!t.enabled) {
      nc(s);
      return;
    }
    const i = s.width;
    s.data.datasets.forEach((r, n) => {
      const { _data: o, indexAxis: a } = r, l = s.getDatasetMeta(n), c = o || r.data;
      if (Ri([
        a,
        s.options.indexAxis
      ]) === "y" || !l.controller.supportsDecimation)
        return;
      const u = s.scales[l.xAxisID];
      if (u.type !== "linear" && u.type !== "time" || s.options.parsing)
        return;
      let { start: h, count: f } = gm(l, c);
      const m = t.threshold || 4 * i;
      if (f <= m) {
        Ph(r);
        return;
      }
      oe(o) && (r._data = c, delete r.data, Object.defineProperty(r, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(v) {
          this._data = v;
        }
      }));
      let _;
      switch (t.algorithm) {
        case "lttb":
          _ = fm(c, h, f, i, t);
          break;
        case "min-max":
          _ = pm(c, h, f, i);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${t.algorithm}'`);
      }
      r._decimated = _;
    });
  },
  destroy(s) {
    nc(s);
  }
};
function bm(s, e, t) {
  const i = s.segments, r = s.points, n = e.points, o = [];
  for (const a of i) {
    let { start: l, end: c } = a;
    c = $n(l, c, r);
    const u = Oo(t, r[l], r[c], a.loop);
    if (!e.segments) {
      o.push({
        source: a,
        target: u,
        start: r[l],
        end: r[c]
      });
      continue;
    }
    const h = bh(e, u);
    for (const f of h) {
      const m = Oo(t, n[f.start], n[f.end], f.loop), _ = mh(a, r, m);
      for (const v of _)
        o.push({
          source: v,
          target: f,
          start: {
            [t]: oc(u, m, "start", Math.max)
          },
          end: {
            [t]: oc(u, m, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function Oo(s, e, t, i) {
  if (i)
    return;
  let r = e[s], n = t[s];
  return s === "angle" && (r = Qe(r), n = Qe(n)), {
    property: s,
    start: r,
    end: n
  };
}
function vm(s, e) {
  const { x: t = null, y: i = null } = s || {}, r = e.points, n = [];
  return e.segments.forEach(({ start: o, end: a }) => {
    a = $n(o, a, r);
    const l = r[o], c = r[a];
    i !== null ? (n.push({
      x: l.x,
      y: i
    }), n.push({
      x: c.x,
      y: i
    })) : t !== null && (n.push({
      x: t,
      y: l.y
    }), n.push({
      x: t,
      y: c.y
    }));
  }), n;
}
function $n(s, e, t) {
  for (; e > s; e--) {
    const i = t[e];
    if (!isNaN(i.x) && !isNaN(i.y))
      break;
  }
  return e;
}
function oc(s, e, t, i) {
  return s && e ? i(s[t], e[t]) : s ? s[t] : e ? e[t] : 0;
}
function Bh(s, e) {
  let t = [], i = !1;
  return xe(s) ? (i = !0, t = s) : t = vm(s, e), t.length ? new Zt({
    points: t,
    options: {
      tension: 0
    },
    _loop: i,
    _fullLoop: i
  }) : null;
}
function ac(s) {
  return s && s.fill !== !1;
}
function _m(s, e, t) {
  let r = s[e].fill;
  const n = [
    e
  ];
  let o;
  if (!t)
    return r;
  for (; r !== !1 && n.indexOf(r) === -1; ) {
    if (!Te(r))
      return r;
    if (o = s[r], !o)
      return !1;
    if (o.visible)
      return r;
    n.push(r), r = o.fill;
  }
  return !1;
}
function ym(s, e, t) {
  const i = Sm(s);
  if (ae(i))
    return isNaN(i.value) ? !1 : i;
  let r = parseFloat(i);
  return Te(r) && Math.floor(r) === r ? wm(i[0], e, r, t) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(i) >= 0 && i;
}
function wm(s, e, t, i) {
  return (s === "-" || s === "+") && (t = e + t), t === e || t < 0 || t >= i ? !1 : t;
}
function xm(s, e) {
  let t = null;
  return s === "start" ? t = e.bottom : s === "end" ? t = e.top : ae(s) ? t = e.getPixelForValue(s.value) : e.getBasePixel && (t = e.getBasePixel()), t;
}
function km(s, e, t) {
  let i;
  return s === "start" ? i = t : s === "end" ? i = e.options.reverse ? e.min : e.max : ae(s) ? i = s.value : i = e.getBaseValue(), i;
}
function Sm(s) {
  const e = s.options, t = e.fill;
  let i = ee(t && t.target, t);
  return i === void 0 && (i = !!e.backgroundColor), i === !1 || i === null ? !1 : i === !0 ? "origin" : i;
}
function Cm(s) {
  const { scale: e, index: t, line: i } = s, r = [], n = i.segments, o = i.points, a = Dm(e, t);
  a.push(Bh({
    x: null,
    y: e.bottom
  }, i));
  for (let l = 0; l < n.length; l++) {
    const c = n[l];
    for (let u = c.start; u <= c.end; u++)
      $m(r, o[u], a);
  }
  return new Zt({
    points: r,
    options: {}
  });
}
function Dm(s, e) {
  const t = [], i = s.getMatchingVisibleMetas("line");
  for (let r = 0; r < i.length; r++) {
    const n = i[r];
    if (n.index === e)
      break;
    n.hidden || t.unshift(n.dataset);
  }
  return t;
}
function $m(s, e, t) {
  const i = [];
  for (let r = 0; r < t.length; r++) {
    const n = t[r], { first: o, last: a, point: l } = Am(n, e, "x");
    if (!(!l || o && a)) {
      if (o)
        i.unshift(l);
      else if (s.push(l), !a)
        break;
    }
  }
  s.push(...i);
}
function Am(s, e, t) {
  const i = s.interpolate(e, t);
  if (!i)
    return {};
  const r = i[t], n = s.segments, o = s.points;
  let a = !1, l = !1;
  for (let c = 0; c < n.length; c++) {
    const u = n[c], h = o[u.start][t], f = o[u.end][t];
    if (zt(r, h, f)) {
      a = r === h, l = r === f;
      break;
    }
  }
  return {
    first: a,
    last: l,
    point: i
  };
}
class Nh {
  constructor(e) {
    this.x = e.x, this.y = e.y, this.radius = e.radius;
  }
  pathSegment(e, t, i) {
    const { x: r, y: n, radius: o } = this;
    return t = t || {
      start: 0,
      end: _e
    }, e.arc(r, n, o, t.end, t.start, !0), !i.bounds;
  }
  interpolate(e) {
    const { x: t, y: i, radius: r } = this, n = e.angle;
    return {
      x: t + Math.cos(n) * r,
      y: i + Math.sin(n) * r,
      angle: n
    };
  }
}
function Em(s) {
  const { chart: e, fill: t, line: i } = s;
  if (Te(t))
    return Tm(e, t);
  if (t === "stack")
    return Cm(s);
  if (t === "shape")
    return !0;
  const r = Lm(s);
  return r instanceof Nh ? r : Bh(r, i);
}
function Tm(s, e) {
  const t = s.getDatasetMeta(e);
  return t && s.isDatasetVisible(e) ? t.dataset : null;
}
function Lm(s) {
  return (s.scale || {}).getPointPositionForValue ? Im(s) : Mm(s);
}
function Mm(s) {
  const { scale: e = {}, fill: t } = s, i = xm(t, e);
  if (Te(i)) {
    const r = e.isHorizontal();
    return {
      x: r ? i : null,
      y: r ? null : i
    };
  }
  return null;
}
function Im(s) {
  const { scale: e, fill: t } = s, i = e.options, r = e.getLabels().length, n = i.reverse ? e.max : e.min, o = km(t, e, n), a = [];
  if (i.grid.circular) {
    const l = e.getPointPositionForValue(0, n);
    return new Nh({
      x: l.x,
      y: l.y,
      radius: e.getDistanceFromCenterForValue(o)
    });
  }
  for (let l = 0; l < r; ++l)
    a.push(e.getPointPositionForValue(l, o));
  return a;
}
function mo(s, e, t) {
  const i = Em(e), { chart: r, index: n, line: o, scale: a, axis: l } = e, c = o.options, u = c.fill, h = c.backgroundColor, { above: f = h, below: m = h } = u || {}, _ = r.getDatasetMeta(n), v = vh(r, _);
  i && o.points.length && (kn(s, t), Rm(s, {
    line: o,
    target: i,
    above: f,
    below: m,
    area: t,
    scale: a,
    axis: l,
    clip: v
  }), Sn(s));
}
function Rm(s, e) {
  const { line: t, target: i, above: r, below: n, area: o, scale: a, clip: l } = e, c = t._loop ? "angle" : e.axis;
  s.save();
  let u = n;
  n !== r && (c === "x" ? (lc(s, i, o.top), bo(s, {
    line: t,
    target: i,
    color: r,
    scale: a,
    property: c,
    clip: l
  }), s.restore(), s.save(), lc(s, i, o.bottom)) : c === "y" && (cc(s, i, o.left), bo(s, {
    line: t,
    target: i,
    color: n,
    scale: a,
    property: c,
    clip: l
  }), s.restore(), s.save(), cc(s, i, o.right), u = r)), bo(s, {
    line: t,
    target: i,
    color: u,
    scale: a,
    property: c,
    clip: l
  }), s.restore();
}
function lc(s, e, t) {
  const { segments: i, points: r } = e;
  let n = !0, o = !1;
  s.beginPath();
  for (const a of i) {
    const { start: l, end: c } = a, u = r[l], h = r[$n(l, c, r)];
    n ? (s.moveTo(u.x, u.y), n = !1) : (s.lineTo(u.x, t), s.lineTo(u.x, u.y)), o = !!e.pathSegment(s, a, {
      move: o
    }), o ? s.closePath() : s.lineTo(h.x, t);
  }
  s.lineTo(e.first().x, t), s.closePath(), s.clip();
}
function cc(s, e, t) {
  const { segments: i, points: r } = e;
  let n = !0, o = !1;
  s.beginPath();
  for (const a of i) {
    const { start: l, end: c } = a, u = r[l], h = r[$n(l, c, r)];
    n ? (s.moveTo(u.x, u.y), n = !1) : (s.lineTo(t, u.y), s.lineTo(u.x, u.y)), o = !!e.pathSegment(s, a, {
      move: o
    }), o ? s.closePath() : s.lineTo(t, h.y);
  }
  s.lineTo(t, e.first().y), s.closePath(), s.clip();
}
function bo(s, e) {
  const { line: t, target: i, property: r, color: n, scale: o, clip: a } = e, l = bm(t, i, r);
  for (const { source: c, target: u, start: h, end: f } of l) {
    const { style: { backgroundColor: m = n } = {} } = c, _ = i !== !0;
    s.save(), s.fillStyle = m, Om(s, o, a, _ && Oo(r, h, f)), s.beginPath();
    const v = !!t.pathSegment(s, c);
    let d;
    if (_) {
      v ? s.closePath() : hc(s, i, f, r);
      const p = !!i.pathSegment(s, u, {
        move: v,
        reverse: !0
      });
      d = v && p, d || hc(s, i, h, r);
    }
    s.closePath(), s.fill(d ? "evenodd" : "nonzero"), s.restore();
  }
}
function Om(s, e, t, i) {
  const r = e.chart.chartArea, { property: n, start: o, end: a } = i || {};
  if (n === "x" || n === "y") {
    let l, c, u, h;
    n === "x" ? (l = o, c = r.top, u = a, h = r.bottom) : (l = r.left, c = o, u = r.right, h = a), s.beginPath(), t && (l = Math.max(l, t.left), u = Math.min(u, t.right), c = Math.max(c, t.top), h = Math.min(h, t.bottom)), s.rect(l, c, u - l, h - c), s.clip();
  }
}
function hc(s, e, t, i) {
  const r = e.interpolate(t, i);
  r && s.lineTo(r.x, r.y);
}
var Pm = {
  id: "filler",
  afterDatasetsUpdate(s, e, t) {
    const i = (s.data.datasets || []).length, r = [];
    let n, o, a, l;
    for (o = 0; o < i; ++o)
      n = s.getDatasetMeta(o), a = n.dataset, l = null, a && a.options && a instanceof Zt && (l = {
        visible: s.isDatasetVisible(o),
        index: o,
        fill: ym(a, o, i),
        chart: s,
        axis: n.controller.options.indexAxis,
        scale: n.vScale,
        line: a
      }), n.$filler = l, r.push(l);
    for (o = 0; o < i; ++o)
      l = r[o], !(!l || l.fill === !1) && (l.fill = _m(r, o, t.propagate));
  },
  beforeDraw(s, e, t) {
    const i = t.drawTime === "beforeDraw", r = s.getSortedVisibleDatasetMetas(), n = s.chartArea;
    for (let o = r.length - 1; o >= 0; --o) {
      const a = r[o].$filler;
      a && (a.line.updateControlPoints(n, a.axis), i && a.fill && mo(s.ctx, a, n));
    }
  },
  beforeDatasetsDraw(s, e, t) {
    if (t.drawTime !== "beforeDatasetsDraw")
      return;
    const i = s.getSortedVisibleDatasetMetas();
    for (let r = i.length - 1; r >= 0; --r) {
      const n = i[r].$filler;
      ac(n) && mo(s.ctx, n, s.chartArea);
    }
  },
  beforeDatasetDraw(s, e, t) {
    const i = e.meta.$filler;
    !ac(i) || t.drawTime !== "beforeDatasetDraw" || mo(s.ctx, i, s.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const dc = (s, e) => {
  let { boxHeight: t = e, boxWidth: i = e } = s;
  return s.usePointStyle && (t = Math.min(t, e), i = s.pointStyleWidth || Math.min(i, e)), {
    boxWidth: i,
    boxHeight: t,
    itemHeight: Math.max(e, t)
  };
}, Bm = (s, e) => s !== null && e !== null && s.datasetIndex === e.datasetIndex && s.index === e.index;
class uc extends _t {
  constructor(e) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, t, i) {
    this.maxWidth = e, this.maxHeight = t, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let t = be(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (t = t.filter((i) => e.filter(i, this.chart.data))), e.sort && (t = t.sort((i, r) => e.sort(i, r, this.chart.data))), this.options.reverse && t.reverse(), this.legendItems = t;
  }
  fit() {
    const { options: e, ctx: t } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const i = e.labels, r = Oe(i.font), n = r.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = dc(i, n);
    let c, u;
    t.font = r.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(o, n, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(o, r, a, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, t, i, r) {
    const { ctx: n, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], u = r + a;
    let h = e;
    n.textAlign = "left", n.textBaseline = "middle";
    let f = -1, m = -u;
    return this.legendItems.forEach((_, v) => {
      const d = i + t / 2 + n.measureText(_.text).width;
      (v === 0 || c[c.length - 1] + d + 2 * a > o) && (h += u, c[c.length - (v > 0 ? 0 : 1)] = 0, m += u, f++), l[v] = {
        left: 0,
        top: m,
        row: f,
        width: d,
        height: r
      }, c[c.length - 1] += d + a;
    }), h;
  }
  _fitCols(e, t, i, r) {
    const { ctx: n, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = o - e;
    let h = a, f = 0, m = 0, _ = 0, v = 0;
    return this.legendItems.forEach((d, p) => {
      const { itemWidth: g, itemHeight: b } = Nm(i, t, n, d, r);
      p > 0 && m + b + 2 * a > u && (h += f + a, c.push({
        width: f,
        height: m
      }), _ += f + a, v++, f = m = 0), l[p] = {
        left: _,
        top: m,
        col: v,
        width: g,
        height: b
      }, f = Math.max(f, g), m += b + a;
    }), h += f, c.push({
      width: f,
      height: m
    }), h;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: t, options: { align: i, labels: { padding: r }, rtl: n } } = this, o = si(n, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = Ke(i, this.left + r, this.right - this.lineWidths[a]);
      for (const c of t)
        a !== c.row && (a = c.row, l = Ke(i, this.left + r, this.right - this.lineWidths[a])), c.top += this.top + e + r, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + r;
    } else {
      let a = 0, l = Ke(i, this.top + e + r, this.bottom - this.columnSizes[a].height);
      for (const c of t)
        c.col !== a && (a = c.col, l = Ke(i, this.top + e + r, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + r, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      kn(e, this), this._draw(), Sn(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: t, lineWidths: i, ctx: r } = this, { align: n, labels: o } = e, a = ke.color, l = si(e.rtl, this.left, this.width), c = Oe(o.font), { padding: u } = o, h = c.size, f = h / 2;
    let m;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = c.string;
    const { boxWidth: _, boxHeight: v, itemHeight: d } = dc(o, h), p = function(k, C, x) {
      if (isNaN(_) || _ <= 0 || isNaN(v) || v < 0)
        return;
      r.save();
      const S = ee(x.lineWidth, 1);
      if (r.fillStyle = ee(x.fillStyle, a), r.lineCap = ee(x.lineCap, "butt"), r.lineDashOffset = ee(x.lineDashOffset, 0), r.lineJoin = ee(x.lineJoin, "miter"), r.lineWidth = S, r.strokeStyle = ee(x.strokeStyle, a), r.setLineDash(ee(x.lineDash, [])), o.usePointStyle) {
        const T = {
          radius: v * Math.SQRT2 / 2,
          pointStyle: x.pointStyle,
          rotation: x.rotation,
          borderWidth: S
        }, M = l.xPlus(k, _ / 2), E = C + f;
        nh(r, T, M, E, o.pointStyleWidth && _);
      } else {
        const T = C + Math.max((h - v) / 2, 0), M = l.leftForLtr(k, _), E = Cs(x.borderRadius);
        r.beginPath(), Object.values(E).some((R) => R !== 0) ? tr(r, {
          x: M,
          y: T,
          w: _,
          h: v,
          radius: E
        }) : r.rect(M, T, _, v), r.fill(), S !== 0 && r.stroke();
      }
      r.restore();
    }, g = function(k, C, x) {
      Ls(r, x.text, k, C + d / 2, c, {
        strikethrough: x.hidden,
        textAlign: l.textAlign(x.textAlign)
      });
    }, b = this.isHorizontal(), y = this._computeTitleHeight();
    b ? m = {
      x: Ke(n, this.left + u, this.right - i[0]),
      y: this.top + u + y,
      line: 0
    } : m = {
      x: this.left + u,
      y: Ke(n, this.top + y + u, this.bottom - t[0].height),
      line: 0
    }, fh(this.ctx, e.textDirection);
    const w = d + u;
    this.legendItems.forEach((k, C) => {
      r.strokeStyle = k.fontColor, r.fillStyle = k.fontColor;
      const x = r.measureText(k.text).width, S = l.textAlign(k.textAlign || (k.textAlign = o.textAlign)), T = _ + f + x;
      let M = m.x, E = m.y;
      l.setWidth(this.width), b ? C > 0 && M + T + u > this.right && (E = m.y += w, m.line++, M = m.x = Ke(n, this.left + u, this.right - i[m.line])) : C > 0 && E + w > this.bottom && (M = m.x = M + t[m.line].width + u, m.line++, E = m.y = Ke(n, this.top + y + u, this.bottom - t[m.line].height));
      const R = l.x(M);
      if (p(R, E, k), M = sf(S, M + _ + f, b ? M + T : this.right, e.rtl), g(l.x(M), E, k), b)
        m.x += T + u;
      else if (typeof k.text != "string") {
        const z = c.lineHeight;
        m.y += Fh(k, z) + u;
      } else
        m.y += w;
    }), ph(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, t = e.title, i = Oe(t.font), r = Xe(t.padding);
    if (!t.display)
      return;
    const n = si(e.rtl, this.left, this.width), o = this.ctx, a = t.position, l = i.size / 2, c = r.top + l;
    let u, h = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), u = this.top + c, h = Ke(e.align, h, this.right - f);
    else {
      const _ = this.columnSizes.reduce((v, d) => Math.max(v, d.height), 0);
      u = c + Ke(e.align, this.top, this.bottom - _ - e.labels.padding - this._computeTitleHeight());
    }
    const m = Ke(a, h, h + f);
    o.textAlign = n.textAlign(aa(a)), o.textBaseline = "middle", o.strokeStyle = t.color, o.fillStyle = t.color, o.font = i.string, Ls(o, t.text, m, u, i);
  }
  _computeTitleHeight() {
    const e = this.options.title, t = Oe(e.font), i = Xe(e.padding);
    return e.display ? t.lineHeight + i.height : 0;
  }
  _getLegendItemAt(e, t) {
    let i, r, n;
    if (zt(e, this.left, this.right) && zt(t, this.top, this.bottom)) {
      for (n = this.legendHitBoxes, i = 0; i < n.length; ++i)
        if (r = n[i], zt(e, r.left, r.left + r.width) && zt(t, r.top, r.top + r.height))
          return this.legendItems[i];
    }
    return null;
  }
  handleEvent(e) {
    const t = this.options;
    if (!Hm(e.type, t))
      return;
    const i = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const r = this._hoveredItem, n = Bm(r, i);
      r && !n && be(t.onLeave, [
        e,
        r,
        this
      ], this), this._hoveredItem = i, i && !n && be(t.onHover, [
        e,
        i,
        this
      ], this);
    } else i && be(t.onClick, [
      e,
      i,
      this
    ], this);
  }
}
function Nm(s, e, t, i, r) {
  const n = Fm(i, s, e, t), o = zm(r, i, e.lineHeight);
  return {
    itemWidth: n,
    itemHeight: o
  };
}
function Fm(s, e, t, i) {
  let r = s.text;
  return r && typeof r != "string" && (r = r.reduce((n, o) => n.length > o.length ? n : o)), e + t.size / 2 + i.measureText(r).width;
}
function zm(s, e, t) {
  let i = s;
  return typeof e.text != "string" && (i = Fh(e, t)), i;
}
function Fh(s, e) {
  const t = s.text ? s.text.length : 0;
  return e * t;
}
function Hm(s, e) {
  return !!((s === "mousemove" || s === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (s === "click" || s === "mouseup"));
}
var jm = {
  id: "legend",
  _element: uc,
  start(s, e, t) {
    const i = s.legend = new uc({
      ctx: s.ctx,
      options: t,
      chart: s
    });
    Ye.configure(s, i, t), Ye.addBox(s, i);
  },
  stop(s) {
    Ye.removeBox(s, s.legend), delete s.legend;
  },
  beforeUpdate(s, e, t) {
    const i = s.legend;
    Ye.configure(s, i, t), i.options = t;
  },
  afterUpdate(s) {
    const e = s.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(s, e) {
    e.replay || s.legend.handleEvent(e.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(s, e, t) {
      const i = e.datasetIndex, r = t.chart;
      r.isDatasetVisible(i) ? (r.hide(i), e.hidden = !0) : (r.show(i), e.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (s) => s.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(s) {
        const e = s.data.datasets, { labels: { usePointStyle: t, pointStyle: i, textAlign: r, color: n, useBorderRadius: o, borderRadius: a } } = s.legend.options;
        return s._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(t ? 0 : void 0), u = Xe(c.borderWidth);
          return {
            text: e[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: n,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: i || c.pointStyle,
            rotation: c.rotation,
            textAlign: r || c.textAlign,
            borderRadius: o && (a || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (s) => s.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (s) => !s.startsWith("on"),
    labels: {
      _scriptable: (s) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(s)
    }
  }
};
class ma extends _t {
  constructor(e) {
    super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, t) {
    const i = this.options;
    if (this.left = 0, this.top = 0, !i.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = e, this.height = this.bottom = t;
    const r = xe(i.text) ? i.text.length : 1;
    this._padding = Xe(i.padding);
    const n = r * Oe(i.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = n : this.width = n;
  }
  isHorizontal() {
    const e = this.options.position;
    return e === "top" || e === "bottom";
  }
  _drawArgs(e) {
    const { top: t, left: i, bottom: r, right: n, options: o } = this, a = o.align;
    let l = 0, c, u, h;
    return this.isHorizontal() ? (u = Ke(a, i, n), h = t + e, c = n - i) : (o.position === "left" ? (u = i + e, h = Ke(a, r, t), l = ce * -0.5) : (u = n - e, h = Ke(a, t, r), l = ce * 0.5), c = r - t), {
      titleX: u,
      titleY: h,
      maxWidth: c,
      rotation: l
    };
  }
  draw() {
    const e = this.ctx, t = this.options;
    if (!t.display)
      return;
    const i = Oe(t.font), n = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(n);
    Ls(e, t.text, 0, 0, i, {
      color: t.color,
      maxWidth: l,
      rotation: c,
      textAlign: aa(t.align),
      textBaseline: "middle",
      translation: [
        o,
        a
      ]
    });
  }
}
function Um(s, e) {
  const t = new ma({
    ctx: s.ctx,
    options: e,
    chart: s
  });
  Ye.configure(s, t, e), Ye.addBox(s, t), s.titleBlock = t;
}
var Wm = {
  id: "title",
  _element: ma,
  start(s, e, t) {
    Um(s, t);
  },
  stop(s) {
    const e = s.titleBlock;
    Ye.removeBox(s, e), delete s.titleBlock;
  },
  beforeUpdate(s, e, t) {
    const i = s.titleBlock;
    Ye.configure(s, i, t), i.options = t;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Pr = /* @__PURE__ */ new WeakMap();
var Vm = {
  id: "subtitle",
  start(s, e, t) {
    const i = new ma({
      ctx: s.ctx,
      options: t,
      chart: s
    });
    Ye.configure(s, i, t), Ye.addBox(s, i), Pr.set(s, i);
  },
  stop(s) {
    Ye.removeBox(s, Pr.get(s)), Pr.delete(s);
  },
  beforeUpdate(s, e, t) {
    const i = Pr.get(s);
    Ye.configure(s, i, t), i.options = t;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Bi = {
  average(s) {
    if (!s.length)
      return !1;
    let e, t, i = /* @__PURE__ */ new Set(), r = 0, n = 0;
    for (e = 0, t = s.length; e < t; ++e) {
      const a = s[e].element;
      if (a && a.hasValue()) {
        const l = a.tooltipPosition();
        i.add(l.x), r += l.y, ++n;
      }
    }
    return n === 0 || i.size === 0 ? !1 : {
      x: [
        ...i
      ].reduce((a, l) => a + l) / i.size,
      y: r / n
    };
  },
  nearest(s, e) {
    if (!s.length)
      return !1;
    let t = e.x, i = e.y, r = Number.POSITIVE_INFINITY, n, o, a;
    for (n = 0, o = s.length; n < o; ++n) {
      const l = s[n].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), u = $o(e, c);
        u < r && (r = u, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      t = l.x, i = l.y;
    }
    return {
      x: t,
      y: i
    };
  }
};
function Ct(s, e) {
  return e && (xe(e) ? Array.prototype.push.apply(s, e) : s.push(e)), s;
}
function Nt(s) {
  return (typeof s == "string" || s instanceof String) && s.indexOf(`
`) > -1 ? s.split(`
`) : s;
}
function qm(s, e) {
  const { element: t, datasetIndex: i, index: r } = e, n = s.getDatasetMeta(i).controller, { label: o, value: a } = n.getLabelAndValue(r);
  return {
    chart: s,
    label: o,
    parsed: n.getParsed(r),
    raw: s.data.datasets[i].data[r],
    formattedValue: a,
    dataset: n.getDataset(),
    dataIndex: r,
    datasetIndex: i,
    element: t
  };
}
function fc(s, e) {
  const t = s.chart.ctx, { body: i, footer: r, title: n } = s, { boxWidth: o, boxHeight: a } = e, l = Oe(e.bodyFont), c = Oe(e.titleFont), u = Oe(e.footerFont), h = n.length, f = r.length, m = i.length, _ = Xe(e.padding);
  let v = _.height, d = 0, p = i.reduce((y, w) => y + w.before.length + w.lines.length + w.after.length, 0);
  if (p += s.beforeBody.length + s.afterBody.length, h && (v += h * c.lineHeight + (h - 1) * e.titleSpacing + e.titleMarginBottom), p) {
    const y = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    v += m * y + (p - m) * l.lineHeight + (p - 1) * e.bodySpacing;
  }
  f && (v += e.footerMarginTop + f * u.lineHeight + (f - 1) * e.footerSpacing);
  let g = 0;
  const b = function(y) {
    d = Math.max(d, t.measureText(y).width + g);
  };
  return t.save(), t.font = c.string, ue(s.title, b), t.font = l.string, ue(s.beforeBody.concat(s.afterBody), b), g = e.displayColors ? o + 2 + e.boxPadding : 0, ue(i, (y) => {
    ue(y.before, b), ue(y.lines, b), ue(y.after, b);
  }), g = 0, t.font = u.string, ue(s.footer, b), t.restore(), d += _.width, {
    width: d,
    height: v
  };
}
function Km(s, e) {
  const { y: t, height: i } = e;
  return t < i / 2 ? "top" : t > s.height - i / 2 ? "bottom" : "center";
}
function Qm(s, e, t, i) {
  const { x: r, width: n } = i, o = t.caretSize + t.caretPadding;
  if (s === "left" && r + n + o > e.width || s === "right" && r - n - o < 0)
    return !0;
}
function Ym(s, e, t, i) {
  const { x: r, width: n } = t, { width: o, chartArea: { left: a, right: l } } = s;
  let c = "center";
  return i === "center" ? c = r <= (a + l) / 2 ? "left" : "right" : r <= n / 2 ? c = "left" : r >= o - n / 2 && (c = "right"), Qm(c, s, e, t) && (c = "center"), c;
}
function pc(s, e, t) {
  const i = t.yAlign || e.yAlign || Km(s, t);
  return {
    xAlign: t.xAlign || e.xAlign || Ym(s, e, t, i),
    yAlign: i
  };
}
function Gm(s, e) {
  let { x: t, width: i } = s;
  return e === "right" ? t -= i : e === "center" && (t -= i / 2), t;
}
function Xm(s, e, t) {
  let { y: i, height: r } = s;
  return e === "top" ? i += t : e === "bottom" ? i -= r + t : i -= r / 2, i;
}
function gc(s, e, t, i) {
  const { caretSize: r, caretPadding: n, cornerRadius: o } = s, { xAlign: a, yAlign: l } = t, c = r + n, { topLeft: u, topRight: h, bottomLeft: f, bottomRight: m } = Cs(o);
  let _ = Gm(e, a);
  const v = Xm(e, l, c);
  return l === "center" ? a === "left" ? _ += c : a === "right" && (_ -= c) : a === "left" ? _ -= Math.max(u, f) + r : a === "right" && (_ += Math.max(h, m) + r), {
    x: Fe(_, 0, i.width - e.width),
    y: Fe(v, 0, i.height - e.height)
  };
}
function Br(s, e, t) {
  const i = Xe(t.padding);
  return e === "center" ? s.x + s.width / 2 : e === "right" ? s.x + s.width - i.right : s.x + i.left;
}
function mc(s) {
  return Ct([], Nt(s));
}
function Jm(s, e, t) {
  return cs(s, {
    tooltip: e,
    tooltipItems: t,
    type: "tooltip"
  });
}
function bc(s, e) {
  const t = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return t ? s.override(t) : s;
}
const zh = {
  beforeTitle: Pt,
  title(s) {
    if (s.length > 0) {
      const e = s[0], t = e.chart.data.labels, i = t ? t.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (i > 0 && e.dataIndex < i)
        return t[e.dataIndex];
    }
    return "";
  },
  afterTitle: Pt,
  beforeBody: Pt,
  beforeLabel: Pt,
  label(s) {
    if (this && this.options && this.options.mode === "dataset")
      return s.label + ": " + s.formattedValue || s.formattedValue;
    let e = s.dataset.label || "";
    e && (e += ": ");
    const t = s.formattedValue;
    return oe(t) || (e += t), e;
  },
  labelColor(s) {
    const t = s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);
    return {
      borderColor: t.borderColor,
      backgroundColor: t.backgroundColor,
      borderWidth: t.borderWidth,
      borderDash: t.borderDash,
      borderDashOffset: t.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(s) {
    const t = s.chart.getDatasetMeta(s.datasetIndex).controller.getStyle(s.dataIndex);
    return {
      pointStyle: t.pointStyle,
      rotation: t.rotation
    };
  },
  afterLabel: Pt,
  afterBody: Pt,
  beforeFooter: Pt,
  footer: Pt,
  afterFooter: Pt
};
function rt(s, e, t, i) {
  const r = s[e].call(t, i);
  return typeof r > "u" ? zh[e].call(t, i) : r;
}
class Po extends _t {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const t = this.chart, i = this.options.setContext(this.getContext()), r = i.enabled && t.options.animation && i.animations, n = new _h(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(n)), n;
  }
  getContext() {
    return this.$context || (this.$context = Jm(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, t) {
    const { callbacks: i } = t, r = rt(i, "beforeTitle", this, e), n = rt(i, "title", this, e), o = rt(i, "afterTitle", this, e);
    let a = [];
    return a = Ct(a, Nt(r)), a = Ct(a, Nt(n)), a = Ct(a, Nt(o)), a;
  }
  getBeforeBody(e, t) {
    return mc(rt(t.callbacks, "beforeBody", this, e));
  }
  getBody(e, t) {
    const { callbacks: i } = t, r = [];
    return ue(e, (n) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, a = bc(i, n);
      Ct(o.before, Nt(rt(a, "beforeLabel", this, n))), Ct(o.lines, rt(a, "label", this, n)), Ct(o.after, Nt(rt(a, "afterLabel", this, n))), r.push(o);
    }), r;
  }
  getAfterBody(e, t) {
    return mc(rt(t.callbacks, "afterBody", this, e));
  }
  getFooter(e, t) {
    const { callbacks: i } = t, r = rt(i, "beforeFooter", this, e), n = rt(i, "footer", this, e), o = rt(i, "afterFooter", this, e);
    let a = [];
    return a = Ct(a, Nt(r)), a = Ct(a, Nt(n)), a = Ct(a, Nt(o)), a;
  }
  _createItems(e) {
    const t = this._active, i = this.chart.data, r = [], n = [], o = [];
    let a = [], l, c;
    for (l = 0, c = t.length; l < c; ++l)
      a.push(qm(this.chart, t[l]));
    return e.filter && (a = a.filter((u, h, f) => e.filter(u, h, f, i))), e.itemSort && (a = a.sort((u, h) => e.itemSort(u, h, i))), ue(a, (u) => {
      const h = bc(e.callbacks, u);
      r.push(rt(h, "labelColor", this, u)), n.push(rt(h, "labelPointStyle", this, u)), o.push(rt(h, "labelTextColor", this, u));
    }), this.labelColors = r, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = a, a;
  }
  update(e, t) {
    const i = this.options.setContext(this.getContext()), r = this._active;
    let n, o = [];
    if (!r.length)
      this.opacity !== 0 && (n = {
        opacity: 0
      });
    else {
      const a = Bi[i.position].call(this, r, this._eventPosition);
      o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);
      const l = this._size = fc(this, i), c = Object.assign({}, a, l), u = pc(this.chart, i, c), h = gc(i, c, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, n = {
        opacity: 1,
        x: h.x,
        y: h.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), e && i.external && i.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: t
    });
  }
  drawCaret(e, t, i, r) {
    const n = this.getCaretPosition(e, i, r);
    t.lineTo(n.x1, n.y1), t.lineTo(n.x2, n.y2), t.lineTo(n.x3, n.y3);
  }
  getCaretPosition(e, t, i) {
    const { xAlign: r, yAlign: n } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: h } = Cs(a), { x: f, y: m } = e, { width: _, height: v } = t;
    let d, p, g, b, y, w;
    return n === "center" ? (y = m + v / 2, r === "left" ? (d = f, p = d - o, b = y + o, w = y - o) : (d = f + _, p = d + o, b = y - o, w = y + o), g = d) : (r === "left" ? p = f + Math.max(l, u) + o : r === "right" ? p = f + _ - Math.max(c, h) - o : p = this.caretX, n === "top" ? (b = m, y = b - o, d = p - o, g = p + o) : (b = m + v, y = b + o, d = p + o, g = p - o), w = b), {
      x1: d,
      x2: p,
      x3: g,
      y1: b,
      y2: y,
      y3: w
    };
  }
  drawTitle(e, t, i) {
    const r = this.title, n = r.length;
    let o, a, l;
    if (n) {
      const c = si(i.rtl, this.x, this.width);
      for (e.x = Br(this, i.titleAlign, i), t.textAlign = c.textAlign(i.titleAlign), t.textBaseline = "middle", o = Oe(i.titleFont), a = i.titleSpacing, t.fillStyle = i.titleColor, t.font = o.string, l = 0; l < n; ++l)
        t.fillText(r[l], c.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === n && (e.y += i.titleMarginBottom - a);
    }
  }
  _drawColorBox(e, t, i, r, n) {
    const o = this.labelColors[i], a = this.labelPointStyles[i], { boxHeight: l, boxWidth: c } = n, u = Oe(n.bodyFont), h = Br(this, "left", n), f = r.x(h), m = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, _ = t.y + m;
    if (n.usePointStyle) {
      const v = {
        radius: Math.min(c, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, d = r.leftForLtr(f, c) + c / 2, p = _ + l / 2;
      e.strokeStyle = n.multiKeyBackground, e.fillStyle = n.multiKeyBackground, Eo(e, v, d, p), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, Eo(e, v, d, p);
    } else {
      e.lineWidth = ae(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0;
      const v = r.leftForLtr(f, c), d = r.leftForLtr(r.xPlus(f, 1), c - 2), p = Cs(o.borderRadius);
      Object.values(p).some((g) => g !== 0) ? (e.beginPath(), e.fillStyle = n.multiKeyBackground, tr(e, {
        x: v,
        y: _,
        w: c,
        h: l,
        radius: p
      }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), tr(e, {
        x: d,
        y: _ + 1,
        w: c - 2,
        h: l - 2,
        radius: p
      }), e.fill()) : (e.fillStyle = n.multiKeyBackground, e.fillRect(v, _, c, l), e.strokeRect(v, _, c, l), e.fillStyle = o.backgroundColor, e.fillRect(d, _ + 1, c - 2, l - 2));
    }
    e.fillStyle = this.labelTextColors[i];
  }
  drawBody(e, t, i) {
    const { body: r } = this, { bodySpacing: n, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = i, h = Oe(i.bodyFont);
    let f = h.lineHeight, m = 0;
    const _ = si(i.rtl, this.x, this.width), v = function(x) {
      t.fillText(x, _.x(e.x + m), e.y + f / 2), e.y += f + n;
    }, d = _.textAlign(o);
    let p, g, b, y, w, k, C;
    for (t.textAlign = o, t.textBaseline = "middle", t.font = h.string, e.x = Br(this, d, i), t.fillStyle = i.bodyColor, ue(this.beforeBody, v), m = a && d !== "right" ? o === "center" ? c / 2 + u : c + 2 + u : 0, y = 0, k = r.length; y < k; ++y) {
      for (p = r[y], g = this.labelTextColors[y], t.fillStyle = g, ue(p.before, v), b = p.lines, a && b.length && (this._drawColorBox(t, e, y, _, i), f = Math.max(h.lineHeight, l)), w = 0, C = b.length; w < C; ++w)
        v(b[w]), f = h.lineHeight;
      ue(p.after, v);
    }
    m = 0, f = h.lineHeight, ue(this.afterBody, v), e.y -= n;
  }
  drawFooter(e, t, i) {
    const r = this.footer, n = r.length;
    let o, a;
    if (n) {
      const l = si(i.rtl, this.x, this.width);
      for (e.x = Br(this, i.footerAlign, i), e.y += i.footerMarginTop, t.textAlign = l.textAlign(i.footerAlign), t.textBaseline = "middle", o = Oe(i.footerFont), t.fillStyle = i.footerColor, t.font = o.string, a = 0; a < n; ++a)
        t.fillText(r[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + i.footerSpacing;
    }
  }
  drawBackground(e, t, i, r) {
    const { xAlign: n, yAlign: o } = this, { x: a, y: l } = e, { width: c, height: u } = i, { topLeft: h, topRight: f, bottomLeft: m, bottomRight: _ } = Cs(r.cornerRadius);
    t.fillStyle = r.backgroundColor, t.strokeStyle = r.borderColor, t.lineWidth = r.borderWidth, t.beginPath(), t.moveTo(a + h, l), o === "top" && this.drawCaret(e, t, i, r), t.lineTo(a + c - f, l), t.quadraticCurveTo(a + c, l, a + c, l + f), o === "center" && n === "right" && this.drawCaret(e, t, i, r), t.lineTo(a + c, l + u - _), t.quadraticCurveTo(a + c, l + u, a + c - _, l + u), o === "bottom" && this.drawCaret(e, t, i, r), t.lineTo(a + m, l + u), t.quadraticCurveTo(a, l + u, a, l + u - m), o === "center" && n === "left" && this.drawCaret(e, t, i, r), t.lineTo(a, l + h), t.quadraticCurveTo(a, l, a + h, l), t.closePath(), t.fill(), r.borderWidth > 0 && t.stroke();
  }
  _updateAnimationTarget(e) {
    const t = this.chart, i = this.$animations, r = i && i.x, n = i && i.y;
    if (r || n) {
      const o = Bi[e.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const a = this._size = fc(this, e), l = Object.assign({}, o, this._size), c = pc(t, e, l), u = gc(e, l, c, t);
      (r._to !== u.x || n._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const t = this.options.setContext(this.getContext());
    let i = this.opacity;
    if (!i)
      return;
    this._updateAnimationTarget(t);
    const r = {
      width: this.width,
      height: this.height
    }, n = {
      x: this.x,
      y: this.y
    };
    i = Math.abs(i) < 1e-3 ? 0 : i;
    const o = Xe(t.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    t.enabled && a && (e.save(), e.globalAlpha = i, this.drawBackground(n, e, r, t), fh(e, t.textDirection), n.y += o.top, this.drawTitle(n, e, t), this.drawBody(n, e, t), this.drawFooter(n, e, t), ph(e, t.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, t) {
    const i = this._active, r = e.map(({ datasetIndex: a, index: l }) => {
      const c = this.chart.getDatasetMeta(a);
      if (!c)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: c.data[l],
        index: l
      };
    }), n = !an(i, r), o = this._positionChanged(r, t);
    (n || o) && (this._active = r, this._eventPosition = t, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(e, t, i = !0) {
    if (t && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, n = this._active || [], o = this._getActiveElements(e, n, t, i), a = this._positionChanged(o, e), l = t || !an(o, n) || a;
    return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(!0, t))), l;
  }
  _getActiveElements(e, t, i, r) {
    const n = this.options;
    if (e.type === "mouseout")
      return [];
    if (!r)
      return t.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(e, n.mode, n, i);
    return n.reverse && o.reverse(), o;
  }
  _positionChanged(e, t) {
    const { caretX: i, caretY: r, options: n } = this, o = Bi[n.position].call(this, e, t);
    return o !== !1 && (i !== o.x || r !== o.y);
  }
}
K(Po, "positioners", Bi);
var Zm = {
  id: "tooltip",
  _element: Po,
  positioners: Bi,
  afterInit(s, e, t) {
    t && (s.tooltip = new Po({
      chart: s,
      options: t
    }));
  },
  beforeUpdate(s, e, t) {
    s.tooltip && s.tooltip.initialize(t);
  },
  reset(s, e, t) {
    s.tooltip && s.tooltip.initialize(t);
  },
  afterDraw(s) {
    const e = s.tooltip;
    if (e && e._willRender()) {
      const t = {
        tooltip: e
      };
      if (s.notifyPlugins("beforeTooltipDraw", {
        ...t,
        cancelable: !0
      }) === !1)
        return;
      e.draw(s.ctx), s.notifyPlugins("afterTooltipDraw", t);
    }
  },
  afterEvent(s, e) {
    if (s.tooltip) {
      const t = e.replay;
      s.tooltip.handleEvent(e.event, t, e.inChartArea) && (e.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (s, e) => e.bodyFont.size,
    boxWidth: (s, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: zh
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (s) => s !== "filter" && s !== "itemSort" && s !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, eb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: um,
  Decimation: mm,
  Filler: Pm,
  Legend: jm,
  SubTitle: Vm,
  Title: Wm,
  Tooltip: Zm
});
const tb = (s, e, t, i) => (typeof e == "string" ? (t = s.push(e) - 1, i.unshift({
  index: t,
  label: e
})) : isNaN(e) && (t = null), t);
function sb(s, e, t, i) {
  const r = s.indexOf(e);
  if (r === -1)
    return tb(s, e, t, i);
  const n = s.lastIndexOf(e);
  return r !== n ? t : r;
}
const ib = (s, e) => s === null ? null : Fe(Math.round(s), 0, e);
function vc(s) {
  const e = this.getLabels();
  return s >= 0 && s < e.length ? e[s] : s;
}
class Bo extends zs {
  constructor(e) {
    super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(e) {
    const t = this._addedLabels;
    if (t.length) {
      const i = this.getLabels();
      for (const { index: r, label: n } of t)
        i[r] === n && i.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(e);
  }
  parse(e, t) {
    if (oe(e))
      return null;
    const i = this.getLabels();
    return t = isFinite(t) && i[t] === e ? t : sb(i, e, ee(t, e), this._addedLabels), ib(t, i.length - 1);
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: t } = this.getUserBounds();
    let { min: i, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (e || (i = 0), t || (r = this.getLabels().length - 1)), this.min = i, this.max = r;
  }
  buildTicks() {
    const e = this.min, t = this.max, i = this.options.offset, r = [];
    let n = this.getLabels();
    n = e === 0 && t === n.length - 1 ? n : n.slice(e, t + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? 0.5 : 0);
    for (let o = e; o <= t; o++)
      r.push({
        value: o
      });
    return r;
  }
  getLabelForValue(e) {
    return vc.call(this, e);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(e) {
    return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getPixelForTick(e) {
    const t = this.ticks;
    return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value);
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
K(Bo, "id", "category"), K(Bo, "defaults", {
  ticks: {
    callback: vc
  }
});
function rb(s, e) {
  const t = [], { bounds: r, step: n, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: h, includeBounds: f } = s, m = n || 1, _ = u - 1, { min: v, max: d } = e, p = !oe(o), g = !oe(a), b = !oe(c), y = (d - v) / (h + 1);
  let w = fl((d - v) / _ / m) * m, k, C, x, S;
  if (w < 1e-14 && !p && !g)
    return [
      {
        value: v
      },
      {
        value: d
      }
    ];
  S = Math.ceil(d / w) - Math.floor(v / w), S > _ && (w = fl(S * w / _ / m) * m), oe(l) || (k = Math.pow(10, l), w = Math.ceil(w * k) / k), r === "ticks" ? (C = Math.floor(v / w) * w, x = Math.ceil(d / w) * w) : (C = v, x = d), p && g && n && Yu((a - o) / n, w / 1e3) ? (S = Math.round(Math.min((a - o) / w, u)), w = (a - o) / S, C = o, x = a) : b ? (C = p ? o : C, x = g ? a : x, S = c - 1, w = (x - C) / S) : (S = (x - C) / w, Ui(S, Math.round(S), w / 1e3) ? S = Math.round(S) : S = Math.ceil(S));
  const T = Math.max(pl(w), pl(C));
  k = Math.pow(10, oe(l) ? T : l), C = Math.round(C * k) / k, x = Math.round(x * k) / k;
  let M = 0;
  for (p && (f && C !== o ? (t.push({
    value: o
  }), C < o && M++, Ui(Math.round((C + M * w) * k) / k, o, _c(o, y, s)) && M++) : C < o && M++); M < S; ++M) {
    const E = Math.round((C + M * w) * k) / k;
    if (g && E > a)
      break;
    t.push({
      value: E
    });
  }
  return g && f && x !== a ? t.length && Ui(t[t.length - 1].value, a, _c(a, y, s)) ? t[t.length - 1].value = a : t.push({
    value: a
  }) : (!g || x === a) && t.push({
    value: x
  }), t;
}
function _c(s, e, { horizontal: t, minRotation: i }) {
  const r = bt(i), n = (t ? Math.sin(r) : Math.cos(r)) || 1e-3, o = 0.75 * e * ("" + s).length;
  return Math.min(e / n, o);
}
class pn extends zs {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(e, t) {
    return oe(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options, { minDefined: t, maxDefined: i } = this.getUserBounds();
    let { min: r, max: n } = this;
    const o = (l) => r = t ? r : l, a = (l) => n = i ? n : l;
    if (e) {
      const l = At(r), c = At(n);
      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0);
    }
    if (r === n) {
      let l = n === 0 ? 1 : Math.abs(n * 0.05);
      a(n + l), e || o(r - l);
    }
    this.min = r, this.max = n;
  }
  getTickLimit() {
    const e = this.options.ticks;
    let { maxTicksLimit: t, stepSize: i } = e, r;
    return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), t = t || 11), t && (r = Math.min(t, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const e = this.options, t = e.ticks;
    let i = this.getTickLimit();
    i = Math.max(2, i);
    const r = {
      maxTicks: i,
      bounds: e.bounds,
      min: e.min,
      max: e.max,
      precision: t.precision,
      step: t.stepSize,
      count: t.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: t.minRotation || 0,
      includeBounds: t.includeBounds !== !1
    }, n = this._range || this, o = rb(r, n);
    return e.bounds === "ticks" && Gc(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const e = this.ticks;
    let t = this.min, i = this.max;
    if (super.configure(), this.options.offset && e.length) {
      const r = (i - t) / Math.max(e.length - 1, 1) / 2;
      t -= r, i += r;
    }
    this._startValue = t, this._endValue = i, this._valueRange = i - t;
  }
  getLabelForValue(e) {
    return gr(e, this.chart.options.locale, this.options.ticks.format);
  }
}
class No extends pn {
  determineDataLimits() {
    const { min: e, max: t } = this.getMinMax(!0);
    this.min = Te(e) ? e : 0, this.max = Te(t) ? t : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const e = this.isHorizontal(), t = e ? this.width : this.height, i = bt(this.options.ticks.minRotation), r = (e ? Math.sin(i) : Math.cos(i)) || 1e-3, n = this._resolveTickFontOptions(0);
    return Math.ceil(t / Math.min(40, n.lineHeight / r));
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
  }
}
K(No, "id", "linear"), K(No, "defaults", {
  ticks: {
    callback: xn.formatters.numeric
  }
});
const ir = (s) => Math.floor(Jt(s)), ms = (s, e) => Math.pow(10, ir(s) + e);
function yc(s) {
  return s / Math.pow(10, ir(s)) === 1;
}
function wc(s, e, t) {
  const i = Math.pow(10, t), r = Math.floor(s / i);
  return Math.ceil(e / i) - r;
}
function nb(s, e) {
  const t = e - s;
  let i = ir(t);
  for (; wc(s, e, i) > 10; )
    i++;
  for (; wc(s, e, i) < 10; )
    i--;
  return Math.min(i, ir(s));
}
function ob(s, { min: e, max: t }) {
  e = ct(s.min, e);
  const i = [], r = ir(e);
  let n = nb(e, t), o = n < 0 ? Math.pow(10, Math.abs(n)) : 1;
  const a = Math.pow(10, n), l = r > n ? Math.pow(10, r) : 0, c = Math.round((e - l) * o) / o, u = Math.floor((e - l) / a / 10) * a * 10;
  let h = Math.floor((c - u) / Math.pow(10, n)), f = ct(s.min, Math.round((l + u + h * Math.pow(10, n)) * o) / o);
  for (; f < t; )
    i.push({
      value: f,
      major: yc(f),
      significand: h
    }), h >= 10 ? h = h < 15 ? 15 : 20 : h++, h >= 20 && (n++, h = 2, o = n >= 0 ? 1 : o), f = Math.round((l + u + h * Math.pow(10, n)) * o) / o;
  const m = ct(s.max, f);
  return i.push({
    value: m,
    major: yc(m),
    significand: h
  }), i;
}
class Fo extends zs {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(e, t) {
    const i = pn.prototype.parse.apply(this, [
      e,
      t
    ]);
    if (i === 0) {
      this._zero = !0;
      return;
    }
    return Te(i) && i > 0 ? i : null;
  }
  determineDataLimits() {
    const { min: e, max: t } = this.getMinMax(!0);
    this.min = Te(e) ? Math.max(0, e) : null, this.max = Te(t) ? Math.max(0, t) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Te(this._userMin) && (this.min = e === ms(this.min, 0) ? ms(this.min, -1) : ms(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: e, maxDefined: t } = this.getUserBounds();
    let i = this.min, r = this.max;
    const n = (a) => i = e ? i : a, o = (a) => r = t ? r : a;
    i === r && (i <= 0 ? (n(1), o(10)) : (n(ms(i, -1)), o(ms(r, 1)))), i <= 0 && n(ms(r, -1)), r <= 0 && o(ms(i, 1)), this.min = i, this.max = r;
  }
  buildTicks() {
    const e = this.options, t = {
      min: this._userMin,
      max: this._userMax
    }, i = ob(t, this);
    return e.bounds === "ticks" && Gc(i, this, "value"), e.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i;
  }
  getLabelForValue(e) {
    return e === void 0 ? "0" : gr(e, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const e = this.min;
    super.configure(), this._startValue = Jt(e), this._valueRange = Jt(this.max) - Jt(e);
  }
  getPixelForValue(e) {
    return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Jt(e) - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    const t = this.getDecimalForPixel(e);
    return Math.pow(10, this._startValue + t * this._valueRange);
  }
}
K(Fo, "id", "logarithmic"), K(Fo, "defaults", {
  ticks: {
    callback: xn.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function zo(s) {
  const e = s.ticks;
  if (e.display && s.display) {
    const t = Xe(e.backdropPadding);
    return ee(e.font && e.font.size, ke.font.size) + t.height;
  }
  return 0;
}
function ab(s, e, t) {
  return t = xe(t) ? t : [
    t
  ], {
    w: ff(s, e.string, t),
    h: t.length * e.lineHeight
  };
}
function xc(s, e, t, i, r) {
  return s === i || s === r ? {
    start: e - t / 2,
    end: e + t / 2
  } : s < i || s > r ? {
    start: e - t,
    end: e
  } : {
    start: e,
    end: e + t
  };
}
function lb(s) {
  const e = {
    l: s.left + s._padding.left,
    r: s.right - s._padding.right,
    t: s.top + s._padding.top,
    b: s.bottom - s._padding.bottom
  }, t = Object.assign({}, e), i = [], r = [], n = s._pointLabels.length, o = s.options.pointLabels, a = o.centerPointLabels ? ce / n : 0;
  for (let l = 0; l < n; l++) {
    const c = o.setContext(s.getPointLabelContext(l));
    r[l] = c.padding;
    const u = s.getPointPosition(l, s.drawingArea + r[l], a), h = Oe(c.font), f = ab(s.ctx, h, s._pointLabels[l]);
    i[l] = f;
    const m = Qe(s.getIndexAngle(l) + a), _ = Math.round(na(m)), v = xc(_, u.x, f.w, 0, 180), d = xc(_, u.y, f.h, 90, 270);
    cb(t, e, m, v, d);
  }
  s.setCenterPoint(e.l - t.l, t.r - e.r, e.t - t.t, t.b - e.b), s._pointLabelItems = ub(s, i, r);
}
function cb(s, e, t, i, r) {
  const n = Math.abs(Math.sin(t)), o = Math.abs(Math.cos(t));
  let a = 0, l = 0;
  i.start < e.l ? (a = (e.l - i.start) / n, s.l = Math.min(s.l, e.l - a)) : i.end > e.r && (a = (i.end - e.r) / n, s.r = Math.max(s.r, e.r + a)), r.start < e.t ? (l = (e.t - r.start) / o, s.t = Math.min(s.t, e.t - l)) : r.end > e.b && (l = (r.end - e.b) / o, s.b = Math.max(s.b, e.b + l));
}
function hb(s, e, t) {
  const i = s.drawingArea, { extra: r, additionalAngle: n, padding: o, size: a } = t, l = s.getPointPosition(e, i + r + o, n), c = Math.round(na(Qe(l.angle + Le))), u = gb(l.y, a.h, c), h = fb(c), f = pb(l.x, a.w, h);
  return {
    visible: !0,
    x: l.x,
    y: u,
    textAlign: h,
    left: f,
    top: u,
    right: f + a.w,
    bottom: u + a.h
  };
}
function db(s, e) {
  if (!e)
    return !0;
  const { left: t, top: i, right: r, bottom: n } = s;
  return !(jt({
    x: t,
    y: i
  }, e) || jt({
    x: t,
    y: n
  }, e) || jt({
    x: r,
    y: i
  }, e) || jt({
    x: r,
    y: n
  }, e));
}
function ub(s, e, t) {
  const i = [], r = s._pointLabels.length, n = s.options, { centerPointLabels: o, display: a } = n.pointLabels, l = {
    extra: zo(n) / 2,
    additionalAngle: o ? ce / r : 0
  };
  let c;
  for (let u = 0; u < r; u++) {
    l.padding = t[u], l.size = e[u];
    const h = hb(s, u, l);
    i.push(h), a === "auto" && (h.visible = db(h, c), h.visible && (c = h));
  }
  return i;
}
function fb(s) {
  return s === 0 || s === 180 ? "center" : s < 180 ? "left" : "right";
}
function pb(s, e, t) {
  return t === "right" ? s -= e : t === "center" && (s -= e / 2), s;
}
function gb(s, e, t) {
  return t === 90 || t === 270 ? s -= e / 2 : (t > 270 || t < 90) && (s -= e), s;
}
function mb(s, e, t) {
  const { left: i, top: r, right: n, bottom: o } = t, { backdropColor: a } = e;
  if (!oe(a)) {
    const l = Cs(e.borderRadius), c = Xe(e.backdropPadding);
    s.fillStyle = a;
    const u = i - c.left, h = r - c.top, f = n - i + c.width, m = o - r + c.height;
    Object.values(l).some((_) => _ !== 0) ? (s.beginPath(), tr(s, {
      x: u,
      y: h,
      w: f,
      h: m,
      radius: l
    }), s.fill()) : s.fillRect(u, h, f, m);
  }
}
function bb(s, e) {
  const { ctx: t, options: { pointLabels: i } } = s;
  for (let r = e - 1; r >= 0; r--) {
    const n = s._pointLabelItems[r];
    if (!n.visible)
      continue;
    const o = i.setContext(s.getPointLabelContext(r));
    mb(t, o, n);
    const a = Oe(o.font), { x: l, y: c, textAlign: u } = n;
    Ls(t, s._pointLabels[r], l, c + a.lineHeight / 2, a, {
      color: o.color,
      textAlign: u,
      textBaseline: "middle"
    });
  }
}
function Hh(s, e, t, i) {
  const { ctx: r } = s;
  if (t)
    r.arc(s.xCenter, s.yCenter, e, 0, _e);
  else {
    let n = s.getPointPosition(0, e);
    r.moveTo(n.x, n.y);
    for (let o = 1; o < i; o++)
      n = s.getPointPosition(o, e), r.lineTo(n.x, n.y);
  }
}
function vb(s, e, t, i, r) {
  const n = s.ctx, o = e.circular, { color: a, lineWidth: l } = e;
  !o && !i || !a || !l || t < 0 || (n.save(), n.strokeStyle = a, n.lineWidth = l, n.setLineDash(r.dash || []), n.lineDashOffset = r.dashOffset, n.beginPath(), Hh(s, t, o, i), n.closePath(), n.stroke(), n.restore());
}
function _b(s, e, t) {
  return cs(s, {
    label: t,
    index: e,
    type: "pointLabel"
  });
}
class Ni extends pn {
  constructor(e) {
    super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const e = this._padding = Xe(zo(this.options) / 2), t = this.width = this.maxWidth - e.width, i = this.height = this.maxHeight - e.height;
    this.xCenter = Math.floor(this.left + t / 2 + e.left), this.yCenter = Math.floor(this.top + i / 2 + e.top), this.drawingArea = Math.floor(Math.min(t, i) / 2);
  }
  determineDataLimits() {
    const { min: e, max: t } = this.getMinMax(!1);
    this.min = Te(e) && !isNaN(e) ? e : 0, this.max = Te(t) && !isNaN(t) ? t : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / zo(this.options));
  }
  generateTickLabels(e) {
    pn.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((t, i) => {
      const r = be(this.options.pointLabels.callback, [
        t,
        i
      ], this);
      return r || r === 0 ? r : "";
    }).filter((t, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const e = this.options;
    e.display && e.pointLabels.display ? lb(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(e, t, i, r) {
    this.xCenter += Math.floor((e - t) / 2), this.yCenter += Math.floor((i - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, t, i, r));
  }
  getIndexAngle(e) {
    const t = _e / (this._pointLabels.length || 1), i = this.options.startAngle || 0;
    return Qe(e * t + bt(i));
  }
  getDistanceFromCenterForValue(e) {
    if (oe(e))
      return NaN;
    const t = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - e) * t : (e - this.min) * t;
  }
  getValueForDistanceFromCenter(e) {
    if (oe(e))
      return NaN;
    const t = e / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - t : this.min + t;
  }
  getPointLabelContext(e) {
    const t = this._pointLabels || [];
    if (e >= 0 && e < t.length) {
      const i = t[e];
      return _b(this.getContext(), e, i);
    }
  }
  getPointPosition(e, t, i = 0) {
    const r = this.getIndexAngle(e) - Le + i;
    return {
      x: Math.cos(r) * t + this.xCenter,
      y: Math.sin(r) * t + this.yCenter,
      angle: r
    };
  }
  getPointPositionForValue(e, t) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(t));
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue());
  }
  getPointLabelPosition(e) {
    const { left: t, top: i, right: r, bottom: n } = this._pointLabelItems[e];
    return {
      left: t,
      top: i,
      right: r,
      bottom: n
    };
  }
  drawBackground() {
    const { backgroundColor: e, grid: { circular: t } } = this.options;
    if (e) {
      const i = this.ctx;
      i.save(), i.beginPath(), Hh(this, this.getDistanceFromCenterForValue(this._endValue), t, this._pointLabels.length), i.closePath(), i.fillStyle = e, i.fill(), i.restore();
    }
  }
  drawGrid() {
    const e = this.ctx, t = this.options, { angleLines: i, grid: r, border: n } = t, o = this._pointLabels.length;
    let a, l, c;
    if (t.pointLabels.display && bb(this, o), r.display && this.ticks.forEach((u, h) => {
      if (h !== 0 || h === 0 && this.min < 0) {
        l = this.getDistanceFromCenterForValue(u.value);
        const f = this.getContext(h), m = r.setContext(f), _ = n.setContext(f);
        vb(this, m, l, o, _);
      }
    }), i.display) {
      for (e.save(), a = o - 1; a >= 0; a--) {
        const u = i.setContext(this.getPointLabelContext(a)), { color: h, lineWidth: f } = u;
        !f || !h || (e.lineWidth = f, e.strokeStyle = h, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(t.reverse ? this.min : this.max), c = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(c.x, c.y), e.stroke());
      }
      e.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const e = this.ctx, t = this.options, i = t.ticks;
    if (!i.display)
      return;
    const r = this.getIndexAngle(0);
    let n, o;
    e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => {
      if (l === 0 && this.min >= 0 && !t.reverse)
        return;
      const c = i.setContext(this.getContext(l)), u = Oe(c.font);
      if (n = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        e.font = u.string, o = e.measureText(a.label).width, e.fillStyle = c.backdropColor;
        const h = Xe(c.backdropPadding);
        e.fillRect(-o / 2 - h.left, -n - u.size / 2 - h.top, o + h.width, u.size + h.height);
      }
      Ls(e, a.label, 0, -n, u, {
        color: c.color,
        strokeColor: c.textStrokeColor,
        strokeWidth: c.textStrokeWidth
      });
    }), e.restore();
  }
  drawTitle() {
  }
}
K(Ni, "id", "radialLinear"), K(Ni, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: xn.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(e) {
      return e;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), K(Ni, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), K(Ni, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const An = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, ot = /* @__PURE__ */ Object.keys(An);
function kc(s, e) {
  return s - e;
}
function Sc(s, e) {
  if (oe(e))
    return null;
  const t = s._adapter, { parser: i, round: r, isoWeekday: n } = s._parseOpts;
  let o = e;
  return typeof i == "function" && (o = i(o)), Te(o) || (o = typeof i == "string" ? t.parse(o, i) : t.parse(o)), o === null ? null : (r && (o = r === "week" && (oi(n) || n === !0) ? t.startOf(o, "isoWeek", n) : t.startOf(o, r)), +o);
}
function Cc(s, e, t, i) {
  const r = ot.length;
  for (let n = ot.indexOf(s); n < r - 1; ++n) {
    const o = An[ot[n]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((t - e) / (a * o.size)) <= i)
      return ot[n];
  }
  return ot[r - 1];
}
function yb(s, e, t, i, r) {
  for (let n = ot.length - 1; n >= ot.indexOf(t); n--) {
    const o = ot[n];
    if (An[o].common && s._adapter.diff(r, i, o) >= e - 1)
      return o;
  }
  return ot[t ? ot.indexOf(t) : 0];
}
function wb(s) {
  for (let e = ot.indexOf(s) + 1, t = ot.length; e < t; ++e)
    if (An[ot[e]].common)
      return ot[e];
}
function Dc(s, e, t) {
  if (!t)
    s[e] = !0;
  else if (t.length) {
    const { lo: i, hi: r } = oa(t, e), n = t[i] >= e ? t[i] : t[r];
    s[n] = !0;
  }
}
function xb(s, e, t, i) {
  const r = s._adapter, n = +r.startOf(e[0].value, i), o = e[e.length - 1].value;
  let a, l;
  for (a = n; a <= o; a = +r.add(a, 1, i))
    l = t[a], l >= 0 && (e[l].major = !0);
  return e;
}
function $c(s, e, t) {
  const i = [], r = {}, n = e.length;
  let o, a;
  for (o = 0; o < n; ++o)
    a = e[o], r[a] = o, i.push({
      value: a,
      major: !1
    });
  return n === 0 || !t ? i : xb(s, i, r, t);
}
class rr extends zs {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(e, t = {}) {
    const i = e.time || (e.time = {}), r = this._adapter = new Tp._date(e.adapters.date);
    r.init(t), ji(i.displayFormats, r.formats()), this._parseOpts = {
      parser: i.parser,
      round: i.round,
      isoWeekday: i.isoWeekday
    }, super.init(e), this._normalized = t.normalized;
  }
  parse(e, t) {
    return e === void 0 ? null : Sc(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, t = this._adapter, i = e.time.unit || "day";
    let { min: r, max: n, minDefined: o, maxDefined: a } = this.getUserBounds();
    function l(c) {
      !o && !isNaN(c.min) && (r = Math.min(r, c.min)), !a && !isNaN(c.max) && (n = Math.max(n, c.max));
    }
    (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))), r = Te(r) && !isNaN(r) ? r : +t.startOf(Date.now(), i), n = Te(n) && !isNaN(n) ? n : +t.endOf(Date.now(), i) + 1, this.min = Math.min(r, n - 1), this.max = Math.max(r + 1, n);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let t = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    return e.length && (t = e[0], i = e[e.length - 1]), {
      min: t,
      max: i
    };
  }
  buildTicks() {
    const e = this.options, t = e.time, i = e.ticks, r = i.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const n = this.min, o = this.max, a = Zu(r, n, o);
    return this._unit = t.unit || (i.autoSkip ? Cc(t.minUnit, this.min, this.max, this._getLabelCapacity(n)) : yb(this, a.length, t.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : wb(this._unit), this.initOffsets(r), e.reverse && a.reverse(), $c(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let t = 0, i = 0, r, n;
    this.options.offset && e.length && (r = this.getDecimalForValue(e[0]), e.length === 1 ? t = 1 - r : t = (this.getDecimalForValue(e[1]) - r) / 2, n = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? i = n : i = (n - this.getDecimalForValue(e[e.length - 2])) / 2);
    const o = e.length < 3 ? 0.5 : 0.25;
    t = Fe(t, 0, o), i = Fe(i, 0, o), this._offsets = {
      start: t,
      end: i,
      factor: 1 / (t + 1 + i)
    };
  }
  _generate() {
    const e = this._adapter, t = this.min, i = this.max, r = this.options, n = r.time, o = n.unit || Cc(n.minUnit, t, i, this._getLabelCapacity(t)), a = ee(r.ticks.stepSize, 1), l = o === "week" ? n.isoWeekday : !1, c = oi(l) || l === !0, u = {};
    let h = t, f, m;
    if (c && (h = +e.startOf(h, "isoWeek", l)), h = +e.startOf(h, c ? "day" : o), e.diff(i, t, o) > 1e5 * a)
      throw new Error(t + " and " + i + " are too far apart with stepSize of " + a + " " + o);
    const _ = r.ticks.source === "data" && this.getDataTimestamps();
    for (f = h, m = 0; f < i; f = +e.add(f, a, o), m++)
      Dc(u, f, _);
    return (f === i || r.bounds === "ticks" || m === 1) && Dc(u, f, _), Object.keys(u).sort(kc).map((v) => +v);
  }
  getLabelForValue(e) {
    const t = this._adapter, i = this.options.time;
    return i.tooltipFormat ? t.format(e, i.tooltipFormat) : t.format(e, i.displayFormats.datetime);
  }
  format(e, t) {
    const r = this.options.time.displayFormats, n = this._unit, o = t || r[n];
    return this._adapter.format(e, o);
  }
  _tickFormatFunction(e, t, i, r) {
    const n = this.options, o = n.ticks.callback;
    if (o)
      return be(o, [
        e,
        t,
        i
      ], this);
    const a = n.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], h = c && a[c], f = i[t], m = c && h && f && f.major;
    return this._adapter.format(e, r || (m ? h : u));
  }
  generateTickLabels(e) {
    let t, i, r;
    for (t = 0, i = e.length; t < i; ++t)
      r = e[t], r.label = this._tickFormatFunction(r.value, t, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const t = this._offsets, i = this.getDecimalForValue(e);
    return this.getPixelForDecimal((t.start + i) * t.factor);
  }
  getValueForPixel(e) {
    const t = this._offsets, i = this.getDecimalForPixel(e) / t.factor - t.end;
    return this.min + i * (this.max - this.min);
  }
  _getLabelSize(e) {
    const t = this.options.ticks, i = this.ctx.measureText(e).width, r = bt(this.isHorizontal() ? t.maxRotation : t.minRotation), n = Math.cos(r), o = Math.sin(r), a = this._resolveTickFontOptions(0).size;
    return {
      w: i * n + a * o,
      h: i * o + a * n
    };
  }
  _getLabelCapacity(e) {
    const t = this.options.time, i = t.displayFormats, r = i[t.unit] || i.millisecond, n = this._tickFormatFunction(e, 0, $c(this, [
      e
    ], this._majorUnit), r), o = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], t, i;
    if (e.length)
      return e;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (t = 0, i = r.length; t < i; ++t)
      e = e.concat(r[t].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let t, i;
    if (e.length)
      return e;
    const r = this.getLabels();
    for (t = 0, i = r.length; t < i; ++t)
      e.push(Sc(this, r[t]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return Zc(e.sort(kc));
  }
}
K(rr, "id", "time"), K(rr, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function Nr(s, e, t) {
  let i = 0, r = s.length - 1, n, o, a, l;
  t ? (e >= s[i].pos && e <= s[r].pos && ({ lo: i, hi: r } = Ht(s, "pos", e)), { pos: n, time: a } = s[i], { pos: o, time: l } = s[r]) : (e >= s[i].time && e <= s[r].time && ({ lo: i, hi: r } = Ht(s, "time", e)), { time: n, pos: a } = s[i], { time: o, pos: l } = s[r]);
  const c = o - n;
  return c ? a + (l - a) * (e - n) / c : a;
}
class Ho extends rr {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), t = this._table = this.buildLookupTable(e);
    this._minPos = Nr(t, this.min), this._tableRange = Nr(t, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: t, max: i } = this, r = [], n = [];
    let o, a, l, c, u;
    for (o = 0, a = e.length; o < a; ++o)
      c = e[o], c >= t && c <= i && r.push(c);
    if (r.length < 2)
      return [
        {
          time: t,
          pos: 0
        },
        {
          time: i,
          pos: 1
        }
      ];
    for (o = 0, a = r.length; o < a; ++o)
      u = r[o + 1], l = r[o - 1], c = r[o], Math.round((u + l) / 2) !== c && n.push({
        time: c,
        pos: o / (a - 1)
      });
    return n;
  }
  _generate() {
    const e = this.min, t = this.max;
    let i = super.getDataTimestamps();
    return (!i.includes(e) || !i.length) && i.splice(0, 0, e), (!i.includes(t) || i.length === 1) && i.push(t), i.sort((r, n) => r - n);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const t = this.getDataTimestamps(), i = this.getLabelTimestamps();
    return t.length && i.length ? e = this.normalize(t.concat(i)) : e = t.length ? t : i, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (Nr(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const t = this._offsets, i = this.getDecimalForPixel(e) / t.factor - t.end;
    return Nr(this._table, i * this._tableRange + this._minPos, !0);
  }
}
K(Ho, "id", "timeseries"), K(Ho, "defaults", rr.defaults);
var kb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: Bo,
  LinearScale: No,
  LogarithmicScale: Fo,
  RadialLinearScale: Ni,
  TimeScale: rr,
  TimeSeriesScale: Ho
});
const Sb = [
  Ep,
  nm,
  eb,
  kb
];
$t.register(...Sb);
var Cb = Object.defineProperty, Hs = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Cb(e, t, r), r;
};
const Ba = class Ba extends Fs {
  constructor() {
    super(...arguments), this.systemSummary = null, this.cpuInfo = null, this.memoryInfo = null, this.currentCpuData = null, this.currentMemoryData = null, this.wsConnected = !1, this.wsError = null, this.cpuChart = null, this.memoryChart = null, this.diskChart = null, this.networkChart = null, this.wsManager = null;
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchInitialData();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.cleanup();
  }
  firstUpdated() {
    this.initCharts(), this.initWebSocket();
  }
  async fetchInitialData() {
    try {
      const [e, t, i] = await Promise.all([
        J.get("/system/summary"),
        J.get("/system/cpu"),
        J.get("/system/memory")
      ]);
      this.systemSummary = e, this.cpuInfo = t, this.memoryInfo = i;
    } catch (e) {
      console.error("Failed to fetch system data:", e);
    }
  }
  async initWebSocket() {
    try {
      this.wsManager = new ea("/ws/metrics"), this.wsError = null, this.wsManager.on("auth", (e) => {
        var t;
        (t = e.payload) != null && t.authenticated && (console.log(`Authenticated as ${e.payload.username}`), this.wsConnected = !0, this.wsError = null, this.wsManager.send({
          type: "subscribe"
        }));
      }), this.wsManager.on("data", (e) => {
        var t, i, r;
        if (e.payload) {
          const n = e.payload;
          n.cpu && (this.currentCpuData = {
            usage_percent: n.cpu.usage,
            load1: ((t = n.cpu.load_average) == null ? void 0 : t[0]) || 0,
            load5: ((i = n.cpu.load_average) == null ? void 0 : i[1]) || 0,
            load15: ((r = n.cpu.load_average) == null ? void 0 : r[2]) || 0
          }, this.updateCpuChart(this.currentCpuData)), n.memory && (this.currentMemoryData = n.memory, this.updateMemoryChart(n.memory)), n.disk && this.updateDiskChart(n.disk), n.network && this.updateNetworkChart(n.network), this.requestUpdate();
        }
      }), this.wsManager.on("error", (e) => {
        console.error("WebSocket error:", e), this.wsError = e.error || "WebSocket connection error", this.wsConnected = !1;
      }), await this.wsManager.connect();
    } catch (e) {
      console.error("Failed to connect to metrics WebSocket:", e), this.wsError = e instanceof Error ? e.message : "Failed to connect to metrics", this.wsConnected = !1;
    }
  }
  cleanup() {
    this.wsManager && (this.wsManager.disconnect(), this.wsManager = null), this.cpuChart && (this.cpuChart.destroy(), this.cpuChart = null), this.memoryChart && (this.memoryChart.destroy(), this.memoryChart = null), this.diskChart && (this.diskChart.destroy(), this.diskChart = null), this.networkChart && (this.networkChart.destroy(), this.networkChart = null);
  }
  updateCpuChart(e) {
    var t, i;
    if (this.cpuChart) {
      const r = (/* @__PURE__ */ new Date()).toLocaleTimeString();
      (t = this.cpuChart.data.labels) == null || t.push(r), this.cpuChart.data.datasets[0].data.push(e.usage_percent), this.cpuChart.data.labels.length > 30 && ((i = this.cpuChart.data.labels) == null || i.shift(), this.cpuChart.data.datasets[0].data.shift()), this.cpuChart.update("none");
    }
  }
  updateMemoryChart(e) {
    var t, i;
    if (this.memoryChart) {
      const r = (/* @__PURE__ */ new Date()).toLocaleTimeString();
      (t = this.memoryChart.data.labels) == null || t.push(r), this.memoryChart.data.datasets[0].data.push(e.used_percent), this.memoryChart.data.labels.length > 30 && ((i = this.memoryChart.data.labels) == null || i.shift(), this.memoryChart.data.datasets[0].data.shift()), this.memoryChart.update("none");
    }
  }
  updateDiskChart(e) {
  }
  updateNetworkChart(e) {
  }
  formatBytes(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, i = ["Bytes", "KB", "MB", "GB", "TB"], r = Math.floor(Math.log(e) / Math.log(t));
    return parseFloat((e / Math.pow(t, r)).toFixed(2)) + " " + i[r];
  }
  formatUptime(e) {
    const t = Math.floor(e / 86400), i = Math.floor(e % 86400 / 3600), r = Math.floor(e % 3600 / 60), n = [];
    return t > 0 && n.push(`${t} ${L("dashboard.days")}`), i > 0 && n.push(`${i} ${L("dashboard.hours")}`), r > 0 && n.push(`${r} ${L("dashboard.minutes")}`), n.join(", ") || "0 " + L("dashboard.minutes");
  }
  initCharts() {
    var i, r;
    const e = (i = this.shadowRoot) == null ? void 0 : i.querySelector("#cpuChart"), t = (r = this.shadowRoot) == null ? void 0 : r.querySelector("#memoryChart");
    this.cpuChart = new $t(e, {
      type: "line",
      data: {
        labels: [],
        datasets: [{
          label: L("dashboard.cpuUsage"),
          data: [],
          borderColor: "rgba(75, 192, 192, 1)",
          tension: 0.1
        }]
      },
      options: {
        scales: {
          x: { display: !1 },
          y: {
            beginAtZero: !0,
            max: 100
          }
        }
      }
    }), this.memoryChart = new $t(t, {
      type: "line",
      data: {
        labels: [],
        datasets: [{
          label: L("dashboard.memoryUsage"),
          data: [],
          borderColor: "rgba(153, 102, 255, 1)",
          tension: 0.1
        }]
      },
      options: {
        scales: {
          x: { display: !1 },
          y: {
            beginAtZero: !0,
            max: 100
          }
        }
      }
    });
  }
  render() {
    return D`
      <div class="dashboard">
        <h1>${L("dashboard.title")}</h1>
        
        ${this.systemSummary ? D`
          <div class="system-info">
            <div class="info-card">
              <h3>${L("dashboard.overview")}</h3>
              <div class="info-grid">
                <span class="info-label">${L("dashboard.hostname")}:</span>
                <span class="info-value">${this.systemSummary.hostname}</span>
                
                <span class="info-label">${L("dashboard.os")}:</span>
                <span class="info-value">${this.systemSummary.os}</span>
                
                <span class="info-label">${L("dashboard.kernel")}:</span>
                <span class="info-value">${this.systemSummary.kernel_version}</span>
                
                <span class="info-label">${L("dashboard.uptime")}:</span>
                <span class="info-value">${this.formatUptime(this.systemSummary.uptime)}</span>
                
                <span class="info-label">${L("dashboard.architecture")}:</span>
                <span class="info-value">${this.systemSummary.platform}</span>
              </div>
            </div>
            
            ${this.cpuInfo ? D`
              <div class="info-card">
                <h3>${L("dashboard.cpu")}</h3>
                <div class="info-grid">
                  <span class="info-label">Model:</span>
                  <span class="info-value">${this.cpuInfo.model_name}</span>
                  
                  <span class="info-label">Cores:</span>
                  <span class="info-value">${this.cpuInfo.cores}</span>
                  
                  <span class="info-label">${L("dashboard.loadAverage")}:</span>
                  <span class="info-value">
                    ${this.cpuInfo.load1.toFixed(2)}, 
                    ${this.cpuInfo.load5.toFixed(2)}, 
                    ${this.cpuInfo.load15.toFixed(2)}
                  </span>
                  
                  ${this.currentCpuData ? D`
                    <span class="info-label">Current Usage:</span>
                    <span class="info-value">${this.currentCpuData.usage_percent.toFixed(1)}%</span>
                  ` : ""}
                </div>
              </div>
            ` : ""}
            
            ${this.memoryInfo ? D`
              <div class="info-card">
                <h3>${L("dashboard.memory")}</h3>
                <div class="info-grid">
                  <span class="info-label">Total:</span>
                  <span class="info-value">${this.formatBytes(this.memoryInfo.total)}</span>
                  
                  <span class="info-label">Used:</span>
                  <span class="info-value">
                    ${this.formatBytes(this.memoryInfo.used)} 
                    (${this.memoryInfo.used_percent.toFixed(1)}%)
                  </span>
                  
                  <span class="info-label">Free:</span>
                  <span class="info-value">${this.formatBytes(this.memoryInfo.free)}</span>
                  
                  ${this.currentMemoryData ? D`
                    <span class="info-label">Available:</span>
                    <span class="info-value">${this.formatBytes(this.currentMemoryData.available)}</span>
                  ` : ""}
                </div>
              </div>
            ` : ""}
          </div>
        ` : D`
          <div class="loading">${L("common.loading")}</div>
        `}
        
        <div class="metrics-section">
          <div class="metrics-grid">
            <div class="metric-card">
              <div class="metric-header">
                <h3 class="metric-title">${L("dashboard.cpuUsage")}</h3>
                ${this.currentCpuData ? D`
                  <div>
                    <div class="metric-value">${this.currentCpuData.usage_percent.toFixed(1)}%</div>
                    <div class="metric-subtitle">
                      Load: ${this.currentCpuData.load1.toFixed(2)}
                    </div>
                  </div>
                ` : ""}
              </div>
              <div class="chart-container">
                <canvas id="cpuChart"></canvas>
              </div>
            </div>
            
            <div class="metric-card">
              <div class="metric-header">
                <h3 class="metric-title">${L("dashboard.memoryUsage")}</h3>
                ${this.currentMemoryData ? D`
                  <div>
                    <div class="metric-value">${this.currentMemoryData.used_percent.toFixed(1)}%</div>
                    <div class="metric-subtitle">
                      ${this.formatBytes(this.currentMemoryData.used)} / 
                      ${this.formatBytes(this.currentMemoryData.total)}
                    </div>
                  </div>
                ` : ""}
              </div>
              <div class="chart-container">
                <canvas id="memoryChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }
};
Ba.styles = re`
    :host {
      display: block;
      height: 100%;
      overflow-y: auto;
    }

    .dashboard {
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 300;
    }

    .system-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .info-card {
      background: var(--vscode-bg-light);
      border: 1px solid var(--vscode-border);
      border-radius: 8px;
      padding: 16px;
    }

    .info-card h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 500;
      color: var(--vscode-text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .info-grid {
      display: grid;
      grid-template-columns: max-content 1fr;
      gap: 8px 16px;
      font-size: 13px;
    }

    .info-label {
      color: var(--vscode-text-dim);
    }

    .info-value {
      color: var(--vscode-text);
      font-family: var(--vscode-font-family-mono);
    }

    .metrics-section {
      margin-bottom: 24px;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
    }

    .metric-card {
      background: var(--vscode-bg-light);
      border: 1px solid var(--vscode-border);
      border-radius: 8px;
      padding: 20px;
    }

    .metric-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .metric-title {
      font-size: 16px;
      font-weight: 500;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 300;
      color: var(--vscode-accent);
      font-family: var(--vscode-font-family-mono);
    }

    .metric-subtitle {
      font-size: 12px;
      color: var(--vscode-text-dim);
      margin-top: 4px;
    }

    .chart-container {
      height: 200px;
      position: relative;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--vscode-bg);
      border-radius: 4px;
      font-size: 13px;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--vscode-success);
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--vscode-text-dim);
    }

    .error {
      color: var(--vscode-error);
      padding: 16px;
      background: var(--vscode-bg-light);
      border-radius: 8px;
      margin-bottom: 16px;
    }
  `;
let Tt = Ba;
Hs([
  H({ type: Object })
], Tt.prototype, "systemSummary");
Hs([
  H({ type: Object })
], Tt.prototype, "cpuInfo");
Hs([
  H({ type: Object })
], Tt.prototype, "memoryInfo");
Hs([
  H({ type: Object })
], Tt.prototype, "currentCpuData");
Hs([
  H({ type: Object })
], Tt.prototype, "currentMemoryData");
Hs([
  H({ type: Boolean })
], Tt.prototype, "wsConnected");
Hs([
  H({ type: String })
], Tt.prototype, "wsError");
customElements.define("dashboard-tab", Tt);
var Db = Object.defineProperty, En = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Db(e, t, r), r;
};
const Na = class Na extends Fs {
  constructor() {
    super(...arguments), this.open = !1, this.title = "", this.size = "medium", this.showFooter = !0, this.handleKeydown = (e) => {
      e.key === "Escape" && this.open && this.close();
    };
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.handleKeydown);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("keydown", this.handleKeydown);
  }
  handleOverlayClick(e) {
    e.target === e.currentTarget && this.close();
  }
  close() {
    this.open = !1, this.dispatchEvent(new CustomEvent("modal-close", {
      bubbles: !0,
      composed: !0
    }));
  }
  render() {
    return this.open ? D`
      <div class="overlay" @click=${this.handleOverlayClick}>
        <div class="modal ${this.size}">
          <div class="modal-header">
            <h2 class="modal-title">${this.title}</h2>
            <button class="modal-close" @click=${this.close} aria-label="Close">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path d="M8 8.707l3.646 3.647.708-.707L8.707 8l3.647-3.646-.707-.708L8 7.293 4.354 3.646l-.707.708L7.293 8l-3.647 3.646.708.708L8 8.707z"/>
              </svg>
            </button>
          </div>
          <div class="modal-content">
            <slot></slot>
          </div>
          ${this.showFooter ? D`
            <div class="modal-footer">
              <slot name="footer">
                <button class="btn btn-secondary" @click=${this.close}>
                  ${L("common.close")}
                </button>
              </slot>
            </div>
          ` : ""}
        </div>
      </div>
    ` : D``;
  }
};
Na.styles = re`
    :host {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      overflow: auto;
    }

    :host([open]) {
      display: block;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      animation: fadeIn 0.2s ease-out;
    }

    .modal {
      position: relative;
      background-color: var(--vscode-bg-light);
      color: var(--vscode-text);
      margin: 40px auto;
      border: 1px solid var(--vscode-border);
      border-radius: 6px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.2s ease-out;
      max-height: calc(100vh - 80px);
      display: flex;
      flex-direction: column;
    }

    .modal.small {
      width: 90%;
      max-width: 400px;
    }

    .modal.medium {
      width: 90%;
      max-width: 600px;
    }

    .modal.large {
      width: 90%;
      max-width: 900px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--vscode-border);
      background-color: var(--vscode-bg-lighter);
    }

    .modal-title {
      margin: 0;
      font-size: 16px;
      font-weight: 500;
    }

    .modal-close {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: none;
      background: none;
      color: var(--vscode-text-dim);
      border-radius: 4px;
      transition: all 0.2s;
    }

    .modal-close:hover {
      background-color: var(--vscode-bg-light);
      color: var(--vscode-text);
    }

    .modal-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 16px 20px;
      border-top: 1px solid var(--vscode-border);
      background-color: var(--vscode-bg);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .modal {
        margin: 20px;
        width: calc(100% - 40px);
        max-width: none;
      }
    }
  `;
let Ms = Na;
En([
  H({ type: Boolean, reflect: !0 })
], Ms.prototype, "open");
En([
  H({ type: String })
], Ms.prototype, "title");
En([
  H({ type: String })
], Ms.prototype, "size");
En([
  H({ type: Boolean })
], Ms.prototype, "showFooter");
customElements.define("modal-dialog", Ms);
var $b = Object.defineProperty, Ee = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && $b(e, t, r), r;
};
const Fa = class Fa extends Fs {
  constructor() {
    super(), this.subRoute = null, this.activeTab = "interfaces", this.interfaces = [], this.bridges = [], this.bonds = [], this.vlans = [], this.showConfigureDrawer = !1, this.showBridgeDrawer = !1, this.bridgeFormData = {
      name: "",
      interfaces: ""
    }, this.showBondDrawer = !1, this.bondFormData = {
      name: "",
      mode: "balance-rr",
      interfaces: ""
    }, this.vlanFormData = {
      interface: "",
      vlanId: 0,
      name: ""
    }, this.showVLANDrawer = !1, this.searchQuery = "", this.bridgeSearchQuery = "", this.bondSearchQuery = "", this.vlanSearchQuery = "", this.configureNetworkInterface = null, this.configureFormData = {
      address: "",
      netmask: 24,
      gateway: ""
    }, this.showConfirmModal = !1, this.confirmAction = null, this.confirmTitle = "", this.confirmMessage = "", this.handlePopState = this.handlePopState.bind(this);
  }
  handlePopState() {
    const e = window.location.pathname.split("/"), t = e[e.length - 1];
    t && ["interfaces", "bridges", "bonds", "vlans"].includes(t) && (this.activeTab = t);
  }
  firstUpdated() {
    this.fetchNetworkData(), document.addEventListener("click", this.handleDocumentClick.bind(this)), document.addEventListener("keydown", this.handleKeyDown.bind(this)), window.addEventListener("popstate", this.handlePopState);
    const e = window.location.pathname.split("/"), t = e[e.length - 1];
    t && ["interfaces", "bridges", "bonds", "vlans"].includes(t) ? this.activeTab = t : this.handleSubRoute();
  }
  updated(e) {
    super.updated(e), e.has("subRoute") && this.handleSubRoute();
  }
  handleSubRoute() {
    this.subRoute && ["interfaces", "bridges", "bonds", "vlans"].includes(this.subRoute) ? this.activeTab = this.subRoute : this.activeTab = "interfaces";
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("click", this.handleDocumentClick.bind(this)), document.removeEventListener("keydown", this.handleKeyDown.bind(this)), window.removeEventListener("popstate", this.handlePopState);
  }
  handleDocumentClick(e) {
    e.target.closest(".action-menu") || this.closeAllMenus();
  }
  handleKeyDown(e) {
    e.key === "Escape" && (this.closeAllMenus(), this.showConfigureDrawer && this.closeConfigureDrawer(), this.showBridgeDrawer && this.closeBridgeDrawer(), this.showBondDrawer && this.closeBondDrawer(), this.showVLANDrawer && this.closeVLANDrawer(), this.showConfirmModal && this.handleCancel());
  }
  toggleActionMenu(e, t) {
    var r;
    e.stopPropagation();
    const i = (r = this.shadowRoot) == null ? void 0 : r.getElementById(t);
    if (i) {
      const n = i.classList.contains("show");
      if (this.closeAllMenus(), !n) {
        i.classList.add("show");
        const o = i.querySelector("button");
        o && setTimeout(() => o.focus(), 10);
      }
    }
  }
  closeAllMenus() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelectorAll(".action-dropdown");
    e == null || e.forEach((i) => i.classList.remove("show"));
  }
  async fetchNetworkData() {
    this.fetchInterfaces(), this.fetchBridges(), this.fetchBonds(), this.fetchVlans();
  }
  async fetchInterfaces() {
    try {
      const e = await J.get("/network/interfaces");
      this.interfaces = e.interfaces || [];
    } catch (e) {
      console.error("Error fetching network interfaces:", e);
    }
  }
  async fetchBridges() {
    try {
      const e = await J.get("/network/bridges");
      this.bridges = e.bridges || [];
    } catch (e) {
      console.error("Error fetching bridges:", e);
    }
  }
  async fetchBonds() {
    try {
      const e = await J.get("/network/bonds");
      this.bonds = e.bonds || [];
    } catch (e) {
      console.error("Error fetching bonds:", e);
    }
  }
  async fetchVlans() {
    try {
      const e = await J.get("/network/vlans");
      this.vlans = e.vlans || [];
    } catch (e) {
      console.error("Error fetching VLANs:", e);
    }
  }
  toggleInterfaceState(e) {
    const t = e.state === "up", i = L(t ? "network.downInterface" : "network.upInterface"), r = L(t ? "network.confirmBringDown" : "network.confirmBringUp", { name: e.name });
    this.showConfirmDialog(
      i,
      r,
      async () => {
        const n = `/network/interfaces/${e.name}/${e.state === "up" ? "down" : "up"}`;
        try {
          await J.put(n), this.fetchInterfaces();
        } catch (o) {
          console.error(`Error bringing interface ${t ? "down" : "up"}:`, o);
        }
      }
    );
  }
  async deleteBridge(e) {
    this.showConfirmDialog(
      L("network.deleteBridge"),
      L("network.confirmDeleteBridge", { name: e }),
      async () => {
        try {
          await J.delete(`/network/bridge/${e}`), await this.fetchBridges();
        } catch (t) {
          console.error("Error deleting bridge:", t);
        }
      }
    );
  }
  async deleteBond(e) {
    this.showConfirmDialog(
      L("network.deleteBond"),
      L("network.confirmDeleteBond", { name: e }),
      async () => {
        try {
          await J.delete(`/network/bond/${e}`), await this.fetchBonds();
        } catch (t) {
          console.error("Error deleting bond:", t);
        }
      }
    );
  }
  async deleteVlan(e) {
    this.showConfirmDialog(
      L("network.deleteVlan"),
      L("network.confirmDeleteVlan", { name: e }),
      async () => {
        try {
          await J.delete(`/network/vlan/${e}`), await this.fetchVlans();
        } catch (t) {
          console.error("Error deleting VLAN:", t);
        }
      }
    );
  }
  showConfirmDialog(e, t, i) {
    this.confirmTitle = e, this.confirmMessage = t, this.confirmAction = i, this.showConfirmModal = !0, this.updateComplete.then(() => {
      var n;
      const r = (n = this.shadowRoot) == null ? void 0 : n.querySelector("modal-dialog button.btn-secondary");
      r && setTimeout(() => r.focus(), 50);
    });
  }
  handleConfirm() {
    this.confirmAction && this.confirmAction(), this.showConfirmModal = !1, this.confirmAction = null;
  }
  handleCancel() {
    this.showConfirmModal = !1, this.confirmAction = null;
  }
  openVLANDrawer() {
    this.showVLANDrawer = !0, this.vlanFormData = {
      interface: "",
      vlanId: 0,
      name: ""
    };
  }
  closeVLANDrawer() {
    this.showVLANDrawer = !1, this.vlanFormData = {
      interface: "",
      vlanId: 0,
      name: ""
    };
  }
  handleConfigureAddress(e) {
    this.configureNetworkInterface = e, this.configureFormData = {
      address: "",
      netmask: 24,
      gateway: ""
    }, this.showConfigureDrawer = !0;
  }
  async submitConfigureAddress() {
    if (!this.configureNetworkInterface || !this.configureFormData.address)
      return;
    const e = {
      address: this.configureFormData.address,
      netmask: this.configureFormData.netmask,
      gateway: this.configureFormData.gateway || void 0
    };
    try {
      await J.post(`/network/interfaces/${this.configureNetworkInterface.name}/address`, e), this.showConfigureDrawer = !1, this.configureNetworkInterface = null, await this.fetchInterfaces();
    } catch (t) {
      console.error("Error configuring address:", t);
    }
  }
  closeConfigureDrawer() {
    this.showConfigureDrawer = !1, this.configureNetworkInterface = null, this.configureFormData = {
      address: "",
      netmask: 24,
      gateway: ""
    };
  }
  openBridgeDrawer() {
    this.showBridgeDrawer = !0, this.bridgeFormData = {
      name: "",
      interfaces: ""
    };
  }
  closeBridgeDrawer() {
    this.showBridgeDrawer = !1, this.bridgeFormData = {
      name: "",
      interfaces: ""
    };
  }
  openBondDrawer() {
    this.showBondDrawer = !0, this.bondFormData = {
      name: "",
      mode: "balance-rr",
      interfaces: ""
    };
  }
  closeBondDrawer() {
    this.showBondDrawer = !1, this.bondFormData = {
      name: "",
      mode: "balance-rr",
      interfaces: ""
    };
  }
  async handleCreateBridge() {
    if (!this.bridgeFormData.name || !this.bridgeFormData.interfaces)
      return;
    const e = {
      name: this.bridgeFormData.name,
      interfaces: this.bridgeFormData.interfaces.split(",").map((t) => t.trim()).filter(Boolean)
    };
    try {
      await J.post("/network/bridge", e), this.closeBridgeDrawer(), await this.fetchBridges(), await this.fetchInterfaces();
    } catch (t) {
      console.error("Error creating bridge:", t);
    }
  }
  async handleCreateBond() {
    if (!this.bondFormData.name || !this.bondFormData.mode || !this.bondFormData.interfaces)
      return;
    const e = {
      name: this.bondFormData.name,
      mode: this.bondFormData.mode,
      interfaces: this.bondFormData.interfaces.split(",").map((t) => t.trim()).filter(Boolean)
    };
    try {
      await J.post("/network/bond", e), this.closeBondDrawer(), await this.fetchBonds(), await this.fetchInterfaces();
    } catch (t) {
      console.error("Error creating bond:", t);
    }
  }
  async handleCreateVLANInterface() {
    if (!this.vlanFormData.interface || this.vlanFormData.vlanId <= 0)
      return;
    const e = {
      interface: this.vlanFormData.interface,
      vlan_id: this.vlanFormData.vlanId,
      name: this.vlanFormData.name || `${this.vlanFormData.interface}.${this.vlanFormData.vlanId}`
    };
    try {
      await J.post("/network/vlan", e), this.closeVLANDrawer(), this.fetchVlans(), this.fetchInterfaces();
    } catch (t) {
      console.error("Error creating VLAN:", t);
    }
  }
  renderInterface(e) {
    return D`
      <div class="network-interface">
        <div class="interface-header">
          <span class="interface-name">
            ${e.name}
          </span>
          <span class="interface-state ${e.state === "up" ? "state-up" : "state-down"}">
            ${e.state}
          </span>
        </div>
        <div class="interface-details">
          <div class="detail-item">
            <span class="detail-label">${L("network.rxBytes")}</span>
            <span class="detail-value">${e.statistics.rx_bytes}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">${L("network.txBytes")}</span>
            <span class="detail-value">${e.statistics.tx_bytes}</span>
          </div>
        </div>
        <div class="interface-actions">
          <button class="action-button primary" @click="${() => this.toggleInterfaceState(e)}">
            ${L(e.state === "up" ? "network.bringDown" : "network.bringUp")}
          </button>
          <button class="action-button" @click="${() => this.handleConfigureAddress(e)}">
            ${L("network.configure")}
          </button>
        </div>
      </div>
    `;
  }
  getPageTitle() {
    switch (this.activeTab) {
      case "interfaces":
        return L("network.interfaces");
      case "bridges":
        return L("network.bridges");
      case "bonds":
        return L("network.bonds");
      case "vlans":
        return L("network.vlans");
      default:
        return L("network.title");
    }
  }
  render() {
    return D`
      <div class="tab-container">
        <h1>${this.getPageTitle()}</h1>
        <div class="tab-content">
          ${this.activeTab === "interfaces" ? D`
            <div class="interface-search" style="display: flex; justify-content: flex-start; margin-bottom: 12px;">
              <div class="search-container">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input 
                  class="form-input search-input"
                  type="text"
                  placeholder="${L("network.searchInterfaces")}"
                  .value=${this.searchQuery}
                  @input=${(e) => this.searchQuery = e.target.value}
                />
              </div>
            </div>
${this.interfaces.length > 0 ? D`
              <table class="network-table">
                <thead>
                  <tr>
                    <th>${L("common.name")}</th>
                    <th>${L("common.state")}</th>
                    <th>${L("network.rxBytes")}</th>
                    <th>${L("network.txBytes")}</th>
                    <th>${L("common.actions")}</th>
                  </tr>
                </thead>
                <tbody>
                  ${this.interfaces.filter((e) => e.name.toLowerCase().includes(this.searchQuery.toLowerCase())).map((e, t) => D`
                    <tr>
                      <td>${e.name}</td>
                      <td>
                        <div class="status-indicator">
                          <span class="status-icon ${e.state === "up" ? "up" : "down"}" data-tooltip="${e.state === "up" ? "Up" : "Down"}"></span>
                        </div>
                      </td>
                      <td>${e.statistics.rx_bytes}</td>
                      <td>${e.statistics.tx_bytes}</td>
                      <td>
                        <div class="action-menu">
                          <button class="action-dots" @click=${(i) => this.toggleActionMenu(i, `interface-${t}`)}></button>
                          <div class="action-dropdown" id="interface-${t}">
                            <button @click=${() => {
      this.closeAllMenus(), this.toggleInterfaceState(e);
    }}>
                              ${e.state === "up" ? "Down" : "Up"}
                            </button>
                            <button @click=${() => {
      this.closeAllMenus(), this.handleConfigureAddress(e);
    }}>
                              ${L("network.configure")}
                            </button>
                          </div>
                        </div>
                      </td>
                    </tr>
                  `)}
                </tbody>
              </table>
            ` : D`<div class="empty-state">${L("network.noInterfaces")}</div>`}
          ` : ""}

          ${this.activeTab === "bridges" ? D`
            <div class="interface-search" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <div class="search-container">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input 
                  class="form-input search-input"
                  type="text"
                  placeholder="${L("network.searchBridges")}"
                  .value=${this.bridgeSearchQuery}
                  @input=${(e) => this.bridgeSearchQuery = e.target.value}
                />
              </div>
              <button class="action-button primary" @click="${this.openBridgeDrawer}">
                ${L("network.createBridge")}
              </button>
            </div>
            
            ${this.bridges.length > 0 ? D`
              <table class="network-table">
                <thead>
                  <tr>
                    <th>${L("common.name")}</th>
                    <th>${L("common.state")}</th>
                    <th>${L("common.actions")}</th>
                  </tr>
                </thead>
                <tbody>
                  ${this.bridges.filter((e) => e.name.toLowerCase().includes(this.bridgeSearchQuery.toLowerCase())).map((e, t) => D`
                    <tr>
                      <td>${e.name}</td>
                      <td>
                        <div class="status-indicator">
                          <span class="status-icon ${e.state === "up" ? "up" : "down"}" data-tooltip="${e.state === "up" ? "Up" : "Down"}"></span>
                        </div>
                      </td>
                      <td>
                        <div class="action-menu">
                          <button class="action-dots" @click=${(i) => this.toggleActionMenu(i, `bridge-${t}`)}>${""}</button>
                          <div class="action-dropdown" id="bridge-${t}">
                            <button class="danger" @click=${() => {
      this.closeAllMenus(), this.deleteBridge(e.name);
    }}>
                              ${L("common.delete")}
                            </button>
                          </div>
                        </div>
                      </td>
                    </tr>
                  `)}
                </tbody>
              </table>
            ` : D`<div class="empty-state">${L("network.noBridges")}</div>`}
          ` : ""}

          ${this.activeTab === "bonds" ? D`
            <div class="interface-search" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <div class="search-container">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input 
                  class="form-input search-input"
                  type="text"
                  placeholder="${L("network.searchBonds")}"
                  .value=${this.bondSearchQuery}
                  @input=${(e) => this.bondSearchQuery = e.target.value}
                />
              </div>
              <button class="action-button primary" @click="${this.openBondDrawer}">
                ${L("network.createBond")}
              </button>
            </div>
            
            ${this.bonds.length > 0 ? D`
              <table class="network-table">
                <thead>
                  <tr>
                    <th>${L("common.name")}</th>
                    <th>${L("common.state")}</th>
                    <th>${L("network.mode")}</th>
                    <th>${L("common.actions")}</th>
                  </tr>
                </thead>
                <tbody>
                  ${this.bonds.filter((e) => e.name.toLowerCase().includes(this.bondSearchQuery.toLowerCase())).map((e, t) => D`
                    <tr>
                      <td>${e.name}</td>
                      <td>
                        <div class="status-indicator">
                          <span class="status-icon ${e.state === "up" ? "up" : "down"}" data-tooltip="${e.state === "up" ? "Up" : "Down"}"></span>
                        </div>
                      </td>
                      <td>${e.mode || "N/A"}</td>
                      <td>
                        <div class="action-menu">
                          <button class="action-dots" @click=${(i) => this.toggleActionMenu(i, `bond-${t}`)}>${""}</button>
                          <div class="action-dropdown" id="bond-${t}">
                            <button class="danger" @click=${() => {
      this.closeAllMenus(), this.deleteBond(e.name);
    }}>
                              ${L("common.delete")}
                            </button>
                          </div>
                        </div>
                      </td>
                    </tr>
                  `)}
                </tbody>
              </table>
            ` : D`<div class="empty-state">${L("network.noBonds")}</div>`}
          ` : ""}

          ${this.activeTab === "vlans" ? D`
            <div class="interface-search" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <div class="search-container">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input 
                  class="form-input search-input"
                  type="text"
                  placeholder="${L("network.searchVLANs")}"
                  .value=${this.vlanSearchQuery}
                  @input=${(e) => this.vlanSearchQuery = e.target.value}
                />
              </div>
              <button class="action-button primary" @click="${this.openVLANDrawer}">
                ${L("network.createVLAN")}
              </button>
            </div>
            
            ${this.vlans.length > 0 ? D`
              <table class="network-table">
                <thead>
                  <tr>
                    <th>${L("common.name")}</th>
                    <th>${L("common.state")}</th>
                    <th>${L("common.actions")}</th>
                  </tr>
                </thead>
                <tbody>
                  ${this.vlans.filter((e) => e.name.toLowerCase().includes(this.vlanSearchQuery.toLowerCase())).map((e, t) => D`
                    <tr>
                      <td>${e.name}</td>
                      <td>
                        <div class="status-indicator">
                          <span class="status-icon ${e.state === "up" ? "up" : "down"}" data-tooltip="${e.state === "up" ? "Up" : "Down"}"></span>
                        </div>
                      </td>
                      <td>
                        <div class="action-menu">
                          <button class="action-dots" @click=${(i) => this.toggleActionMenu(i, `vlan-${t}`)}>${""}</button>
                          <div class="action-dropdown" id="vlan-${t}">
                            <button class="danger" @click=${() => {
      this.closeAllMenus(), this.deleteVlan(e.name);
    }}>
                              ${L("common.delete")}
                            </button>
                          </div>
                        </div>
                      </td>
                    </tr>
                  `)}
                </tbody>
              </table>
            ` : D`<div class="empty-state">${L("network.noVLANs")}</div>`}
          ` : ""}
        </div>
      </div>

      <modal-dialog
        ?open=${this.showConfirmModal}
        .title=${this.confirmTitle}
        size="small"
        @modal-close=${this.handleCancel}
      >
        <p>${this.confirmMessage}</p>
        <div slot="footer" style="display: flex; gap: 8px; justify-content: flex-end;">
          <button class="action-button" @click=${this.handleCancel}>
            ${L("common.cancel")}
          </button>
          <button class="action-button primary" @click=${this.handleConfirm}>
            ${L("common.confirm")}
          </button>
        </div>
      </modal-dialog>

      ${this.showConfigureDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click="${() => this.closeConfigureDrawer()}"></button>
          <div class="drawer-content">
            <h2>${L("network.configureInterface")}</h2>
            ${this.configureNetworkInterface ? D`
              <form @submit=${(e) => {
      e.preventDefault(), this.submitConfigureAddress();
    }}>
                <div class="detail-item" style="margin-bottom: 16px;">
                  <span class="detail-label">${L("network.interfaceName")}</span>
                  <span class="detail-value">${this.configureNetworkInterface.name}</span>
                </div>
                <div class="detail-item" style="margin-bottom: 16px;">
                  <span class="detail-label">${L("network.currentState")}</span>
                  <span class="detail-value">${this.configureNetworkInterface.state}</span>
                </div>
                
                <div class="form-group">
                  <label class="form-label" for="address">${L("network.ipAddressRequired")}</label>
                  <input 
                    id="address"
                    class="form-input" 
                    type="text" 
                    placeholder="192.168.1.100"
                    .value=${this.configureFormData.address}
                    @input=${(e) => this.configureFormData.address = e.target.value}
                    required
                  />
                </div>
                
                <div class="form-group">
                  <label class="form-label" for="netmask">${L("network.netmaskCidrRequired")}</label>
                  <input 
                    id="netmask"
                    class="form-input" 
                    type="number" 
                    min="0" 
                    max="32" 
                    placeholder="24"
                    .value=${this.configureFormData.netmask}
                    @input=${(e) => this.configureFormData.netmask = parseInt(e.target.value) || 24}
                    required
                  />
                </div>
                
                <div class="form-group">
                  <label class="form-label" for="gateway">${L("network.gatewayOptional")}</label>
                  <input 
                    id="gateway"
                    class="form-input" 
                    type="text" 
                    placeholder="192.168.1.1"
                    .value=${this.configureFormData.gateway}
                    @input=${(e) => this.configureFormData.gateway = e.target.value}
                  />
                </div>
                
                <div class="form-actions">
                  <button type="button" class="action-button" @click="${() => this.closeConfigureDrawer()}">
                    ${L("common.cancel")}
                  </button>
                  <button type="submit" class="action-button primary">
                    ${L("network.applyConfiguration")}
                  </button>
                </div>
              </form>
            ` : null}
          </div>
        </div>
      ` : null}

      ${this.showBridgeDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click="${() => this.closeBridgeDrawer()}"></button>
          <div class="drawer-content">
            <h2>${L("network.createBridgeTitle")}</h2>
            <form @submit=${(e) => {
      e.preventDefault(), this.handleCreateBridge();
    }}>
              <div class="form-group">
                <label class="form-label" for="bridge-name">${L("network.bridgeNameRequired")}</label>
                <input 
                  id="bridge-name"
                  class="form-input" 
                  type="text" 
                  placeholder="br0"
                  .value=${this.bridgeFormData.name}
                  @input=${(e) => this.bridgeFormData.name = e.target.value}
                  required
                />
              </div>
              
              <div class="form-group">
                <label class="form-label" for="bridge-interfaces">${L("network.interfacesRequired")}</label>
                <input 
                  id="bridge-interfaces"
                  class="form-input" 
                  type="text" 
                  placeholder="eth0, eth1"
                  .value=${this.bridgeFormData.interfaces}
                  @input=${(e) => this.bridgeFormData.interfaces = e.target.value}
                  required
                />
                <small style="display: block; margin-top: 0.25rem; color: var(--text-secondary); font-size: 0.75rem;">
                  ${L("network.commaSeparatedInterfaces")}
                </small>
              </div>
              
              <div class="form-actions">
                <button type="button" class="action-button" @click="${() => this.closeBridgeDrawer()}">
                  ${L("common.cancel")}
                </button>
                <button type="submit" class="action-button primary">
                  ${L("network.createBridge")}
                </button>
              </div>
            </form>
          </div>
        </div>
      ` : null}

      ${this.showBondDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click="${() => this.closeBondDrawer()}"></button>
          <div class="drawer-content">
            <h2>${L("network.createBondTitle")}</h2>
            <form @submit=${(e) => {
      e.preventDefault(), this.handleCreateBond();
    }}>
              <div class="form-group">
                <label class="form-label" for="bond-name">${L("network.bondNameRequired")}</label>
                <input 
                  id="bond-name"
                  class="form-input" 
                  type="text" 
                  placeholder="bond0"
                  .value=${this.bondFormData.name}
                  @input=${(e) => this.bondFormData.name = e.target.value}
                  required
                />
              </div>
              
              <div class="form-group">
                <label class="form-label" for="bond-mode">${L("network.modeRequired")}</label>
                <select 
                  id="bond-mode"
                  class="form-select" 
                  .value=${this.bondFormData.mode}
                  @input=${(e) => this.bondFormData.mode = e.target.value}
                  required
                >
                  <option value="balance-rr">balance-rr (Round-robin)</option>
                  <option value="active-backup">active-backup</option>
                  <option value="balance-xor">balance-xor</option>
                  <option value="broadcast">broadcast</option>
                  <option value="802.3ad">802.3ad (LACP)</option>
                  <option value="balance-tlb">balance-tlb</option>
                  <option value="balance-alb">balance-alb</option>
                </select>
              </div>
              
              <div class="form-group">
                <label class="form-label" for="bond-interfaces">${L("network.interfacesRequired")}</label>
                <input 
                  id="bond-interfaces"
                  class="form-input" 
                  type="text" 
                  placeholder="eth2, eth3"
                  .value=${this.bondFormData.interfaces}
                  @input=${(e) => this.bondFormData.interfaces = e.target.value}
                  required
                />
                <small style="display: block; margin-top: 0.25rem; color: var(--text-secondary); font-size: 0.75rem;">
                  ${L("network.commaSeparatedInterfaces")}
                </small>
              </div>
              
              <div class="form-actions">
                <button type="button" class="action-button" @click="${() => this.closeBondDrawer()}">
                  ${L("common.cancel")}
                </button>
                <button type="submit" class="action-button primary">
                  ${L("network.createBond")}
                </button>
              </div>
            </form>
          </div>
        </div>
      ` : null}

      ${this.showVLANDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click="${() => this.closeVLANDrawer()}"></button>
          <div class="drawer-content">
            <h2>${L("network.createVlanTitle")}</h2>
            <form @submit=${(e) => {
      e.preventDefault(), this.handleCreateVLANInterface();
    }}>
              <div class="form-group">
                <label class="form-label" for="vlan-interface">${L("network.baseInterfaceRequired")}</label>
                <input 
                  id="vlan-interface"
                  class="form-input" 
                  type="text" 
                  placeholder="eth0"
                  .value=${this.vlanFormData.interface}
                  @input=${(e) => this.vlanFormData.interface = e.target.value}
                  required
                />
              </div>
              
              <div class="form-group">
                <label class="form-label" for="vlan-id">${L("network.vlanIdRequired")}</label>
                <input 
                  id="vlan-id"
                  class="form-input" 
                  type="number"
                  min="1"
                  max="4094"
                  placeholder="100"
                  .value=${this.vlanFormData.vlanId}
                  @input=${(e) => this.vlanFormData.vlanId = parseInt(e.target.value) || 0}
                  required
                />
              </div>

              <div class="form-group">
                <label class="form-label" for="vlan-name">${L("network.vlanNameOptional")}</label>
                <input 
                  id="vlan-name"
                  class="form-input" 
                  type="text"
                  placeholder="eth0.100"
                  .value=${this.vlanFormData.name}
                  @input=${(e) => this.vlanFormData.name = e.target.value}
                />
                <small style="display: block; margin-top: 0.25rem; color: var(--text-secondary); font-size: 0.75rem;">
                  ${L("network.vlanNameDefault")}
                </small>
              </div>

              <div class="form-actions">
                <button type="button" class="action-button" @click="${() => this.closeVLANDrawer()}">
                  ${L("common.cancel")}
                </button>
                <button type="submit" class="action-button primary">
                  ${L("network.createVLAN")}
                </button>
              </div>
            </form>
          </div>
        </div>
      ` : null}
    `;
  }
};
Fa.styles = re`
    :host {
      display: block;
      padding: 16px;
    }

    .tab-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .tab-header {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.2s;
    }

    .tab-button:hover {
      color: var(--text-primary);
    }

    .tab-button.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .tab-content {
      flex: 1;
      overflow-y: auto;
    }

    .network-interface {
      background-color: var(--surface-1);
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 12px;
      border: 1px solid var(--border-color);
    }

    .interface-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .interface-name {
      font-size: 1.1rem;
      font-weight: 500;
    }

    .interface-state {
      padding: 0.25rem 0.75rem;
      border-radius: 16px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .state-up {
      background-color: var(--success-bg);
      color: var(--success);
    }

    .state-down {
      background-color: var(--error-bg);
      color: var(--error);
    }

    .interface-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
    }

    .detail-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }

    .detail-value {
      font-size: 0.875rem;
      color: var(--text-primary);
    }

    .interface-actions {
      display: flex;
      gap: 0.5rem;
    }

    .action-button {
      padding: 0.5rem 1rem;
      background-color: var(--surface-2);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    .action-button:hover {
      background-color: var(--surface-3);
      border-color: var(--primary);
    }

    .action-button.primary {
      background-color: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .action-button.primary:hover {
      background-color: var(--primary-hover);
    }

    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .create-form {
      background-color: var(--surface-1);
      padding: 1.5rem;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      margin-bottom: 1rem;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-primary);
    }

    .form-input,
    .form-select {
      width: 100%;
      padding: 0.5rem;
      background-color: var(--surface-0);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 0.875rem;
      box-sizing: border-box;
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 1.5rem;
    }

    h1 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 300;
    }

    h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: var(--text-primary);
    }

    h3 {
      font-size: 1.2rem;
      margin: 1.5rem 0 1rem 0;
      color: var(--text-primary);
    }

    .network-table {
      width: 100%;
      border-collapse: collapse;
      background-color: var(--surface-1);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .network-table thead {
      background-color: var(--surface-2);
    }

    .network-table th {
      text-align: left;
      padding: 12px 16px;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    .network-table td {
      padding: 12px 16px;
      font-size: 0.875rem;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
    }

    .network-table tbody tr:last-child td {
      border-bottom: none;
    }

    .network-table tbody tr:hover {
      background-color: var(--surface-0);
    }

    .network-table td.state-up,
    .network-table td.state-down {
      font-weight: 500;
    }

    .network-table td:last-child {
      text-align: right;
    }

    .network-table td button {
      margin-right: 0.5rem;
    }

    .network-table td button:last-child {
      margin-right: 0;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .status-icon {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      position: relative;
    }

    .status-icon.up {
      background-color: #4caf50;
      box-shadow: 0 0 4px #4caf50;
    }

    .status-icon.down {
      background-color: #9e9e9e;
    }

    .status-icon[data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      padding: 6px 12px;
      background-color: var(--surface-1);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 14px;
      white-space: nowrap;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .action-menu {
      position: relative;
      display: inline-block;
    }

    .action-dots {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      color: var(--text-secondary);
      font-size: 18px;
      line-height: 1;
      transition: background-color 0.2s;
      border-radius: 4px;
    }

    .action-dots:hover {
      background-color: var(--vscode-toolbar-hoverBackground, var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.1)));
    }

    .action-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background-color: var(--surface-1);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      min-width: 150px;
      display: none;
    }

    .action-dropdown.show {
      display: block;
    }

    .action-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 16px;
      border: none;
      background: none;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .action-dropdown button:hover {
      background-color: var(--vscode-list-hoverBackground, rgba(255, 255, 255, 0.08));
    }

    .action-dropdown button.danger {
      color: var(--vscode-error, #f44336);
    }
    .drawer {
      position: fixed;
      top: 0;
      right: 0;
      width: 400px;
      max-width: 90%;
      height: 100%;
      background: var(--vscode-bg-light);
      border-left: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      overflow-y: auto;
      padding: 24px;
      animation: slideIn 0.3s ease-out;
    }

    @media (max-width: 768px) {
      .drawer {
        width: 100%;
        max-width: 100%;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
      }
      to {
        transform: translateX(0);
      }
    }

    .drawer h2 {
      margin-top: 0;
    }

    .drawer button.close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      background: var(--vscode-toolbar-hoverBackground, rgba(90, 93, 94, 0.1));
      color: var(--vscode-foreground, var(--vscode-editor-foreground));
      border: 1px solid var(--vscode-widget-border, rgba(0, 0, 0, 0.1));
      transition: all 0.2s;
    }

    .drawer button.close-btn:hover {
      background: var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.2));
      border-color: var(--vscode-widget-border, rgba(0, 0, 0, 0.2));
    }

    .drawer-content {
      margin-top: 40px;
    }

    .search-container {
      position: relative;
      display: inline-block;
      width: 200px;
    }

    .search-icon {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      pointer-events: none;
      opacity: 0.5;
    }

    .search-input {
      padding-left: 35px !important;
      width: 100%;
    }
  `;
let ve = Fa;
Ee([
  H({ type: String })
], ve.prototype, "subRoute");
Ee([
  B()
], ve.prototype, "activeTab");
Ee([
  B()
], ve.prototype, "interfaces");
Ee([
  B()
], ve.prototype, "bridges");
Ee([
  B()
], ve.prototype, "bonds");
Ee([
  B()
], ve.prototype, "vlans");
Ee([
  B()
], ve.prototype, "showConfigureDrawer");
Ee([
  B()
], ve.prototype, "showBridgeDrawer");
Ee([
  B()
], ve.prototype, "bridgeFormData");
Ee([
  B()
], ve.prototype, "showBondDrawer");
Ee([
  B()
], ve.prototype, "bondFormData");
Ee([
  B()
], ve.prototype, "vlanFormData");
Ee([
  B()
], ve.prototype, "showVLANDrawer");
Ee([
  B()
], ve.prototype, "searchQuery");
Ee([
  B()
], ve.prototype, "bridgeSearchQuery");
Ee([
  B()
], ve.prototype, "bondSearchQuery");
Ee([
  B()
], ve.prototype, "vlanSearchQuery");
Ee([
  B()
], ve.prototype, "configureNetworkInterface");
Ee([
  B()
], ve.prototype, "configureFormData");
Ee([
  B()
], ve.prototype, "showConfirmModal");
Ee([
  B()
], ve.prototype, "confirmAction");
Ee([
  B()
], ve.prototype, "confirmTitle");
Ee([
  B()
], ve.prototype, "confirmMessage");
customElements.define("network-tab", ve);
var Ab = Object.defineProperty, lt = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Ab(e, t, r), r;
};
const za = class za extends Fs {
  constructor() {
    super(...arguments), this.disks = [], this.volumeGroups = [], this.logicalVolumes = [], this.physicalVolumes = [], this.raidDevices = [], this.availableRaidDisks = [], this.iscsiTargets = [], this.iscsiSessions = [], this.multipathDevices = [], this.btrfsSubvolumes = [], this.activeSection = "disks", this.subRoute = null, this.loading = !1, this.error = "";
  }
  static get properties() {
    return {
      subRoute: { type: String, attribute: "sub-route" }
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.handlePopState = this.handlePopState.bind(this), window.addEventListener("popstate", this.handlePopState), this.updateActiveSection(), this.loadData();
  }
  updated(e) {
    e.has("subRoute") && (this.updateActiveSection(), this.loadData());
  }
  updateActiveSection() {
    if (this.subRoute && ["disks", "lvm", "raid", "iscsi", "multipath", "btrfs"].includes(this.subRoute)) {
      this.activeSection = this.subRoute;
      return;
    }
    const e = window.location.pathname.split("/"), t = e[e.length - 1];
    t && ["disks", "lvm", "raid", "iscsi", "multipath", "btrfs"].includes(t) && (this.activeSection = t);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("popstate", this.handlePopState);
  }
  handlePopState() {
    const e = window.location.pathname.split("/"), t = e[e.length - 1];
    t && ["disks", "lvm", "raid", "iscsi", "multipath", "btrfs"].includes(t) && (this.activeSection = t, this.loadData());
  }
  async loadData() {
    this.loading = !0, this.error = "";
    try {
      switch (this.activeSection) {
        case "disks":
          await this.fetchDisks();
          break;
        case "lvm":
          await this.fetchLVM();
          break;
        case "raid":
          await this.fetchRAID();
          break;
        case "iscsi":
          await this.fetchiSCSI();
          break;
        case "multipath":
          await this.fetchMultipath();
          break;
        case "btrfs":
          await this.fetchBTRFS();
          break;
      }
    } catch (e) {
      const t = (e == null ? void 0 : e.message) || "Failed to load data", i = (e == null ? void 0 : e.details) || "";
      this.error = i ? `${t}: ${i}` : t, console.error("Storage tab error:", e);
    } finally {
      this.loading = !1;
    }
  }
  async fetchDisks() {
    try {
      const e = await J.get("/storage/disks");
      this.disks = (e == null ? void 0 : e.disks) || [];
    } catch (e) {
      throw console.error("Error fetching disks:", e), this.disks = [], e;
    }
  }
  async fetchLVM() {
    try {
      const [e, t, i] = await Promise.all([
        J.get("/storage/lvm/vgs"),
        J.get("/storage/lvm/lvs"),
        J.get("/storage/lvm/pvs")
      ]);
      this.volumeGroups = (e == null ? void 0 : e.volume_groups) || [], this.logicalVolumes = (t == null ? void 0 : t.logical_volumes) || [], this.physicalVolumes = (i == null ? void 0 : i.physical_volumes) || [];
    } catch (e) {
      throw console.error("Error fetching LVM data:", e), this.volumeGroups = [], this.logicalVolumes = [], this.physicalVolumes = [], e;
    }
  }
  async fetchRAID() {
    try {
      const [e, t] = await Promise.all([
        J.get("/storage/raid/devices"),
        J.get("/storage/raid/available-disks")
      ]);
      this.raidDevices = (e == null ? void 0 : e.devices) || [], this.availableRaidDisks = (t == null ? void 0 : t.disks) || [];
    } catch (e) {
      throw console.error("Error fetching RAID data:", e), this.raidDevices = [], this.availableRaidDisks = [], e;
    }
  }
  async fetchiSCSI() {
    try {
      const e = await J.get("/storage/iscsi/sessions");
      this.iscsiSessions = (e == null ? void 0 : e.sessions) || [];
    } catch (e) {
      throw console.error("Error fetching iSCSI data:", e), this.iscsiSessions = [], e;
    }
  }
  async fetchMultipath() {
    try {
      const e = await J.get("/storage/multipath/devices");
      this.multipathDevices = (e == null ? void 0 : e.devices) || [];
    } catch (e) {
      throw console.error("Error fetching multipath data:", e), this.multipathDevices = [], e;
    }
  }
  async fetchBTRFS() {
    this.btrfsSubvolumes = [];
  }
  formatBytes(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, i = ["Bytes", "KB", "MB", "GB", "TB"], r = Math.floor(Math.log(e) / Math.log(t));
    return parseFloat((e / Math.pow(t, r)).toFixed(2)) + " " + i[r];
  }
  renderDisksSection() {
    return this.disks.length === 0 ? D`<div class="empty-state">${L("storage.disks.empty")}</div>` : D`
      ${this.disks.map((e) => D`
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">${e.name} - ${e.model || "Unknown Model"}</h3>
            <span>${this.formatBytes(e.size)}</span>
          </div>
          <div class="info-grid">
            <div class="info-item">
              <span class="info-label">${L("storage.disks.type")}</span>
              <span class="info-value">${e.type}</span>
            </div>
            <div class="info-item">
              <span class="info-label">${L("storage.disks.serial")}</span>
              <span class="info-value">${e.serial || "N/A"}</span>
            </div>
            <div class="info-item">
              <span class="info-label">${L("storage.disks.removable")}</span>
              <span class="info-value">${e.removable ? L("common.yes") : L("common.no")}</span>
            </div>
          </div>
          
          ${e.partitions && e.partitions.length > 0 ? D`
            <h4>${L("storage.disks.partitions")}</h4>
            <table class="table">
              <thead>
                <tr>
                  <th>${L("storage.disks.partition")}</th>
                  <th>${L("storage.disks.filesystem")}</th>
                  <th>${L("storage.disks.size")}</th>
                  <th>${L("storage.disks.used")}</th>
                  <th>${L("storage.disks.mountpoint")}</th>
                  <th>${L("common.actions")}</th>
                </tr>
              </thead>
              <tbody>
                ${e.partitions.map((t) => {
      var i;
      return D`
                  <tr>
                    <td>${t.name}</td>
                    <td>${t.filesystem || "Unknown"}</td>
                    <td>${this.formatBytes(t.size)}</td>
                    <td>
                      ${t.used ? D`
                        <div>
                          ${this.formatBytes(t.used)} (${(i = t.use_percent) == null ? void 0 : i.toFixed(1)}%)
                          <div class="progress-bar">
                            <div class="progress-fill" style="width: ${t.use_percent}%"></div>
                          </div>
                        </div>
                      ` : "N/A"}
                    </td>
                    <td>${t.mount_point || "Not mounted"}</td>
                    <td>
                      ${t.mount_point ? D`
                        <button class="btn-danger" @click=${() => this.unmountPartition(t.mount_point)}>
                          ${L("storage.disks.unmount")}
                        </button>
                      ` : D`
                        <button class="btn-primary" @click=${() => this.mountPartition(t.path, `/mnt/${t.name}`)}>
                          ${L("storage.disks.mount")}
                        </button>
                      `}
                    </td>
                  </tr>
                `;
    })}
              </tbody>
            </table>
          ` : ""}
        </div>
      `)}
    `;
  }
  renderLVMSection() {
    return D`
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">${L("storage.lvm.volumeGroups")}</h3>
          <button class="btn-primary" @click=${this.showCreateVGDialog}>
            ${L("storage.lvm.createVG")}
          </button>
        </div>
        
        ${this.volumeGroups.length === 0 ? D`
          <div class="empty-state">${L("storage.lvm.noVolumeGroups")}</div>
        ` : D`
          <table class="table">
            <thead>
              <tr>
                <th>${L("common.name")}</th>
                <th>${L("storage.lvm.size")}</th>
                <th>${L("storage.lvm.free")}</th>
                <th>${L("storage.lvm.pvCount")}</th>
                <th>${L("storage.lvm.lvCount")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.volumeGroups.map((e) => D`
                <tr>
                  <td>${e.name}</td>
                  <td>${this.formatBytes(e.size)}</td>
                  <td>${this.formatBytes(e.free)}</td>
                  <td>${e.pv_count}</td>
                  <td>${e.lv_count}</td>
                </tr>
              `)}
            </tbody>
          </table>
        `}
      </div>

      <div class="card">
        <div class="card-header">
          <h3 class="card-title">${L("storage.lvm.logicalVolumes")}</h3>
          <button class="btn-primary" @click=${this.showCreateLVDialog}>
            ${L("storage.lvm.createLV")}
          </button>
        </div>
        
        ${this.logicalVolumes.length === 0 ? D`
          <div class="empty-state">${L("storage.lvm.noLogicalVolumes")}</div>
        ` : D`
          <table class="table">
            <thead>
              <tr>
                <th>${L("common.name")}</th>
                <th>${L("storage.lvm.volumeGroup")}</th>
                <th>${L("storage.lvm.size")}</th>
                <th>${L("storage.lvm.path")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.logicalVolumes.map((e) => D`
                <tr>
                  <td>${e.name}</td>
                  <td>${e.vg_name}</td>
                  <td>${this.formatBytes(e.size)}</td>
                  <td>${e.path}</td>
                </tr>
              `)}
            </tbody>
          </table>
        `}
      </div>

      <div class="card">
        <h3 class="card-title">${L("storage.lvm.physicalVolumes")}</h3>
        
        ${this.physicalVolumes.length === 0 ? D`
          <div class="empty-state">${L("storage.lvm.noPhysicalVolumes")}</div>
        ` : D`
          <table class="table">
            <thead>
              <tr>
                <th>${L("common.name")}</th>
                <th>${L("storage.lvm.volumeGroup")}</th>
                <th>${L("storage.lvm.size")}</th>
                <th>${L("storage.lvm.free")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.physicalVolumes.map((e) => D`
                <tr>
                  <td>${e.name}</td>
                  <td>${e.vg_name || "N/A"}</td>
                  <td>${this.formatBytes(e.size)}</td>
                  <td>${this.formatBytes(e.free)}</td>
                </tr>
              `)}
            </tbody>
          </table>
        `}
      </div>
    `;
  }
  renderRAIDSection() {
    return D`
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">${L("storage.raid.devices")}</h3>
          <button class="btn-primary" @click=${this.showCreateRAIDDialog}>
            ${L("storage.raid.createRAID")}
          </button>
        </div>
        
        ${this.raidDevices.length === 0 ? D`
          <div class="empty-state">${L("storage.raid.noDevices")}</div>
        ` : D`
          <table class="table">
            <thead>
              <tr>
                <th>${L("common.name")}</th>
                <th>${L("storage.raid.level")}</th>
                <th>${L("storage.raid.state")}</th>
                <th>${L("storage.raid.size")}</th>
                <th>${L("storage.raid.devices")}</th>
                <th>${L("common.actions")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.raidDevices.map((e) => D`
                <tr>
                  <td>${e.name}</td>
                  <td>RAID ${e.level}</td>
                  <td>
                    <span class="status-badge ${e.state === "active" ? "active" : "error"}">
                      ${e.state}
                    </span>
                  </td>
                  <td>${this.formatBytes(e.size)}</td>
                  <td>${e.active_disks}/${e.total_disks}</td>
                  <td>
                    <button class="btn-danger" @click=${() => this.destroyRAID(e.path)}>
                      ${L("storage.raid.destroy")}
                    </button>
                  </td>
                </tr>
              `)}
            </tbody>
          </table>
        `}
      </div>

      <div class="card">
        <h3 class="card-title">${L("storage.raid.availableDisks")}</h3>
        
        ${this.availableRaidDisks.length === 0 ? D`
          <div class="empty-state">${L("storage.raid.noAvailableDisks")}</div>
        ` : D`
          <table class="table">
            <thead>
              <tr>
                <th>${L("storage.raid.device")}</th>
                <th>${L("storage.raid.size")}</th>
                <th>${L("storage.raid.partition")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.availableRaidDisks.map((e) => D`
                <tr>
                  <td>${e.path}</td>
                  <td>${this.formatBytes(e.size)}</td>
                  <td>${e.partition ? L("common.yes") : L("common.no")}</td>
                </tr>
              `)}
            </tbody>
          </table>
        `}
      </div>
    `;
  }
  renderISCSISection() {
    return D`
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">${L("storage.iscsi.sessions")}</h3>
          <button class="btn-primary" @click=${this.showDiscoverISCSIDialog}>
            ${L("storage.iscsi.discover")}
          </button>
        </div>
        
        ${this.iscsiSessions.length === 0 ? D`
          <div class="empty-state">${L("storage.iscsi.noSessions")}</div>
        ` : D`
          <table class="table">
            <thead>
              <tr>
                <th>${L("storage.iscsi.target")}</th>
                <th>${L("storage.iscsi.portal")}</th>
                <th>${L("storage.iscsi.sessionId")}</th>
                <th>${L("storage.iscsi.state")}</th>
                <th>${L("common.actions")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.iscsiSessions.map((e) => D`
                <tr>
                  <td>${e.target}</td>
                  <td>${e.portal}</td>
                  <td>${e.session_id}</td>
                  <td>
                    <span class="status-badge ${e.state === "logged_in" ? "active" : "inactive"}">
                      ${e.state}
                    </span>
                  </td>
                  <td>
                    <button class="btn-danger" @click=${() => this.logoutISCSI(e.target)}>
                      ${L("storage.iscsi.logout")}
                    </button>
                  </td>
                </tr>
              `)}
            </tbody>
          </table>
        `}
      </div>

      ${this.iscsiTargets.length > 0 ? D`
        <div class="card">
          <h3 class="card-title">${L("storage.iscsi.discoveredTargets")}</h3>
          <table class="table">
            <thead>
              <tr>
                <th>${L("storage.iscsi.iqn")}</th>
                <th>${L("storage.iscsi.portal")}</th>
                <th>${L("storage.iscsi.connected")}</th>
                <th>${L("common.actions")}</th>
              </tr>
            </thead>
            <tbody>
              ${this.iscsiTargets.map((e) => D`
                <tr>
                  <td>${e.iqn}</td>
                  <td>${e.portal}</td>
                  <td>${e.connected ? L("common.yes") : L("common.no")}</td>
                  <td>
                    ${e.connected ? "" : D`
                      <button class="btn-primary" @click=${() => this.loginISCSI(e)}>
                        ${L("storage.iscsi.login")}
                      </button>
                    `}
                  </td>
                </tr>
              `)}
            </tbody>
          </table>
        </div>
      ` : ""}
    `;
  }
  renderMultipathSection() {
    return D`
      <div class="card">
        <h3 class="card-title">${L("storage.multipath.devices")}</h3>
        
        ${this.multipathDevices.length === 0 ? D`
          <div class="empty-state">${L("storage.multipath.noDevices")}</div>
        ` : D`
          ${this.multipathDevices.map((e) => D`
            <div class="card">
              <div class="card-header">
                <h4 class="card-title">${e.name} - ${e.product}</h4>
                <span class="status-badge ${e.state === "active" ? "active" : "error"}">
                  ${e.state}
                </span>
              </div>
              <div class="info-grid">
                <div class="info-item">
                  <span class="info-label">${L("storage.multipath.wwid")}</span>
                  <span class="info-value">${e.wwid}</span>
                </div>
                <div class="info-item">
                  <span class="info-label">${L("storage.multipath.vendor")}</span>
                  <span class="info-value">${e.vendor}</span>
                </div>
                <div class="info-item">
                  <span class="info-label">${L("storage.multipath.size")}</span>
                  <span class="info-value">${e.size}</span>
                </div>
              </div>
              
              <h5>${L("storage.multipath.paths")}</h5>
              <table class="table">
                <thead>
                  <tr>
                    <th>${L("storage.multipath.device")}</th>
                    <th>${L("storage.multipath.host")}</th>
                    <th>${L("storage.multipath.state")}</th>
                    <th>${L("storage.multipath.priority")}</th>
                  </tr>
                </thead>
                <tbody>
                  ${e.paths.map((t) => D`
                    <tr>
                      <td>${t.device}</td>
                      <td>${t.host}</td>
                      <td>
                        <span class="status-badge ${t.state === "active" ? "active" : "inactive"}">
                          ${t.state}
                        </span>
                      </td>
                      <td>${t.priority}</td>
                    </tr>
                  `)}
                </tbody>
              </table>
            </div>
          `)}
        `}
      </div>
    `;
  }
  renderBTRFSSection() {
    return D`
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">${L("storage.btrfs.subvolumes")}</h3>
          <button class="btn-primary" @click=${this.showCreateSubvolumeDialog}>
            ${L("storage.btrfs.createSubvolume")}
          </button>
        </div>
        
        ${this.btrfsSubvolumes.length === 0 ? D`
          <div class="empty-state">${L("storage.btrfs.noSubvolumes")}</div>
        ` : D`
          <ul>
            ${this.btrfsSubvolumes.map((e) => D`
              <li>${e}</li>
            `)}
          </ul>
        `}
      </div>
    `;
  }
  renderContent() {
    if (this.loading)
      return D`<div class="loading">${L("common.loading")}</div>`;
    if (this.error)
      return D`<div class="error">${this.error}</div>`;
    switch (this.activeSection) {
      case "disks":
        return this.renderDisksSection();
      case "lvm":
        return this.renderLVMSection();
      case "raid":
        return this.renderRAIDSection();
      case "iscsi":
        return this.renderISCSISection();
      case "multipath":
        return this.renderMultipathSection();
      case "btrfs":
        return this.renderBTRFSSection();
      default:
        return D``;
    }
  }
  render() {
    return D`
      <div class="storage-container">
        <h1>${L(`storage.${this.activeSection}.title`)}</h1>
        <div class="content">
          ${this.renderContent()}
        </div>
      </div>
    `;
  }
  // Action methods
  async mountPartition(e, t) {
    try {
      await J.post("/storage/mount", { device: e, mount_point: t }), await this.fetchDisks();
    } catch (i) {
      console.error("Error mounting partition:", i);
    }
  }
  async unmountPartition(e) {
    try {
      await J.post("/storage/unmount", { mount_point: e }), await this.fetchDisks();
    } catch (t) {
      console.error("Error unmounting partition:", t);
    }
  }
  async destroyRAID(e) {
    if (confirm(L("storage.raid.confirmDestroy")))
      try {
        await J.post("/storage/raid/destroy", { device: e }), await this.fetchRAID();
      } catch (t) {
        console.error("Error destroying RAID:", t);
      }
  }
  async logoutISCSI(e) {
    try {
      await J.post("/storage/iscsi/logout", { target: e }), await this.fetchiSCSI();
    } catch (t) {
      console.error("Error logging out from iSCSI:", t);
    }
  }
  async loginISCSI(e) {
    try {
      await J.post("/storage/iscsi/login", {
        target: e.iqn,
        portal: e.portal
      }), await this.fetchiSCSI();
    } catch (t) {
      console.error("Error logging in to iSCSI:", t);
    }
  }
  // Dialog methods (placeholders - in a real implementation, these would show modal dialogs)
  showCreateVGDialog() {
    console.log("Show create VG dialog");
  }
  showCreateLVDialog() {
    console.log("Show create LV dialog");
  }
  showCreateRAIDDialog() {
    console.log("Show create RAID dialog");
  }
  showDiscoverISCSIDialog() {
    console.log("Show discover iSCSI dialog");
  }
  showCreateSubvolumeDialog() {
    console.log("Show create subvolume dialog");
  }
};
za.styles = re`
    :host {
      display: block;
      height: 100%;
      overflow-y: auto;
    }

    .storage-container {
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 300;
    }


    .card {
      background: var(--vscode-bg-light);
      border: 1px solid var(--vscode-border);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .card-title {
      font-size: 16px;
      font-weight: 500;
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      font-size: 13px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .info-label {
      color: var(--vscode-text-dim);
      font-size: 12px;
    }

    .info-value {
      color: var(--vscode-text);
      font-family: var(--vscode-font-family-mono);
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--vscode-bg);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 4px;
    }

    .progress-fill {
      height: 100%;
      background: var(--vscode-accent);
      transition: width 0.3s ease;
    }

    .table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .table th,
    .table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid var(--vscode-border);
    }

    .table th {
      font-weight: 500;
      color: var(--vscode-text-dim);
    }

    .status-badge {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    .status-badge.active {
      background: var(--vscode-success);
      color: white;
    }

    .status-badge.inactive {
      background: var(--vscode-text-dim);
      color: white;
    }

    .status-badge.error {
      background: var(--vscode-error);
      color: white;
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--vscode-accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--vscode-accent-hover);
    }

    .btn-secondary {
      background: var(--vscode-bg);
      color: var(--vscode-text);
      border: 1px solid var(--vscode-border);
    }

    .btn-secondary:hover {
      background: var(--vscode-bg-light);
    }

    .btn-danger {
      background: var(--vscode-error);
      color: white;
    }

    .btn-danger:hover {
      opacity: 0.9;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      color: var(--vscode-text-dim);
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--vscode-text-dim);
    }

    .error {
      color: var(--vscode-error);
      padding: 16px;
      background: var(--vscode-bg-light);
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
      color: var(--vscode-text-dim);
    }

    .form-input {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid var(--vscode-border);
      border-radius: 4px;
      background: var(--vscode-bg);
      color: var(--vscode-text);
      font-size: 13px;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--vscode-accent);
    }

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-content {
      background: var(--vscode-bg-light);
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 500;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--vscode-text-dim);
    }
  `;
let je = za;
lt([
  H({ type: Array })
], je.prototype, "disks");
lt([
  H({ type: Array })
], je.prototype, "volumeGroups");
lt([
  H({ type: Array })
], je.prototype, "logicalVolumes");
lt([
  H({ type: Array })
], je.prototype, "physicalVolumes");
lt([
  H({ type: Array })
], je.prototype, "raidDevices");
lt([
  H({ type: Array })
], je.prototype, "availableRaidDisks");
lt([
  H({ type: Array })
], je.prototype, "iscsiTargets");
lt([
  H({ type: Array })
], je.prototype, "iscsiSessions");
lt([
  H({ type: Array })
], je.prototype, "multipathDevices");
lt([
  H({ type: Array })
], je.prototype, "btrfsSubvolumes");
lt([
  H({ type: String })
], je.prototype, "activeSection");
lt([
  H({ type: String })
], je.prototype, "subRoute");
lt([
  H({ type: Boolean })
], je.prototype, "loading");
lt([
  H({ type: String })
], je.prototype, "error");
customElements.define("storage-tab", je);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Eb = { CHILD: 2 }, Tb = (s) => (...e) => ({ _$litDirective$: s, values: e });
class Lb {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, t, i) {
    this._$Ct = e, this._$AM = t, this._$Ci = i;
  }
  _$AS(e, t) {
    return this.update(e, t);
  }
  update(e, t) {
    return this.render(...t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class jo extends Lb {
  constructor(e) {
    if (super(e), this.it = Re, e.type !== Eb.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(e) {
    if (e === Re || e == null) return this._t = void 0, this.it = e;
    if (e === As) return e;
    if (typeof e != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (e === this.it) return this._t;
    this.it = e;
    const t = [e];
    return t.raw = t, this._t = { _$litType$: this.constructor.resultType, strings: t, values: [] };
  }
}
jo.directiveName = "unsafeHTML", jo.resultType = 1;
const jh = Tb(jo);
var Mb = Object.defineProperty, ye = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Mb(e, t, r), r;
};
const Ha = class Ha extends le {
  constructor() {
    super(...arguments), this.activeTab = "containers", this.containers = [], this.images = [], this.searchTerm = "", this.error = null, this.runtime = null, this.showConfirmModal = !1, this.confirmAction = null, this.selectedContainer = null, this.selectedImage = null, this.showDrawer = !1, this.detailError = null, this.confirmTitle = "", this.confirmMessage = "", this.showLogsDrawer = !1, this.containerLogs = "", this.logsError = null, this.logsSearchTerm = "", this.showImageActionsDropdown = !1, this.showPullImageModal = !1, this.imageName = "", this.selectedFile = null, this.showUploadDrawer = !1, this.uploadQueue = [], this.isUploading = !1, this.handleLocationChange = () => {
      window.location.pathname.endsWith("/images") ? this.activeTab = "images" : this.activeTab = "containers", this.fetchData();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.handleLocationChange(), window.addEventListener("popstate", this.handleLocationChange), this.addEventListener("click", this.handleOutsideClick.bind(this)), this.handleKeyDown = this.handleKeyDown.bind(this), document.addEventListener("keydown", this.handleKeyDown);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("popstate", this.handleLocationChange), this.removeEventListener("click", this.handleOutsideClick.bind(this)), document.removeEventListener("keydown", this.handleKeyDown);
  }
  handleTabClick(e, t) {
    e.preventDefault(), this.activeTab = t;
    const i = t === "images" ? "/containers/cri/images" : "/containers/cri";
    window.history.pushState({}, "", i), this.fetchData();
  }
  async fetchData() {
    this.activeTab === "containers" ? await this.fetchContainers() : this.activeTab === "images" && await this.fetchImages();
  }
  async fetchContainerDetails(e) {
    var t;
    try {
      this.detailError = null;
      const i = await J.get(`/containers/${e}`);
      console.log("Full container details response:", i);
      let r = null;
      (t = i == null ? void 0 : i.data) != null && t.container ? r = i.data.container : i != null && i.container ? r = i.container : i != null && i.id && (r = i), console.log("Extracted container:", r), this.selectedContainer = r, this.selectedImage = null, this.showDrawer = !0;
    } catch (i) {
      console.error("Error fetching container details:", i), this.detailError = i instanceof De ? i.message : "Failed to fetch container details", this.selectedContainer = null, this.selectedImage = null, this.showDrawer = !0;
    }
  }
  async fetchImageDetails(e) {
    var t;
    try {
      this.detailError = null;
      const i = await J.get(`/images/${e}`);
      console.log("Full image details response:", i);
      let r = null;
      (t = i == null ? void 0 : i.data) != null && t.image ? r = i.data.image : i != null && i.image ? r = i.image : i != null && i.id && (r = i), console.log("Extracted image:", r), this.selectedImage = r, this.selectedContainer = null, this.showDrawer = !0;
    } catch (i) {
      console.error("Error fetching image details:", i), this.detailError = i instanceof De ? i.message : "Failed to fetch image details", this.selectedImage = null, this.selectedContainer = null, this.showDrawer = !0;
    }
  }
  async fetchContainers() {
    try {
      const e = await J.get("/containers");
      this.containers = e.containers || [], this.runtime = e.runtime || null, this.error = null;
    } catch (e) {
      console.error("Error fetching containers:", e), e instanceof De && e.code === "NO_RUNTIME_AVAILABLE" ? (this.error = e.message || "No container runtime found", this.containers = [], this.runtime = null) : e instanceof De ? this.error = e.message || "Failed to fetch containers" : this.error = "Error connecting to server";
    }
  }
  async fetchImages() {
    try {
      const e = await J.get("/images");
      this.images = e.images || [], this.runtime = e.runtime || null, this.error = null;
    } catch (e) {
      console.error("Error fetching images:", e), e instanceof De && e.code === "NO_RUNTIME_AVAILABLE" ? (this.error = e.message || "No container runtime found", this.images = [], this.runtime = null) : e instanceof De ? this.error = e.message || "Failed to fetch images" : this.error = "Error connecting to server";
    }
  }
  showConfirmDialog(e, t, i) {
    this.confirmTitle = e, this.confirmMessage = t, this.confirmAction = i, this.showConfirmModal = !0, this.updateComplete.then(() => {
      var n;
      const r = (n = this.shadowRoot) == null ? void 0 : n.querySelector("modal-dialog button.btn-secondary");
      r && setTimeout(() => r.focus(), 50);
    });
  }
  handleConfirm() {
    this.confirmAction && this.confirmAction(), this.showConfirmModal = !1, this.confirmAction = null;
  }
  handleCancel() {
    this.showConfirmModal = !1, this.confirmAction = null;
  }
  async startContainer(e, t) {
    this.showConfirmDialog(
      "Start Container",
      `Are you sure you want to start container "${t || e}"?`,
      async () => {
        try {
          await J.post(`/containers/${e}/start`), this.fetchContainers();
        } catch (i) {
          console.error("Error starting container:", i);
        }
      }
    );
  }
  async stopContainer(e, t) {
    this.showConfirmDialog(
      "Stop Container",
      `Are you sure you want to stop container "${t || e}"?`,
      async () => {
        try {
          await J.post(`/containers/${e}/stop`), this.fetchContainers();
        } catch (i) {
          console.error("Error stopping container:", i);
        }
      }
    );
  }
  async removeContainer(e, t) {
    this.showConfirmDialog(
      "Remove Container",
      `Are you sure you want to remove container "${t || e}"? This action cannot be undone.`,
      async () => {
        try {
          await J.delete(`/containers/${e}`), this.fetchContainers();
        } catch (i) {
          console.error("Error removing container:", i);
        }
      }
    );
  }
  async removeImage(e, t) {
    this.showConfirmDialog(
      "Remove Image",
      `Are you sure you want to remove image "${t || e}"? This action cannot be undone.`,
      async () => {
        try {
          await J.delete(`/images/${e}`), this.fetchImages();
        } catch (i) {
          console.error("Error removing image:", i);
        }
      }
    );
  }
  async fetchContainerLogs(e, t) {
    var i;
    try {
      console.log("Fetching logs for container:", e, t), this.logsError = null, this.containerLogs = "Loading logs...", this.logsSearchTerm = "", this.showLogsDrawer = !0;
      const r = await J.get(`/containers/${e}/logs`);
      console.log("Logs response:", r), (i = r == null ? void 0 : r.data) != null && i.logs ? this.containerLogs = r.data.logs : r != null && r.logs ? this.containerLogs = r.logs : this.containerLogs = "No logs available";
    } catch (r) {
      console.error("Error fetching container logs:", r), this.logsError = r instanceof De ? r.message : "Failed to fetch container logs", this.containerLogs = "";
    }
  }
  renderContainersTable() {
    const e = this.containers.filter(
      (t) => {
        var i;
        return (i = t.name) == null ? void 0 : i.toLowerCase().includes(this.searchTerm.toLowerCase());
      }
    );
    return D`
    <div class="search-container">
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${L("containers.searchContainers")}"
          .value=${this.searchTerm}
          @input=${(t) => this.searchTerm = t.target.value}
        />
      </div>
    </div>
      <table class="table">
        <thead>
          <tr>
            <th>${L("common.name")}</th>
            <th>${L("common.state")}</th>
            <th>ID</th>
            <th>${L("common.image")}</th>
            <th>${L("common.created")}</th>
            <th>${L("common.actions")}</th>
          </tr>
        </thead>
        <tbody>
          ${e.map((t, i) => {
      var l;
      const r = ((l = t.id) == null ? void 0 : l.substring(0, 12)) || "Unknown", n = t.created_at ? new Date(t.created_at).toLocaleString() : "Unknown", o = t.image || "Unknown", a = o.length > 20 ? o.substring(0, 20) + "..." : o;
      return D`
              <tr>
<td>
<button class="link-button" @click=${() => this.fetchContainerDetails(t.id)}>
    ${t.name || "Unnamed"}
  </button>
</td>
                <td>
                  <div class="status-indicator">
                    <span class="status-icon ${this.getStatusClass(t.state)}" data-tooltip="${this.getStatusTooltip(t.state)}"></span>
                  </div>
                </td>
                <td>${r}</td>
                <td>
                  <span class="truncate" title="${o}">${a}</span>
                </td>
                <td>${n}</td>
                <td>
                  <div class="action-menu">
                    <button class="action-dots" @click=${(c) => this.toggleActionMenu(c, `container-${i}`)}></button>
                    <div class="action-dropdown" id="container-${i}">
                      <button @click=${() => {
        this.closeAllMenus(), this.fetchContainerLogs(t.id, t.name);
      }}>Logs</button>
                      ${t.state === "CONTAINER_RUNNING" ? D`<button @click=${() => {
        this.closeAllMenus(), this.stopContainer(t.id, t.name);
      }}>${L("containers.stop")}</button>` : D`<button @click=${() => {
        this.closeAllMenus(), this.startContainer(t.id, t.name);
      }}>${L("containers.start")}</button>`}
                      <button class="danger" @click=${() => {
        this.closeAllMenus(), this.removeContainer(t.id, t.name);
      }}>${L("common.delete")}</button>
                    </div>
                  </div>
                </td>
              </tr>
            `;
    })}
        </tbody>
      </table>
    `;
  }
  renderImagesTable() {
    const e = this.images.filter(
      (t) => {
        var i;
        return (i = t.repo_tags) == null ? void 0 : i.some((r) => r.toLowerCase().includes(this.searchTerm.toLowerCase()));
      }
    );
    return D`
    <div class="search-container">
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${L("containers.searchImages")}"
          .value=${this.searchTerm}
          @input=${(t) => this.searchTerm = t.target.value}
        />
      </div>
      <div class="action-menu">
        <button class="btn btn-primary" @click=${(t) => this.toggleImageActionsDropdown(t)}>+ Add Image</button>
        <div class="action-dropdown ${this.showImageActionsDropdown ? "show" : ""}">
          <button @click=${() => this.handleImageActionSelect("pull")}>Pull Image</button>
          <button @click=${() => this.handleImageActionSelect("upload")}>Upload Image</button>
        </div>
      </div>
    </div>
      <table class="table">
        <thead>
          <tr>
            <th>${L("common.tags")}</th>
            <th>ID</th>
            <th>${L("common.size")}</th>
            <th>${L("common.runtime")}</th>
            <th>${L("common.created")}</th>
            <th>${L("common.actions")}</th>
          </tr>
        </thead>
        <tbody>
          ${e.map((t, i) => {
      var a;
      const r = ((a = t.id) == null ? void 0 : a.substring(0, 12)) || "Unknown", n = t.repo_tags && t.repo_tags.length > 0 ? t.repo_tags.join(", ") : "No tags", o = t.created_at ? new Date(t.created_at).toLocaleString() : "Unknown";
      return D`
              <tr>
<td>
<button class="link-button" @click=${() => this.fetchImageDetails(t.id)}>
    ${n}
  </button>
</td>
                <td>${r}</td>
                <td>${this.formatSize(t.size)}</td>
                <td>${t.runtime || "Unknown"}</td>
                <td>${o}</td>
                <td>
                  <div class="action-menu">
                    <button class="action-dots" @click=${(l) => this.toggleActionMenu(l, `image-${i}`)}></button>
                    <div class="action-dropdown" id="image-${i}">
                      <button class="danger" @click=${() => {
        var l;
        this.closeAllMenus(), this.removeImage(t.id, (l = t.repo_tags) == null ? void 0 : l.join(", "));
      }}>${L("common.delete")}</button>
                    </div>
                  </div>
                </td>
              </tr>
            `;
    })}
        </tbody>
      </table>
    `;
  }
  formatSize(e) {
    if (!e) return "Unknown";
    const t = ["B", "KB", "MB", "GB"], i = Math.floor(Math.log(e) / Math.log(1024));
    return `${(e / Math.pow(1024, i)).toFixed(2)} ${t[i]}`;
  }
  getStatusClass(e) {
    switch (e) {
      case "CONTAINER_RUNNING":
        return "running";
      case "CONTAINER_STOPPED":
        return "stopped";
      case "CONTAINER_PAUSED":
        return "paused";
      case "CONTAINER_EXITED":
        return "exited";
      default:
        return "stopped";
    }
  }
  getStatusTooltip(e) {
    switch (e) {
      case "CONTAINER_RUNNING":
        return "Running";
      case "CONTAINER_STOPPED":
        return "Stopped";
      case "CONTAINER_PAUSED":
        return "Paused";
      case "CONTAINER_EXITED":
        return "Exited";
      default:
        return e || "Unknown";
    }
  }
  toggleActionMenu(e, t) {
    var r;
    e.stopPropagation();
    const i = (r = this.shadowRoot) == null ? void 0 : r.getElementById(t);
    if (i) {
      const n = i.classList.contains("show");
      if (this.closeAllMenus(), !n) {
        i.classList.add("show");
        const o = i.querySelector("button");
        o && setTimeout(() => o.focus(), 10);
      }
    }
  }
  closeAllMenus() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelectorAll(".action-dropdown");
    e == null || e.forEach((i) => i.classList.remove("show"));
  }
  renderTabs() {
    return D`
      <div class="tab-header">
        <a 
          href="/containers/cri"
          class="tab-button ${this.activeTab === "containers" ? "active" : ""}" 
          @click="${(e) => this.handleTabClick(e, "containers")}"
        >
          Containers
        </a>
        <a 
          href="/containers/cri/images"
          class="tab-button ${this.activeTab === "images" ? "active" : ""}" 
          @click="${(e) => this.handleTabClick(e, "images")}"
        >
          Images
        </a>
      </div>
    `;
  }
  renderError() {
    return D`
      <div class="error-container">
        <div class="error-icon"></div>
        <p class="error-message">${this.detailError}</p>
      </div>
    `;
  }
  renderContainerDetails() {
    if (!this.selectedContainer) return;
    const e = this.selectedContainer;
    return D`
      <div class="drawer-content">
        <div class="detail-section">
          <h3>Container Details</h3>
          <div class="detail-item">
            <span class="detail-label">Name</span>
            <span class="detail-value">${e.name || "Unnamed"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">ID</span>
            <span class="detail-value monospace">${e.id || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Image</span>
            <span class="detail-value">${e.image || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">State</span>
            <span class="detail-value">
              <span class="status-badge ${this.getStatusClass(e.state)}">${this.getStatusTooltip(e.state)}</span>
            </span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Status</span>
            <span class="detail-value">${e.status || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Runtime</span>
            <span class="detail-value">${e.runtime || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Created</span>
            <span class="detail-value">${e.created_at ? new Date(e.created_at).toLocaleString() : "Unknown"}</span>
          </div>
        </div>

        ${e.labels && Object.keys(e.labels).length > 0 ? D`
          <div class="detail-section">
            <h3>Labels</h3>
            <div class="tag-list">
              ${Object.entries(e.labels).map(
      ([t, i]) => D`<div class="tag">${t}: ${i}</div>`
    )}
            </div>
          </div>
        ` : ""}
      </div>
    `;
  }
  renderImageDetails() {
    if (!this.selectedImage) return;
    const e = this.selectedImage;
    return D`
      <div class="drawer-content">
        <div class="detail-section">
          <h3>Image Details</h3>
          <div class="detail-item">
            <span class="detail-label">ID</span>
            <span class="detail-value monospace">${e.id || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Tags</span>
            ${e.repo_tags && e.repo_tags.length > 0 ? D`<div class="tag-list">${e.repo_tags.map(
      (t) => D`<div class="tag">${t}</div>`
    )}</div>` : D`<span class="detail-value">No tags</span>`}
          </div>
          ${e.repo_digests && e.repo_digests.length > 0 ? D`
            <div class="detail-item">
              <span class="detail-label">Digests</span>
              <div class="detail-value">
                ${e.repo_digests.map((t) => D`<div class="monospace">${t}</div>`)}
              </div>
            </div>
          ` : ""}
          <div class="detail-item">
            <span class="detail-label">Size</span>
            <span class="detail-value">${this.formatSize(e.size)}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Runtime</span>
            <span class="detail-value">${e.runtime || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Created</span>
            <span class="detail-value">${e.created_at ? new Date(e.created_at).toLocaleString() : "Unknown"}</span>
          </div>
        </div>
      </div>
    `;
  }
  render() {
    return D`
      <div class="tab-container">
        <h1>${L("containers.title")}${this.runtime ? D` <span style="font-size: 0.875rem; color: var(--text-secondary); font-weight: normal;">(${this.runtime})</span>` : ""}</h1>
        ${this.renderTabs()}
        <div class="tab-content">
          ${this.error ? D`
            <div class="error-state">
              <h3>${this.error.includes("No container runtime found") ? "Container Runtime Not Available" : "Error"}</h3>
              <p>${this.error.includes("No container runtime found") ? "Container management features are not available. Please install Docker or a CRI-compatible container runtime (containerd, CRI-O) to use this feature." : this.error}</p>
            </div>
          ` : ""}


          ${this.activeTab === "containers" && !this.error ? D`
            ${this.containers.length > 0 ? this.renderContainersTable() : D`
                <div class="empty-state">No containers found.</div>
              `}
          ` : ""}

          ${this.activeTab === "images" && !this.error ? D`
            ${this.images.length > 0 ? this.renderImagesTable() : D`
                <div class="empty-state">No images found.</div>
              `}
          ` : ""}
        </div>
      </div>

      <modal-dialog
        ?open=${this.showConfirmModal}
        .title=${this.confirmTitle}
        size="small"
        @modal-close=${this.handleCancel}
      >
        <p>${this.confirmMessage}</p>
        <div slot="footer" style="display: flex; gap: 8px; justify-content: flex-end;">
          <button class="btn btn-secondary" @click=${this.handleCancel}>
            ${L("common.cancel")}
          </button>
          <button class="btn btn-primary" @click=${this.handleConfirm}>
            ${L("common.confirm")}
          </button>
        </div>
      </modal-dialog>

      <modal-dialog
        ?open=${this.showPullImageModal}
        .title="Pull Image"
        size="medium"
        @modal-close=${this.handleCancelPullImage}
      >
        <div style="margin-bottom: 1rem;">
          <label for="imageName" style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--vscode-foreground);">Image Name:</label>
          <input 
            id="imageName"
            class="modal-input search-input"
            type="text" 
            placeholder="e.g., nginx:latest, ubuntu:20.04"
            .value=${this.imageName}
            @input=${(e) => this.imageName = e.target.value}
            @keydown=${(e) => {
      e.key === "Enter" && this.handleConfirmPullImage();
    }}
            style="width: 100%; padding-left: 12px;"
          />
        </div>
        <div slot="footer" style="display: flex; gap: 8px; justify-content: flex-end;">
          <button class="btn btn-secondary" @click=${this.handleCancelPullImage}>
            Cancel
          </button>
          <button class="btn btn-primary" @click=${this.handleConfirmPullImage} ?disabled=${!this.imageName.trim()}>
            Pull Image
          </button>
        </div>
      </modal-dialog>

      ${this.showDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click=${() => {
      this.showDrawer = !1, this.detailError = null;
    }}></button>
          
          ${this.detailError ? this.renderError() : this.selectedContainer ? this.renderContainerDetails() : this.selectedImage ? this.renderImageDetails() : ""}
        </div>
      ` : ""}

      ${this.showLogsDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click=${() => {
      this.showLogsDrawer = !1, this.logsError = null, this.containerLogs = "", this.logsSearchTerm = "";
    }}></button>
          
          <div class="drawer-content">
            <div class="logs-header">
              <h2 class="logs-title">Container Logs</h2>
              <div class="search-wrapper">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input
                  class="search-input"
                  type="text"
                  placeholder="${L("containers.searchLogs")}"
                  .value=${this.logsSearchTerm}
                  @input=${(e) => this.logsSearchTerm = e.target.value}
                />
              </div>
            </div>
            
            ${this.logsError ? D`
              <div class="error-container">
                <div class="error-icon"></div>
                <p class="error-message">${this.logsError}</p>
              </div>
            ` : D`
              <div class="logs-container">${jh(this.highlightSearchTerm(this.containerLogs, this.logsSearchTerm))}</div>
            `}
          </div>
        </div>
      ` : ""}

      ${this.showUploadDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click=${this.closeUploadDrawer}></button>
          ${this.renderUploadDrawer()}
        </div>
      ` : ""}
    `;
  }
  highlightSearchTerm(e, t) {
    if (!t || !e) return e;
    const i = t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), r = new RegExp(`(${i})`, "gi");
    return e.replace(r, '<mark style="background-color: #ffeb3b; color: #000; padding: 0 2px;">$1</mark>');
  }
  handleOutsideClick(e) {
    this.closeAllMenus(), this.showImageActionsDropdown = !1;
  }
  handleKeyDown(e) {
    e.key === "Escape" && (this.closeAllMenus(), this.showImageActionsDropdown = !1, this.showDrawer && (this.showDrawer = !1), this.showLogsDrawer && (this.showLogsDrawer = !1), this.showPullImageModal && this.handleCancelPullImage());
  }
  toggleImageActionsDropdown(e) {
    e.stopPropagation(), this.showImageActionsDropdown = !this.showImageActionsDropdown;
  }
  handleImageActionSelect(e) {
    this.showImageActionsDropdown = !1, e === "pull" ? (this.showPullImageModal = !0, this.imageName = "", this.updateComplete.then(() => {
      var i;
      const t = (i = this.shadowRoot) == null ? void 0 : i.querySelector(".modal-input");
      t && setTimeout(() => t.focus(), 50);
    })) : e === "upload" && this.openUploadDrawer();
  }
  triggerFileUpload() {
    const e = document.createElement("input");
    e.type = "file", e.accept = ".tar,.tar.gz,.tgz", e.style.display = "none", e.addEventListener("change", (t) => {
      const i = t.target.files;
      i && i.length > 0 && i[0] && (this.selectedFile = i[0], this.handleFileUpload()), document.body.removeChild(e);
    }), document.body.appendChild(e), e.click();
  }
  async handleFileUpload() {
    if (this.selectedFile)
      try {
        new FormData().append("image", this.selectedFile), console.log("Uploading image file:", this.selectedFile.name), this.fetchImages(), this.selectedFile = null;
      } catch (e) {
        console.error("Error uploading image file:", e);
      }
  }
  handleConfirmPullImage() {
    this.imageName.trim() && (this.pullImage(this.imageName.trim()), this.showPullImageModal = !1, this.imageName = "");
  }
  handleCancelPullImage() {
    this.showPullImageModal = !1, this.imageName = "";
  }
  async pullImage(e) {
    try {
      console.log("Pulling image:", e), this.fetchImages();
    } catch (t) {
      console.error("Error pulling image:", t);
    }
  }
  // Upload drawer methods
  openUploadDrawer() {
    this.showUploadDrawer = !0, this.uploadQueue = [];
  }
  closeUploadDrawer() {
    this.showUploadDrawer = !1, this.uploadQueue = [], this.isUploading = !1;
  }
  handleUploadZoneClick() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("#uploadFileInput");
    e == null || e.click();
  }
  handleFileInputChange(e) {
    const t = e.target, i = t.files;
    i && i.length > 0 && this.addFilesToQueue(Array.from(i)), t.value = "";
  }
  handleDragOver(e) {
    e.preventDefault(), e.stopPropagation(), e.currentTarget.classList.add("dragover");
  }
  handleDragLeave(e) {
    e.preventDefault(), e.stopPropagation(), e.currentTarget.classList.remove("dragover");
  }
  handleDrop(e) {
    var r;
    e.preventDefault(), e.stopPropagation(), e.currentTarget.classList.remove("dragover");
    const i = Array.from(((r = e.dataTransfer) == null ? void 0 : r.files) || []);
    i.length > 0 && this.addFilesToQueue(i);
  }
  addFilesToQueue(e) {
    const i = e.filter((r) => [".tar", ".tar.gz", ".tgz"].some((o) => r.name.toLowerCase().endsWith(o))).map((r) => ({
      id: crypto.randomUUID(),
      file: r,
      progress: 0,
      status: "pending"
    }));
    this.uploadQueue = [...this.uploadQueue, ...i];
  }
  removeFromQueue(e) {
    this.uploadQueue = this.uploadQueue.filter((t) => t.id !== e);
  }
  async startUploads() {
    if (this.isUploading) return;
    this.isUploading = !0;
    const e = this.uploadQueue.filter((t) => t.status === "pending");
    for (const t of e)
      await this.uploadSingleFile(t);
    this.isUploading = !1, this.fetchImages();
  }
  async uploadSingleFile(e) {
    try {
      const t = this.uploadQueue.findIndex((n) => n.id === e.id);
      t !== -1 && (this.uploadQueue[t] = { ...e, status: "uploading", progress: 0 }, this.requestUpdate()), new FormData().append("image", e.file), await this.simulateUploadProgress(e.id);
      const r = this.uploadQueue.findIndex((n) => n.id === e.id);
      if (r !== -1 && this.uploadQueue[r]) {
        const n = this.uploadQueue[r];
        this.uploadQueue[r] = { ...n, status: "completed", progress: 100 }, this.requestUpdate();
      }
    } catch (t) {
      console.error("Error uploading file:", t);
      const i = this.uploadQueue.findIndex((r) => r.id === e.id);
      if (i !== -1 && this.uploadQueue[i]) {
        const r = this.uploadQueue[i];
        this.uploadQueue[i] = {
          ...r,
          status: "error",
          error: t instanceof Error ? t.message : "Upload failed"
        }, this.requestUpdate();
      }
    }
  }
  async simulateUploadProgress(e) {
    for (let t = 0; t <= 100; t += 10)
      await new Promise((i) => setTimeout(i, 200)), this.updateUploadProgress(e, t);
  }
  updateUploadProgress(e, t) {
    const i = this.uploadQueue.findIndex((r) => r.id === e);
    if (i !== -1 && this.uploadQueue[i]) {
      const r = this.uploadQueue[i];
      this.uploadQueue[i] = { ...r, progress: t }, this.requestUpdate();
    }
  }
  clearCompletedUploads() {
    this.uploadQueue = this.uploadQueue.filter((e) => e.status !== "completed");
  }
  formatFileSize(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, i = ["Bytes", "KB", "MB", "GB"], r = Math.floor(Math.log(e) / Math.log(t));
    return parseFloat((e / Math.pow(t, r)).toFixed(2)) + " " + i[r];
  }
  renderUploadDrawer() {
    return D`
      <div class="drawer-content">
        <div class="upload-header">
          <h2 class="upload-title">Upload Images</h2>
        </div>
        
        <div class="upload-zone" 
             @click=${this.handleUploadZoneClick}
             @dragover=${this.handleDragOver}
             @dragleave=${this.handleDragLeave}
             @drop=${this.handleDrop}>
          <div class="upload-icon"></div>
          <div class="upload-text">Drop image files here or click to browse</div>
          <div class="upload-hint">Supported formats: .tar, .tar.gz, .tgz</div>
        </div>
        
        <input id="uploadFileInput" 
               class="hidden-file-input" 
               type="file" 
               accept=".tar,.tar.gz,.tgz" 
               multiple
               @change=${this.handleFileInputChange}>
        
        ${this.uploadQueue.length > 0 ? D`
          <div class="upload-queue">
            <h3>Upload Queue (${this.uploadQueue.length} files)</h3>
            ${this.uploadQueue.map((e) => this.renderUploadItem(e))}
          </div>
          
          <div class="upload-actions">
            ${this.isUploading ? D`
              <button class="btn btn-secondary" disabled>
                Uploading...
              </button>
            ` : D`
              <button class="btn btn-primary" 
                      @click=${this.startUploads}
                      ?disabled=${this.uploadQueue.filter((e) => e.status === "pending").length === 0}>
                Start Upload${this.uploadQueue.filter((e) => e.status === "pending").length > 1 ? "s" : ""}
              </button>
            `}
            
            <button class="btn btn-secondary" @click=${this.clearCompletedUploads}>
              Clear Completed
            </button>
            
            <button class="btn btn-secondary" @click=${this.closeUploadDrawer}>
              Close
            </button>
          </div>
        ` : ""}
      </div>
    `;
  }
  renderUploadItem(e) {
    return D`
      <div class="upload-item">
        <div class="upload-item-header">
          <span class="upload-item-name" title="${e.file.name}">${e.file.name}</span>
          <span class="upload-item-size">${this.formatFileSize(e.file.size)}</span>
          <span class="upload-item-status ${e.status}">${e.status.toUpperCase()}</span>
          ${e.status === "pending" ? D`
            <button class="btn btn-danger" @click=${() => this.removeFromQueue(e.id)} style="padding: 2px 6px; font-size: 10px; margin-left: 8px;"></button>
          ` : ""}
        </div>
        
        ${e.status === "uploading" || e.status === "completed" || e.status === "error" ? D`
          <div class="progress-bar">
            <div class="progress-fill ${e.status}" style="width: ${e.progress}%"></div>
          </div>
          <div class="progress-text">
            <span>${e.progress}%</span>
            <span>${e.status === "completed" ? "Complete" : e.status === "error" ? "Failed" : "Uploading..."}</span>
          </div>
        ` : ""}
        
        ${e.error ? D`
          <div class="upload-error">${e.error}</div>
        ` : ""}
      </div>
    `;
  }
};
Ha.styles = re`
    :host {
      display: block;
      padding: 16px;
    }

    .tab-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .tab-header {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.2s;
    }

    .tab-button:hover {
      color: var(--text-primary);
    }

    .tab-button.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .tab-content {
      flex: 1;
      overflow-y: auto;
    }

    .container {
      background: var(--vscode-bg-light);
      color: var(--vscode-text);
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .container-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .container-info {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }

    .container-actions {
      display: flex;
      gap: 8px;
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--vscode-accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--vscode-accent-hover);
    }

    .btn-danger {
      background: var(--vscode-error);
      color: white;
    }

    .btn-danger:hover {
      opacity: 0.9;
    }

    .size-info {
      font-size: 12px;
      color: var(--vscode-text-dim);
    }

    h1 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 300;
    }

    h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: var(--text-primary);
    }

    .image {
      background: var(--vscode-bg-light);
      color: var(--vscode-text);
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .image-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .image-info {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }

    .image-actions {
      display: flex;
      gap: 8px;
    }

    .search-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .section-header h2 {
      margin: 0;
    }

    .search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      max-width: 400px;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      color: var(--vscode-input-placeholderForeground, #999);
      pointer-events: none;
      width: 16px;
      height: 16px;
    }

    .search-input {
      padding: 6px 12px 6px 32px;
      border: 1px solid var(--vscode-widget-border, var(--vscode-input-border, var(--vscode-panel-border, #454545)));
      border-radius: 4px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      font-size: 0.875rem;
      width: 250px;
      transition: all 0.2s;
      outline: none;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
    }

    .search-input:hover {
      border-color: var(--vscode-inputOption-hoverBorder, var(--vscode-widget-border, #858585));
    }

    .search-input:focus {
      border-color: var(--vscode-focusBorder, #007acc);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1), 0 0 0 1px var(--vscode-focusBorder, #007acc);
    }

    .search-input::placeholder {
      color: var(--vscode-input-placeholderForeground, #999);
      opacity: 0.7;
    }

    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .error-state {
      text-align: center;
      padding: 3rem;
      color: var(--vscode-error);
      background: var(--vscode-bg-light);
      border-radius: 6px;
      margin: 2rem 0;
    }


    .table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      background: var(--vscode-bg-light);
      border-radius: 1px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .table thead {
      background: var(--vscode-bg-lighter);
    }

    .table th {
      background: var(--vscode-bg-dark);
      color: var(--vscode-text);
      font-weight: 600;
      text-align: left;
      padding: 12px 16px;
      font-size: 0.875rem;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .table td {
      padding: 12px 16px;
      color: var(--vscode-text);
      font-size: 0.875rem;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      position: relative;
    }

    .table td:last-child {
      text-align: right;
    }

    .table tr:last-child td {
      border-bottom: none;
    }

    .table tr:hover td {
      background: rgba(255, 255, 255, 0.02);
    }

    .table td button {
      margin-right: 8px;
    }

    .table td button:last-child {
      margin-right: 0;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .status-icon {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      position: relative;
    }

    .status-icon.running {
      background-color: #4caf50;
      box-shadow: 0 0 4px #4caf50;
    }

    .status-icon.stopped {
      background-color: #9e9e9e;
    }

    .status-icon.paused {
      background-color: #ff9800;
    }

    .status-icon.exited {
      background-color: #f44336;
    }

    .status-icon[data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      padding: 6px 12px;
      background-color: var(--vscode-editorWidget-background, var(--vscode-dropdown-background, #252526));
      color: var(--vscode-editorWidget-foreground, var(--vscode-foreground, #cccccc));
      border: 1px solid var(--vscode-editorWidget-border, var(--vscode-widget-border, #454545));
      border-radius: 4px;
      font-size: 14px;
      white-space: nowrap;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .truncate {
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
      position: relative;
    }

    .truncate[title]:hover::after {
      content: attr(title);
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 4px;
      padding: 6px 12px;
      background-color: var(--vscode-editorWidget-background, var(--vscode-dropdown-background, #252526));
      color: var(--vscode-editorWidget-foreground, var(--vscode-foreground, #cccccc));
      border: 1px solid var(--vscode-editorWidget-border, var(--vscode-widget-border, #454545));
      border-radius: 4px;
      font-size: 14px;
      white-space: nowrap;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      pointer-events: none;
    }

    .action-menu {
      position: relative;
      display: inline-block;
    }

    .action-dots {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      color: var(--text-secondary);
      font-size: 18px;
      line-height: 1;
      transition: background-color 0.2s;
      border-radius: 4px;
    }

    .action-dots:hover {
      background-color: var(--vscode-toolbar-hoverBackground, var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.1)));
    }

    .action-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--vscode-dropdown-background, var(--vscode-menu-background, var(--vscode-bg-light, #252526)));
      border: 1px solid var(--vscode-dropdown-border, var(--vscode-menu-border, var(--border-color, #454545)));
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 160px;
      z-index: 1000;
      display: none;
    }

    .action-dropdown.show {
      display: block;
    }

    .action-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 16px;
      border: none;
      background: none;
      color: var(--vscode-menu-foreground, var(--vscode-foreground, var(--vscode-text, #cccccc)));
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .action-dropdown button:hover {
      background-color: var(--vscode-list-hoverBackground, var(--vscode-toolbar-hoverBackground, rgba(255, 255, 255, 0.08)));
      color: var(--vscode-list-hoverForeground, var(--vscode-foreground));
    }

    .action-dropdown button.danger {
      color: var(--vscode-error);
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--vscode-accent, #007acc);
      color: white;
    }

    .btn-primary:hover {
      background: var(--vscode-accent-hover, #005a9e);
    }

    .btn-secondary {
      background: var(--vscode-button-secondary-bg, #3c3c3c);
      color: var(--vscode-button-secondary-foreground, #cccccc);
      border: 1px solid var(--vscode-button-secondary-border, #5a5a5a);
    }

    .btn-secondary:hover {
      background: var(--vscode-button-secondary-hover-bg, #484848);
    }

    .drawer {
      position: fixed;
      top: 0;
      right: 0;
      width: 50%;
      height: 100%;
      background: var(--vscode-bg-light);
      border-left: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      overflow-y: auto;
      padding: 24px;
      animation: slideIn 0.3s ease-out;
    }

    /* Make drawer full width on smaller screens */
    @media (max-width: 1024px) {
      .drawer {
        width: 80%;
      }
    }

    @media (max-width: 768px) {
      .drawer {
        width: 100%;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
      }
      to {
        transform: translateX(0);
      }
    }

    .drawer h2 {
      margin-top: 0;
    }

    .drawer pre {
      background: var(--vscode-bg-dark);
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      border-radius: 4px;
      padding: 16px;
      overflow-x: auto;
      font-size: 0.875rem;
      color: var(--vscode-text);
    }

    .drawer button.close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      background: var(--vscode-toolbar-hoverBackground, rgba(90, 93, 94, 0.1));
      color: var(--vscode-foreground, var(--vscode-editor-foreground));
      border: 1px solid var(--vscode-widget-border, rgba(0, 0, 0, 0.1));
      transition: all 0.2s;
    }

    .drawer button.close-btn:hover {
      background: var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.2));
      border-color: var(--vscode-widget-border, rgba(0, 0, 0, 0.2));
    }

    .drawer button.close-btn:active {
      background: var(--vscode-list-activeSelectionBackground, rgba(90, 93, 94, 0.3));
    }

    .drawer button.close-btn:focus {
      outline: 1px solid var(--vscode-focusBorder, #007acc);
      outline-offset: 2px;
    }

    .drawer-content {
      margin-top: 40px;
    }

    .detail-section {
      margin-bottom: 24px;
    }

    .detail-section h3 {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-primary);
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      padding-bottom: 8px;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      margin-bottom: 12px;
    }

    .detail-label {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      margin-bottom: 4px;
      font-weight: 500;
    }

    .detail-value {
      font-size: 0.875rem;
      color: var(--vscode-text);
      word-break: break-word;
    }

    .detail-value.monospace {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      background: var(--vscode-textCodeBlock-background, rgba(255, 255, 255, 0.04));
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 0.8125rem;
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tag {
      background: var(--vscode-badge-background);
      color: var(--vscode-badge-foreground);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .status-badge.running {
      background: rgba(76, 175, 80, 0.1);
      color: #4caf50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .status-badge.stopped {
      background: rgba(158, 158, 158, 0.1);
      color: #9e9e9e;
      border: 1px solid rgba(158, 158, 158, 0.3);
    }

    .status-badge.paused {
      background: rgba(255, 152, 0, 0.1);
      color: #ff9800;
      border: 1px solid rgba(255, 152, 0, 0.3);
    }

    .status-badge.exited {
      background: rgba(244, 67, 54, 0.1);
      color: #f44336;
      border: 1px solid rgba(244, 67, 54, 0.3);
    }

    a {
      color: var(--vscode-textLink-foreground, #3794ff);
      text-decoration: none;
      cursor: pointer;
    }

    a:hover {
      text-decoration: underline;
    }

    /* Link-style buttons for clickable items */
    button.link-button,
    td button {
      background: none;
      border: none;
      color: var(--vscode-textLink-foreground, #3794ff);
      cursor: pointer;
      font-size: inherit;
      font-family: inherit;
      text-align: left;
      padding: 0;
      text-decoration: none;
      transition: text-decoration 0.2s;
    }

    button.link-button:hover,
    td button:hover {
      text-decoration: underline;
    }

    td button:focus {
      outline: 1px solid var(--vscode-focusBorder, #007acc);
      outline-offset: 2px;
    }

    .error-container {
      padding: 40px 20px;
      text-align: center;
    }

    .error-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.7;
    }

    .error-message {
      color: var(--vscode-errorForeground, #f48771);
      font-size: 14px;
      line-height: 1.5;
      margin: 0;
    }

    .logs-container {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.5;
      background: var(--vscode-editor-background, #1e1e1e);
      color: var(--vscode-editor-foreground, #d4d4d4);
      padding: 16px;
      border-radius: 4px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .logs-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    /* Upload drawer styles */
    .upload-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .upload-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .upload-zone {
      border: 2px dashed var(--vscode-widget-border, #454545);
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 24px;
      transition: all 0.2s;
      cursor: pointer;
    }

    .upload-zone:hover {
      border-color: var(--vscode-focusBorder, #007acc);
      background: rgba(0, 122, 204, 0.05);
    }

    .upload-zone.dragover {
      border-color: var(--vscode-focusBorder, #007acc);
      background: rgba(0, 122, 204, 0.1);
    }

    .upload-icon {
      font-size: 48px;
      margin-bottom: 16px;
      color: var(--vscode-descriptionForeground, #999);
    }

    .upload-text {
      font-size: 16px;
      margin-bottom: 8px;
      color: var(--vscode-foreground);
    }

    .upload-hint {
      font-size: 14px;
      color: var(--vscode-descriptionForeground, #999);
    }

    .upload-queue {
      margin-top: 24px;
    }

    .upload-item {
      background: var(--vscode-bg-dark);
      border: 1px solid var(--vscode-widget-border, #454545);
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 12px;
    }

    .upload-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .upload-item-name {
      font-weight: 500;
      color: var(--vscode-foreground);
      flex: 1;
      margin-right: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .upload-item-size {
      font-size: 12px;
      color: var(--vscode-descriptionForeground, #999);
      margin-right: 12px;
    }

    .upload-item-status {
      font-size: 12px;
      font-weight: 500;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .upload-item-status.pending {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
    }

    .upload-item-status.uploading {
      background: rgba(0, 122, 204, 0.2);
      color: #007acc;
    }

    .upload-item-status.completed {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
    }

    .upload-item-status.error {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--vscode-widget-border, #454545);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: var(--vscode-focusBorder, #007acc);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .progress-fill.completed {
      background: #4caf50;
    }

    .progress-fill.error {
      background: #f44336;
    }

    .progress-text {
      font-size: 12px;
      color: var(--vscode-descriptionForeground, #999);
      display: flex;
      justify-content: space-between;
    }

    .upload-error {
      color: var(--vscode-errorForeground, #f48771);
      font-size: 12px;
      margin-top: 4px;
    }

    .upload-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--vscode-widget-border, #454545);
    }

    .hidden-file-input {
      display: none;
    }
  `;
let fe = Ha;
ye([
  B()
], fe.prototype, "activeTab");
ye([
  B()
], fe.prototype, "containers");
ye([
  B()
], fe.prototype, "images");
ye([
  B()
], fe.prototype, "searchTerm");
ye([
  B()
], fe.prototype, "error");
ye([
  B()
], fe.prototype, "runtime");
ye([
  B()
], fe.prototype, "showConfirmModal");
ye([
  B()
], fe.prototype, "confirmAction");
ye([
  B()
], fe.prototype, "selectedContainer");
ye([
  B()
], fe.prototype, "selectedImage");
ye([
  B()
], fe.prototype, "showDrawer");
ye([
  B()
], fe.prototype, "detailError");
ye([
  B()
], fe.prototype, "confirmTitle");
ye([
  B()
], fe.prototype, "confirmMessage");
ye([
  B()
], fe.prototype, "showLogsDrawer");
ye([
  B()
], fe.prototype, "containerLogs");
ye([
  B()
], fe.prototype, "logsError");
ye([
  B()
], fe.prototype, "logsSearchTerm");
ye([
  B()
], fe.prototype, "showImageActionsDropdown");
ye([
  B()
], fe.prototype, "showPullImageModal");
ye([
  B()
], fe.prototype, "imageName");
ye([
  B()
], fe.prototype, "selectedFile");
ye([
  B()
], fe.prototype, "showUploadDrawer");
ye([
  B()
], fe.prototype, "uploadQueue");
ye([
  B()
], fe.prototype, "isUploading");
customElements.define("containers-tab", fe);
var Ib = Object.defineProperty, js = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Ib(e, t, r), r;
};
const ja = class ja extends Fs {
  constructor() {
    super(...arguments), this.logs = [], this.serviceFilter = "", this.priorityFilter = "info", this.sinceFilter = "", this.follow = !0, this.connected = !1, this.autoScroll = !0, this.wsManager = null, this.logsContainer = null, this.maxLogs = 1e3;
  }
  // Maximum number of logs to keep in memory
  // Ensure update triggers on state change
  update(e) {
    super.update(e), console.log("Component updated", {
      logs: this.logs.length,
      connected: this.connected
    });
  }
  connectedCallback() {
    super.connectedCallback(), this.initWebSocket();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.cleanup();
  }
  firstUpdated() {
    var e;
    this.logsContainer = (e = this.shadowRoot) == null ? void 0 : e.querySelector(".logs-container");
  }
  async initWebSocket() {
    try {
      this.wsManager = new ea("/ws/logs"), this.wsManager.on("auth", (e) => {
        var t;
        ((t = e.payload) == null ? void 0 : t.authenticated) === !0 && (this.connected = !0, this.subscribeToLogs());
      }), this.wsManager.on("data", (e) => {
        console.log("Received data message:", e);
        const t = e.payload || e;
        if (t.message) {
          const i = {
            type: "log",
            timestamp: t.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            service: t.service || t.unit || "system",
            priority: t.priority || t.level || "info",
            message: t.message || "",
            hostname: t.hostname,
            pid: t.pid
          };
          this.addLog(i);
        }
      }), this.wsManager.on("logs", (e) => {
        console.log("Received logs message:", e), e.payload && Array.isArray(e.payload) && e.payload.forEach((t) => {
          const i = {
            type: "log",
            timestamp: t.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
            service: t.service || t.unit || "system",
            priority: t.priority || t.level || "info",
            message: t.message || "",
            hostname: t.hostname,
            pid: t.pid
          };
          this.addLog(i);
        });
      }), this.wsManager.on("error", (e) => {
        console.error("WebSocket error:", e.error), this.connected = !1;
      }), await this.wsManager.connect();
    } catch (e) {
      console.error("Failed to connect to logs WebSocket:", e), this.connected = !1;
    }
  }
  subscribeToLogs() {
    if (!this.wsManager) return;
    const e = {
      follow: this.follow
    };
    if (this.serviceFilter) {
      const i = this.serviceFilter.trim();
      i && (e.unit = i);
    }
    this.priorityFilter && this.priorityFilter !== "all" && (e.priority = this.priorityFilter), this.sinceFilter && (e.since = this.sinceFilter);
    const t = {
      type: "subscribe",
      payload: {
        filters: e
      }
    };
    console.log("Sending subscribe message:", t), this.wsManager.send(t);
  }
  addLog(e) {
    console.log("Adding log entry:", e), console.log("Current logs count before:", this.logs.length);
    const t = [...this.logs, e];
    t.length > this.maxLogs ? this.logs = t.slice(-this.maxLogs) : this.logs = t, console.log("Current logs count after:", this.logs.length), console.log("First log:", this.logs[0]), this.requestUpdate(), this.autoScroll && this.logsContainer && this.updateComplete.then(() => {
      this.logsContainer && (this.logsContainer.scrollTop = this.logsContainer.scrollHeight);
    });
  }
  handleServiceFilterChange(e) {
    this.serviceFilter = e.target.value, this.connected && (this.logs = [], this.subscribeToLogs());
  }
  handlePriorityChange(e) {
    this.priorityFilter = e.target.value, this.connected && (this.logs = [], this.subscribeToLogs());
  }
  handleSinceFilterChange(e) {
    this.sinceFilter = e.target.value, this.connected && (this.logs = [], this.subscribeToLogs());
  }
  handleFollowChange(e) {
    this.follow = e.target.checked, this.connected && this.subscribeToLogs();
  }
  handleAutoScrollChange(e) {
    this.autoScroll = e.target.checked, this.autoScroll && this.logsContainer && (this.logsContainer.scrollTop = this.logsContainer.scrollHeight);
  }
  clearLogs() {
    this.logs = [];
  }
  cleanup() {
    this.wsManager && (this.wsManager.disconnect(), this.wsManager = null), this.connected = !1;
  }
  formatTimestamp(e) {
    return new Date(e).toLocaleString();
  }
  renderLog(e) {
    return D`
      <div class="log-entry">
        <span class="log-timestamp">${this.formatTimestamp(e.timestamp)}</span>
        <span class="log-service" title="${e.service || "system"}">${e.service || "system"}</span>
        <span class="log-priority priority-${e.priority || "info"}">${(e.priority || "info").toUpperCase()}</span>
        <span class="log-message">${e.message}</span>
      </div>
    `;
  }
  render() {
    return D`
      <h1>${L("logs.title")}</h1>
      
      <div class="controls">
        <div class="filter-group">
          <input 
            class="filter-input" 
            type="text" 
            placeholder="${L("logs.filterServices")} (e.g., 'systemd', 'nginx')" 
            .value="${this.serviceFilter}"
            @input="${this.handleServiceFilterChange}"
          />
        </div>
        
        <div class="filter-group">
          <label for="priority">${L("logs.priority")}:</label>
          <select 
            id="priority" 
            class="priority-select" 
            .value="${this.priorityFilter}"
            @change="${this.handlePriorityChange}"
          >
            <option value="all">All</option>
            <option value="debug">Debug (7)</option>
            <option value="info">Info (6) and above</option>
            <option value="notice">Notice (5) and above</option>
            <option value="warning">Warning (4) and above</option>
            <option value="err">Error (3) and above</option>
            <option value="crit">Critical (2) and above</option>
            <option value="alert">Alert (1) and above</option>
            <option value="emerg">Emergency (0) only</option>
          </select>
        </div>
        
        <div class="filter-group">
          <input 
            class="filter-input" 
            type="text" 
            placeholder="${L("logs.since")} (e.g., '10 minutes ago', '1 hour ago')" 
            .value="${this.sinceFilter}"
            @input="${this.handleSinceFilterChange}"
          />
        </div>
        
        <div class="toggle-follow">
          <input 
            type="checkbox" 
            id="follow" 
            .checked="${this.follow}"
            @change="${this.handleFollowChange}"
          />
          <label for="follow">${L("logs.follow")}</label>
        </div>
        
        <div class="toggle-follow">
          <input 
            type="checkbox" 
            id="autoscroll" 
            .checked="${this.autoScroll}"
            @change="${this.handleAutoScrollChange}"
          />
          <label for="autoscroll">Auto-scroll</label>
        </div>
        
        <button @click="${this.clearLogs}" ?disabled="${this.logs.length === 0}">
          ${L("logs.clear")}
        </button>
        
        <div class="status-indicator">
          <div class="status-dot ${this.connected ? "connected" : ""}"></div>
          <span>${this.connected ? L("common.connected") : L("common.disconnected")}</span>
        </div>
      </div>
      
      <div class="logs-container">
        ${this.logs.length > 0 ? this.logs.map((e) => this.renderLog(e)) : D`<div class="empty-state">${L("logs.noLogs")}</div>`}
      </div>
    `;
  }
};
ja.styles = re`
    :host {
      display: block;
      padding: 16px;
      height: 100%;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }

    h1 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 300;
      flex-shrink: 0;
    }

    .controls {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      align-items: center;
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    .filter-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .filter-input {
      padding: 8px;
      border: 1px solid var(--vscode-border);
      background: var(--vscode-bg);
      color: var(--vscode-text);
      border-radius: 4px;
      font-size: 13px;
      min-width: 200px;
    }

    .priority-select {
      padding: 8px;
      border: 1px solid var(--vscode-border);
      background: var(--vscode-bg);
      color: var(--vscode-text);
      border-radius: 4px;
      font-size: 13px;
    }

    .toggle-follow {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }

    .toggle-follow input[type="checkbox"] {
      cursor: pointer;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--vscode-text-dim);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--vscode-error);
    }

    .status-dot.connected {
      background: var(--vscode-success);
    }

    .logs-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      background: var(--vscode-bg);
      border: 1px solid var(--vscode-border);
      border-radius: 4px;
      padding: 8px;
      font-family: var(--vscode-font-family-mono);
      font-size: 12px;
      min-height: 0; /* Important for flexbox overflow */
      position: relative;
    }

    .log-entry {
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 2px;
      display: grid;
      grid-template-columns: 160px 80px 100px 1fr;
      gap: 16px;
      align-items: start;
    }

    .log-entry:hover {
      background: var(--vscode-bg-light);
    }

    .log-timestamp {
      color: var(--vscode-text-dim);
      white-space: nowrap;
    }

    .log-service {
      color: var(--vscode-accent);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .log-priority {
      font-weight: 500;
      white-space: nowrap;
    }

    .priority-emerg,
    .priority-emergency,
    .priority-0 {
      color: var(--vscode-error);
      background: rgba(255, 0, 0, 0.1);
    }

    .priority-alert,
    .priority-1 {
      color: var(--vscode-error);
    }

    .priority-crit,
    .priority-critical,
    .priority-2 {
      color: var(--vscode-error);
    }

    .priority-err,
    .priority-error,
    .priority-3 {
      color: var(--error);
    }

    .priority-warning,
    .priority-4 {
      color: var(--warning);
    }

    .priority-notice,
    .priority-5 {
      color: var(--vscode-text);
    }

    .priority-info,
    .priority-6 {
      color: var(--vscode-text);
    }

    .priority-debug,
    .priority-7 {
      color: var(--vscode-text-dim);
    }

    .log-message {
      white-space: pre-wrap;
      word-break: break-word;
    }

    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--vscode-text-dim);
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      background: var(--vscode-accent);
      color: white;
    }

    button:hover {
      background: var(--vscode-accent-hover);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  `;
let Lt = ja;
js([
  B()
], Lt.prototype, "logs");
js([
  B()
], Lt.prototype, "serviceFilter");
js([
  B()
], Lt.prototype, "priorityFilter");
js([
  B()
], Lt.prototype, "sinceFilter");
js([
  B()
], Lt.prototype, "follow");
js([
  B()
], Lt.prototype, "connected");
js([
  B()
], Lt.prototype, "autoScroll");
customElements.define("logs-tab", Lt);
var Uh = { exports: {} };
(function(s, e) {
  (function(t, i) {
    s.exports = i();
  })(self, () => (() => {
    var t = { 4567: function(o, a, l) {
      var c = this && this.__decorate || function(b, y, w, k) {
        var C, x = arguments.length, S = x < 3 ? y : k === null ? k = Object.getOwnPropertyDescriptor(y, w) : k;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(b, y, w, k);
        else for (var T = b.length - 1; T >= 0; T--) (C = b[T]) && (S = (x < 3 ? C(S) : x > 3 ? C(y, w, S) : C(y, w)) || S);
        return x > 3 && S && Object.defineProperty(y, w, S), S;
      }, u = this && this.__param || function(b, y) {
        return function(w, k) {
          y(w, k, b);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.AccessibilityManager = void 0;
      const h = l(9042), f = l(6114), m = l(9924), _ = l(844), v = l(5596), d = l(4725), p = l(3656);
      let g = a.AccessibilityManager = class extends _.Disposable {
        constructor(b, y) {
          super(), this._terminal = b, this._renderService = y, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
          for (let w = 0; w < this._terminal.rows; w++) this._rowElements[w] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[w]);
          if (this._topBoundaryFocusListener = (w) => this._handleBoundaryFocus(w, 0), this._bottomBoundaryFocusListener = (w) => this._handleBoundaryFocus(w, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new m.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
          this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((w) => this._handleResize(w.rows))), this.register(this._terminal.onRender((w) => this._refreshRows(w.start, w.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((w) => this._handleChar(w))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab((w) => this._handleTab(w))), this.register(this._terminal.onKey((w) => this._handleKey(w.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new v.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, p.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, _.toDisposable)(() => {
            this._accessibilityContainer.remove(), this._rowElements.length = 0;
          }));
        }
        _handleTab(b) {
          for (let y = 0; y < b; y++) this._handleChar(" ");
        }
        _handleChar(b) {
          this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== b && (this._charsToAnnounce += b) : this._charsToAnnounce += b, b === `
` && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += h.tooMuchOutput)), f.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
            this._accessibilityContainer.appendChild(this._liveRegion);
          }, 0));
        }
        _clearLiveRegion() {
          this._liveRegion.textContent = "", this._liveRegionLineCount = 0, f.isMac && this._liveRegion.remove();
        }
        _handleKey(b) {
          this._clearLiveRegion(), new RegExp("\\p{Control}", "u").test(b) || this._charsToConsume.push(b);
        }
        _refreshRows(b, y) {
          this._liveRegionDebouncer.refresh(b, y, this._terminal.rows);
        }
        _renderRows(b, y) {
          const w = this._terminal.buffer, k = w.lines.length.toString();
          for (let C = b; C <= y; C++) {
            const x = w.translateBufferLineToString(w.ydisp + C, !0), S = (w.ydisp + C + 1).toString(), T = this._rowElements[C];
            T && (x.length === 0 ? T.innerText = "" : T.textContent = x, T.setAttribute("aria-posinset", S), T.setAttribute("aria-setsize", k));
          }
          this._announceCharacters();
        }
        _announceCharacters() {
          this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
        }
        _handleBoundaryFocus(b, y) {
          const w = b.target, k = this._rowElements[y === 0 ? 1 : this._rowElements.length - 2];
          if (w.getAttribute("aria-posinset") === (y === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || b.relatedTarget !== k) return;
          let C, x;
          if (y === 0 ? (C = w, x = this._rowElements.pop(), this._rowContainer.removeChild(x)) : (C = this._rowElements.shift(), x = w, this._rowContainer.removeChild(C)), C.removeEventListener("focus", this._topBoundaryFocusListener), x.removeEventListener("focus", this._bottomBoundaryFocusListener), y === 0) {
            const S = this._createAccessibilityTreeNode();
            this._rowElements.unshift(S), this._rowContainer.insertAdjacentElement("afterbegin", S);
          } else {
            const S = this._createAccessibilityTreeNode();
            this._rowElements.push(S), this._rowContainer.appendChild(S);
          }
          this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(y === 0 ? -1 : 1), this._rowElements[y === 0 ? 1 : this._rowElements.length - 2].focus(), b.preventDefault(), b.stopImmediatePropagation();
        }
        _handleResize(b) {
          this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
          for (let y = this._rowContainer.children.length; y < this._terminal.rows; y++) this._rowElements[y] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[y]);
          for (; this._rowElements.length > b; ) this._rowContainer.removeChild(this._rowElements.pop());
          this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
        }
        _createAccessibilityTreeNode() {
          const b = document.createElement("div");
          return b.setAttribute("role", "listitem"), b.tabIndex = -1, this._refreshRowDimensions(b), b;
        }
        _refreshRowsDimensions() {
          if (this._renderService.dimensions.css.cell.height) {
            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
            for (let b = 0; b < this._terminal.rows; b++) this._refreshRowDimensions(this._rowElements[b]);
          }
        }
        _refreshRowDimensions(b) {
          b.style.height = `${this._renderService.dimensions.css.cell.height}px`;
        }
      };
      a.AccessibilityManager = g = c([u(1, d.IRenderService)], g);
    }, 3614: (o, a) => {
      function l(f) {
        return f.replace(/\r?\n/g, "\r");
      }
      function c(f, m) {
        return m ? "\x1B[200~" + f + "\x1B[201~" : f;
      }
      function u(f, m, _, v) {
        f = c(f = l(f), _.decPrivateModes.bracketedPasteMode && v.rawOptions.ignoreBracketedPasteMode !== !0), _.triggerDataEvent(f, !0), m.value = "";
      }
      function h(f, m, _) {
        const v = _.getBoundingClientRect(), d = f.clientX - v.left - 10, p = f.clientY - v.top - 10;
        m.style.width = "20px", m.style.height = "20px", m.style.left = `${d}px`, m.style.top = `${p}px`, m.style.zIndex = "1000", m.focus();
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.rightClickHandler = a.moveTextAreaUnderMouseCursor = a.paste = a.handlePasteEvent = a.copyHandler = a.bracketTextForPaste = a.prepareTextForTerminal = void 0, a.prepareTextForTerminal = l, a.bracketTextForPaste = c, a.copyHandler = function(f, m) {
        f.clipboardData && f.clipboardData.setData("text/plain", m.selectionText), f.preventDefault();
      }, a.handlePasteEvent = function(f, m, _, v) {
        f.stopPropagation(), f.clipboardData && u(f.clipboardData.getData("text/plain"), m, _, v);
      }, a.paste = u, a.moveTextAreaUnderMouseCursor = h, a.rightClickHandler = function(f, m, _, v, d) {
        h(f, m, _), d && v.rightClickSelect(f), m.value = v.selectionText, m.select();
      };
    }, 7239: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorContrastCache = void 0;
      const c = l(1505);
      a.ColorContrastCache = class {
        constructor() {
          this._color = new c.TwoKeyMap(), this._css = new c.TwoKeyMap();
        }
        setCss(u, h, f) {
          this._css.set(u, h, f);
        }
        getCss(u, h) {
          return this._css.get(u, h);
        }
        setColor(u, h, f) {
          this._color.set(u, h, f);
        }
        getColor(u, h) {
          return this._color.get(u, h);
        }
        clear() {
          this._color.clear(), this._css.clear();
        }
      };
    }, 3656: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.addDisposableDomListener = void 0, a.addDisposableDomListener = function(l, c, u, h) {
        l.addEventListener(c, u, h);
        let f = !1;
        return { dispose: () => {
          f || (f = !0, l.removeEventListener(c, u, h));
        } };
      };
    }, 6465: function(o, a, l) {
      var c = this && this.__decorate || function(d, p, g, b) {
        var y, w = arguments.length, k = w < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, g) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(d, p, g, b);
        else for (var C = d.length - 1; C >= 0; C--) (y = d[C]) && (k = (w < 3 ? y(k) : w > 3 ? y(p, g, k) : y(p, g)) || k);
        return w > 3 && k && Object.defineProperty(p, g, k), k;
      }, u = this && this.__param || function(d, p) {
        return function(g, b) {
          p(g, b, d);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Linkifier2 = void 0;
      const h = l(3656), f = l(8460), m = l(844), _ = l(2585);
      let v = a.Linkifier2 = class extends m.Disposable {
        get currentLink() {
          return this._currentLink;
        }
        constructor(d) {
          super(), this._bufferService = d, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new f.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new f.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, m.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, m.toDisposable)(() => {
            this._lastMouseEvent = void 0;
          })), this.register(this._bufferService.onResize(() => {
            this._clearCurrentLink(), this._wasResized = !0;
          }));
        }
        registerLinkProvider(d) {
          return this._linkProviders.push(d), { dispose: () => {
            const p = this._linkProviders.indexOf(d);
            p !== -1 && this._linkProviders.splice(p, 1);
          } };
        }
        attachToDom(d, p, g) {
          this._element = d, this._mouseService = p, this._renderService = g, this.register((0, h.addDisposableDomListener)(this._element, "mouseleave", () => {
            this._isMouseOut = !0, this._clearCurrentLink();
          })), this.register((0, h.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
        }
        _handleMouseMove(d) {
          if (this._lastMouseEvent = d, !this._element || !this._mouseService) return;
          const p = this._positionFromMouseEvent(d, this._element, this._mouseService);
          if (!p) return;
          this._isMouseOut = !1;
          const g = d.composedPath();
          for (let b = 0; b < g.length; b++) {
            const y = g[b];
            if (y.classList.contains("xterm")) break;
            if (y.classList.contains("xterm-hover")) return;
          }
          this._lastBufferCell && p.x === this._lastBufferCell.x && p.y === this._lastBufferCell.y || (this._handleHover(p), this._lastBufferCell = p);
        }
        _handleHover(d) {
          if (this._activeLine !== d.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(d, !1), void (this._wasResized = !1);
          this._currentLink && this._linkAtPosition(this._currentLink.link, d) || (this._clearCurrentLink(), this._askForLink(d, !0));
        }
        _askForLink(d, p) {
          var g, b;
          this._activeProviderReplies && p || ((g = this._activeProviderReplies) === null || g === void 0 || g.forEach((w) => {
            w == null || w.forEach((k) => {
              k.link.dispose && k.link.dispose();
            });
          }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = d.y);
          let y = !1;
          for (const [w, k] of this._linkProviders.entries()) p ? !((b = this._activeProviderReplies) === null || b === void 0) && b.get(w) && (y = this._checkLinkProviderResult(w, d, y)) : k.provideLinks(d.y, (C) => {
            var x, S;
            if (this._isMouseOut) return;
            const T = C == null ? void 0 : C.map((M) => ({ link: M }));
            (x = this._activeProviderReplies) === null || x === void 0 || x.set(w, T), y = this._checkLinkProviderResult(w, d, y), ((S = this._activeProviderReplies) === null || S === void 0 ? void 0 : S.size) === this._linkProviders.length && this._removeIntersectingLinks(d.y, this._activeProviderReplies);
          });
        }
        _removeIntersectingLinks(d, p) {
          const g = /* @__PURE__ */ new Set();
          for (let b = 0; b < p.size; b++) {
            const y = p.get(b);
            if (y) for (let w = 0; w < y.length; w++) {
              const k = y[w], C = k.link.range.start.y < d ? 0 : k.link.range.start.x, x = k.link.range.end.y > d ? this._bufferService.cols : k.link.range.end.x;
              for (let S = C; S <= x; S++) {
                if (g.has(S)) {
                  y.splice(w--, 1);
                  break;
                }
                g.add(S);
              }
            }
          }
        }
        _checkLinkProviderResult(d, p, g) {
          var b;
          if (!this._activeProviderReplies) return g;
          const y = this._activeProviderReplies.get(d);
          let w = !1;
          for (let k = 0; k < d; k++) this._activeProviderReplies.has(k) && !this._activeProviderReplies.get(k) || (w = !0);
          if (!w && y) {
            const k = y.find((C) => this._linkAtPosition(C.link, p));
            k && (g = !0, this._handleNewLink(k));
          }
          if (this._activeProviderReplies.size === this._linkProviders.length && !g) for (let k = 0; k < this._activeProviderReplies.size; k++) {
            const C = (b = this._activeProviderReplies.get(k)) === null || b === void 0 ? void 0 : b.find((x) => this._linkAtPosition(x.link, p));
            if (C) {
              g = !0, this._handleNewLink(C);
              break;
            }
          }
          return g;
        }
        _handleMouseDown() {
          this._mouseDownLink = this._currentLink;
        }
        _handleMouseUp(d) {
          if (!this._element || !this._mouseService || !this._currentLink) return;
          const p = this._positionFromMouseEvent(d, this._element, this._mouseService);
          p && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, p) && this._currentLink.link.activate(d, this._currentLink.link.text);
        }
        _clearCurrentLink(d, p) {
          this._element && this._currentLink && this._lastMouseEvent && (!d || !p || this._currentLink.link.range.start.y >= d && this._currentLink.link.range.end.y <= p) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, m.disposeArray)(this._linkCacheDisposables));
        }
        _handleNewLink(d) {
          if (!this._element || !this._lastMouseEvent || !this._mouseService) return;
          const p = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
          p && this._linkAtPosition(d.link, p) && (this._currentLink = d, this._currentLink.state = { decorations: { underline: d.link.decorations === void 0 || d.link.decorations.underline, pointerCursor: d.link.decorations === void 0 || d.link.decorations.pointerCursor }, isHovered: !0 }, this._linkHover(this._element, d.link, this._lastMouseEvent), d.link.decorations = {}, Object.defineProperties(d.link.decorations, { pointerCursor: { get: () => {
            var g, b;
            return (b = (g = this._currentLink) === null || g === void 0 ? void 0 : g.state) === null || b === void 0 ? void 0 : b.decorations.pointerCursor;
          }, set: (g) => {
            var b, y;
            !((b = this._currentLink) === null || b === void 0) && b.state && this._currentLink.state.decorations.pointerCursor !== g && (this._currentLink.state.decorations.pointerCursor = g, this._currentLink.state.isHovered && ((y = this._element) === null || y === void 0 || y.classList.toggle("xterm-cursor-pointer", g)));
          } }, underline: { get: () => {
            var g, b;
            return (b = (g = this._currentLink) === null || g === void 0 ? void 0 : g.state) === null || b === void 0 ? void 0 : b.decorations.underline;
          }, set: (g) => {
            var b, y, w;
            !((b = this._currentLink) === null || b === void 0) && b.state && ((w = (y = this._currentLink) === null || y === void 0 ? void 0 : y.state) === null || w === void 0 ? void 0 : w.decorations.underline) !== g && (this._currentLink.state.decorations.underline = g, this._currentLink.state.isHovered && this._fireUnderlineEvent(d.link, g));
          } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((g) => {
            if (!this._currentLink) return;
            const b = g.start === 0 ? 0 : g.start + 1 + this._bufferService.buffer.ydisp, y = this._bufferService.buffer.ydisp + 1 + g.end;
            if (this._currentLink.link.range.start.y >= b && this._currentLink.link.range.end.y <= y && (this._clearCurrentLink(b, y), this._lastMouseEvent && this._element)) {
              const w = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              w && this._askForLink(w, !1);
            }
          })));
        }
        _linkHover(d, p, g) {
          var b;
          !((b = this._currentLink) === null || b === void 0) && b.state && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(p, !0), this._currentLink.state.decorations.pointerCursor && d.classList.add("xterm-cursor-pointer")), p.hover && p.hover(g, p.text);
        }
        _fireUnderlineEvent(d, p) {
          const g = d.range, b = this._bufferService.buffer.ydisp, y = this._createLinkUnderlineEvent(g.start.x - 1, g.start.y - b - 1, g.end.x, g.end.y - b - 1, void 0);
          (p ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(y);
        }
        _linkLeave(d, p, g) {
          var b;
          !((b = this._currentLink) === null || b === void 0) && b.state && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(p, !1), this._currentLink.state.decorations.pointerCursor && d.classList.remove("xterm-cursor-pointer")), p.leave && p.leave(g, p.text);
        }
        _linkAtPosition(d, p) {
          const g = d.range.start.y * this._bufferService.cols + d.range.start.x, b = d.range.end.y * this._bufferService.cols + d.range.end.x, y = p.y * this._bufferService.cols + p.x;
          return g <= y && y <= b;
        }
        _positionFromMouseEvent(d, p, g) {
          const b = g.getCoords(d, p, this._bufferService.cols, this._bufferService.rows);
          if (b) return { x: b[0], y: b[1] + this._bufferService.buffer.ydisp };
        }
        _createLinkUnderlineEvent(d, p, g, b, y) {
          return { x1: d, y1: p, x2: g, y2: b, cols: this._bufferService.cols, fg: y };
        }
      };
      a.Linkifier2 = v = c([u(0, _.IBufferService)], v);
    }, 9042: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.tooMuchOutput = a.promptLabel = void 0, a.promptLabel = "Terminal input", a.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
    }, 3730: function(o, a, l) {
      var c = this && this.__decorate || function(v, d, p, g) {
        var b, y = arguments.length, w = y < 3 ? d : g === null ? g = Object.getOwnPropertyDescriptor(d, p) : g;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(v, d, p, g);
        else for (var k = v.length - 1; k >= 0; k--) (b = v[k]) && (w = (y < 3 ? b(w) : y > 3 ? b(d, p, w) : b(d, p)) || w);
        return y > 3 && w && Object.defineProperty(d, p, w), w;
      }, u = this && this.__param || function(v, d) {
        return function(p, g) {
          d(p, g, v);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkProvider = void 0;
      const h = l(511), f = l(2585);
      let m = a.OscLinkProvider = class {
        constructor(v, d, p) {
          this._bufferService = v, this._optionsService = d, this._oscLinkService = p;
        }
        provideLinks(v, d) {
          var p;
          const g = this._bufferService.buffer.lines.get(v - 1);
          if (!g) return void d(void 0);
          const b = [], y = this._optionsService.rawOptions.linkHandler, w = new h.CellData(), k = g.getTrimmedLength();
          let C = -1, x = -1, S = !1;
          for (let T = 0; T < k; T++) if (x !== -1 || g.hasContent(T)) {
            if (g.loadCell(T, w), w.hasExtendedAttrs() && w.extended.urlId) {
              if (x === -1) {
                x = T, C = w.extended.urlId;
                continue;
              }
              S = w.extended.urlId !== C;
            } else x !== -1 && (S = !0);
            if (S || x !== -1 && T === k - 1) {
              const M = (p = this._oscLinkService.getLinkData(C)) === null || p === void 0 ? void 0 : p.uri;
              if (M) {
                const E = { start: { x: x + 1, y: v }, end: { x: T + (S || T !== k - 1 ? 0 : 1), y: v } };
                let R = !1;
                if (!(y != null && y.allowNonHttpProtocols)) try {
                  const z = new URL(M);
                  ["http:", "https:"].includes(z.protocol) || (R = !0);
                } catch {
                  R = !0;
                }
                R || b.push({ text: M, range: E, activate: (z, F) => y ? y.activate(z, F, E) : _(0, F), hover: (z, F) => {
                  var j;
                  return (j = y == null ? void 0 : y.hover) === null || j === void 0 ? void 0 : j.call(y, z, F, E);
                }, leave: (z, F) => {
                  var j;
                  return (j = y == null ? void 0 : y.leave) === null || j === void 0 ? void 0 : j.call(y, z, F, E);
                } });
              }
              S = !1, w.hasExtendedAttrs() && w.extended.urlId ? (x = T, C = w.extended.urlId) : (x = -1, C = -1);
            }
          }
          d(b);
        }
      };
      function _(v, d) {
        if (confirm(`Do you want to navigate to ${d}?

WARNING: This link could potentially be dangerous`)) {
          const p = window.open();
          if (p) {
            try {
              p.opener = null;
            } catch {
            }
            p.location.href = d;
          } else console.warn("Opening link blocked as opener could not be cleared");
        }
      }
      a.OscLinkProvider = m = c([u(0, f.IBufferService), u(1, f.IOptionsService), u(2, f.IOscLinkService)], m);
    }, 6193: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderDebouncer = void 0, a.RenderDebouncer = class {
        constructor(l, c) {
          this._parentWindow = l, this._renderCallback = c, this._refreshCallbacks = [];
        }
        dispose() {
          this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
        }
        addRefreshCallback(l) {
          return this._refreshCallbacks.push(l), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
        }
        refresh(l, c, u) {
          this._rowCount = u, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return void this._runRefreshCallbacks();
          const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c), this._runRefreshCallbacks();
        }
        _runRefreshCallbacks() {
          for (const l of this._refreshCallbacks) l(0);
          this._refreshCallbacks = [];
        }
      };
    }, 5596: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ScreenDprMonitor = void 0;
      const c = l(844);
      class u extends c.Disposable {
        constructor(f) {
          super(), this._parentWindow = f, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, c.toDisposable)(() => {
            this.clearListener();
          }));
        }
        setListener(f) {
          this._listener && this.clearListener(), this._listener = f, this._outerListener = () => {
            this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
          }, this._updateDpr();
        }
        _updateDpr() {
          var f;
          this._outerListener && ((f = this._resolutionMediaMatchList) === null || f === void 0 || f.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
        }
        clearListener() {
          this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
        }
      }
      a.ScreenDprMonitor = u;
    }, 3236: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Terminal = void 0;
      const c = l(3614), u = l(3656), h = l(6465), f = l(9042), m = l(3730), _ = l(1680), v = l(3107), d = l(5744), p = l(2950), g = l(1296), b = l(428), y = l(4269), w = l(5114), k = l(8934), C = l(3230), x = l(9312), S = l(4725), T = l(6731), M = l(8055), E = l(8969), R = l(8460), z = l(844), F = l(6114), j = l(8437), U = l(2584), $ = l(7399), I = l(5941), O = l(9074), P = l(2585), q = l(5435), Q = l(4567), X = typeof window < "u" ? window.document : null;
      class G extends E.CoreTerminal {
        get onFocus() {
          return this._onFocus.event;
        }
        get onBlur() {
          return this._onBlur.event;
        }
        get onA11yChar() {
          return this._onA11yCharEmitter.event;
        }
        get onA11yTab() {
          return this._onA11yTabEmitter.event;
        }
        get onWillOpen() {
          return this._onWillOpen.event;
        }
        constructor(A = {}) {
          super(A), this.browser = F, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._accessibilityManager = this.register(new z.MutableDisposable()), this._onCursorMove = this.register(new R.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new R.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new R.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new R.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new R.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new R.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new R.EventEmitter()), this._onBlur = this.register(new R.EventEmitter()), this._onA11yCharEmitter = this.register(new R.EventEmitter()), this._onA11yTabEmitter = this.register(new R.EventEmitter()), this._onWillOpen = this.register(new R.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(h.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(m.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(O.DecorationService), this._instantiationService.setService(P.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((N, V) => this.refresh(N, V))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((N) => this._reportWindowsOptions(N))), this.register(this._inputHandler.onColor((N) => this._handleColorEvent(N))), this.register((0, R.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, R.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, R.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, R.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((N) => this._afterResize(N.cols, N.rows))), this.register((0, z.toDisposable)(() => {
            var N, V;
            this._customKeyEventHandler = void 0, (V = (N = this.element) === null || N === void 0 ? void 0 : N.parentNode) === null || V === void 0 || V.removeChild(this.element);
          }));
        }
        _handleColorEvent(A) {
          if (this._themeService) for (const N of A) {
            let V, W = "";
            switch (N.index) {
              case 256:
                V = "foreground", W = "10";
                break;
              case 257:
                V = "background", W = "11";
                break;
              case 258:
                V = "cursor", W = "12";
                break;
              default:
                V = "ansi", W = "4;" + N.index;
            }
            switch (N.type) {
              case 0:
                const ie = M.color.toColorRGB(V === "ansi" ? this._themeService.colors.ansi[N.index] : this._themeService.colors[V]);
                this.coreService.triggerDataEvent(`${U.C0.ESC}]${W};${(0, I.toRgbString)(ie)}${U.C1_ESCAPED.ST}`);
                break;
              case 1:
                if (V === "ansi") this._themeService.modifyColors((Y) => Y.ansi[N.index] = M.rgba.toColor(...N.color));
                else {
                  const Y = V;
                  this._themeService.modifyColors((de) => de[Y] = M.rgba.toColor(...N.color));
                }
                break;
              case 2:
                this._themeService.restoreColor(N.index);
            }
          }
        }
        _setup() {
          super._setup(), this._customKeyEventHandler = void 0;
        }
        get buffer() {
          return this.buffers.active;
        }
        focus() {
          this.textarea && this.textarea.focus({ preventScroll: !0 });
        }
        _handleScreenReaderModeOptionChange(A) {
          A ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(Q.AccessibilityManager, this)) : this._accessibilityManager.clear();
        }
        _handleTextAreaFocus(A) {
          this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(U.C0.ESC + "[I"), this.updateCursorStyle(A), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
        }
        blur() {
          var A;
          return (A = this.textarea) === null || A === void 0 ? void 0 : A.blur();
        }
        _handleTextAreaBlur() {
          this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(U.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
        }
        _syncTextArea() {
          if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
          const A = this.buffer.ybase + this.buffer.y, N = this.buffer.lines.get(A);
          if (!N) return;
          const V = Math.min(this.buffer.x, this.cols - 1), W = this._renderService.dimensions.css.cell.height, ie = N.getWidth(V), Y = this._renderService.dimensions.css.cell.width * ie, de = this.buffer.y * this._renderService.dimensions.css.cell.height, He = V * this._renderService.dimensions.css.cell.width;
          this.textarea.style.left = He + "px", this.textarea.style.top = de + "px", this.textarea.style.width = Y + "px", this.textarea.style.height = W + "px", this.textarea.style.lineHeight = W + "px", this.textarea.style.zIndex = "-5";
        }
        _initGlobal() {
          this._bindKeys(), this.register((0, u.addDisposableDomListener)(this.element, "copy", (N) => {
            this.hasSelection() && (0, c.copyHandler)(N, this._selectionService);
          }));
          const A = (N) => (0, c.handlePasteEvent)(N, this.textarea, this.coreService, this.optionsService);
          this.register((0, u.addDisposableDomListener)(this.textarea, "paste", A)), this.register((0, u.addDisposableDomListener)(this.element, "paste", A)), F.isFirefox ? this.register((0, u.addDisposableDomListener)(this.element, "mousedown", (N) => {
            N.button === 2 && (0, c.rightClickHandler)(N, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })) : this.register((0, u.addDisposableDomListener)(this.element, "contextmenu", (N) => {
            (0, c.rightClickHandler)(N, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })), F.isLinux && this.register((0, u.addDisposableDomListener)(this.element, "auxclick", (N) => {
            N.button === 1 && (0, c.moveTextAreaUnderMouseCursor)(N, this.textarea, this.screenElement);
          }));
        }
        _bindKeys() {
          this.register((0, u.addDisposableDomListener)(this.textarea, "keyup", (A) => this._keyUp(A), !0)), this.register((0, u.addDisposableDomListener)(this.textarea, "keydown", (A) => this._keyDown(A), !0)), this.register((0, u.addDisposableDomListener)(this.textarea, "keypress", (A) => this._keyPress(A), !0)), this.register((0, u.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, u.addDisposableDomListener)(this.textarea, "compositionupdate", (A) => this._compositionHelper.compositionupdate(A))), this.register((0, u.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, u.addDisposableDomListener)(this.textarea, "input", (A) => this._inputEvent(A), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
        }
        open(A) {
          var N;
          if (!A) throw new Error("Terminal requires a parent element.");
          A.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = A.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), A.appendChild(this.element);
          const V = X.createDocumentFragment();
          this._viewportElement = X.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), V.appendChild(this._viewportElement), this._viewportScrollArea = X.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = X.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = X.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), V.appendChild(this.screenElement), this.textarea = X.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", f.promptLabel), F.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(w.CoreBrowserService, this.textarea, (N = this._document.defaultView) !== null && N !== void 0 ? N : window), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, u.addDisposableDomListener)(this.textarea, "focus", (W) => this._handleTextAreaFocus(W))), this.register((0, u.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(b.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(T.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(y.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(C.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((W) => this._onRender.fire(W))), this.onResize((W) => this._renderService.resize(W.cols, W.rows)), this._compositionView = X.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(p.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(V);
          try {
            this._onWillOpen.fire(this.element);
          } catch {
          }
          this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(k.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(_.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((W) => this.scrollLines(W.amount, W.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
            this._renderService.handleCursorMove(), this._syncTextArea();
          })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(x.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((W) => this.scrollLines(W.amount, W.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((W) => this._renderService.handleSelectionChanged(W.start, W.end, W.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((W) => {
            this.textarea.value = W, this.textarea.focus(), this.textarea.select();
          })), this.register(this._onScroll.event((W) => {
            this.viewport.syncScrollArea(), this._selectionService.refresh();
          })), this.register((0, u.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(v.BufferDecorationRenderer, this.screenElement)), this.register((0, u.addDisposableDomListener)(this.element, "mousedown", (W) => this._selectionService.handleMouseDown(W))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(Q.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (W) => this._handleScreenReaderModeOptionChange(W))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(d.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (W) => {
            !this._overviewRulerRenderer && W && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(d.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
          }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
        }
        _createRenderer() {
          return this._instantiationService.createInstance(g.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
        }
        bindMouse() {
          const A = this, N = this.element;
          function V(Y) {
            const de = A._mouseService.getMouseReportCoords(Y, A.screenElement);
            if (!de) return !1;
            let He, it;
            switch (Y.overrideType || Y.type) {
              case "mousemove":
                it = 32, Y.buttons === void 0 ? (He = 3, Y.button !== void 0 && (He = Y.button < 3 ? Y.button : 3)) : He = 1 & Y.buttons ? 0 : 4 & Y.buttons ? 1 : 2 & Y.buttons ? 2 : 3;
                break;
              case "mouseup":
                it = 0, He = Y.button < 3 ? Y.button : 3;
                break;
              case "mousedown":
                it = 1, He = Y.button < 3 ? Y.button : 3;
                break;
              case "wheel":
                if (A.viewport.getLinesScrolled(Y) === 0) return !1;
                it = Y.deltaY < 0 ? 0 : 1, He = 4;
                break;
              default:
                return !1;
            }
            return !(it === void 0 || He === void 0 || He > 4) && A.coreMouseService.triggerMouseEvent({ col: de.col, row: de.row, x: de.x, y: de.y, button: He, action: it, ctrl: Y.ctrlKey, alt: Y.altKey, shift: Y.shiftKey });
          }
          const W = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, ie = { mouseup: (Y) => (V(Y), Y.buttons || (this._document.removeEventListener("mouseup", W.mouseup), W.mousedrag && this._document.removeEventListener("mousemove", W.mousedrag)), this.cancel(Y)), wheel: (Y) => (V(Y), this.cancel(Y, !0)), mousedrag: (Y) => {
            Y.buttons && V(Y);
          }, mousemove: (Y) => {
            Y.buttons || V(Y);
          } };
          this.register(this.coreMouseService.onProtocolChange((Y) => {
            Y ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(Y)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & Y ? W.mousemove || (N.addEventListener("mousemove", ie.mousemove), W.mousemove = ie.mousemove) : (N.removeEventListener("mousemove", W.mousemove), W.mousemove = null), 16 & Y ? W.wheel || (N.addEventListener("wheel", ie.wheel, { passive: !1 }), W.wheel = ie.wheel) : (N.removeEventListener("wheel", W.wheel), W.wheel = null), 2 & Y ? W.mouseup || (N.addEventListener("mouseup", ie.mouseup), W.mouseup = ie.mouseup) : (this._document.removeEventListener("mouseup", W.mouseup), N.removeEventListener("mouseup", W.mouseup), W.mouseup = null), 4 & Y ? W.mousedrag || (W.mousedrag = ie.mousedrag) : (this._document.removeEventListener("mousemove", W.mousedrag), W.mousedrag = null);
          })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, u.addDisposableDomListener)(N, "mousedown", (Y) => {
            if (Y.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(Y)) return V(Y), W.mouseup && this._document.addEventListener("mouseup", W.mouseup), W.mousedrag && this._document.addEventListener("mousemove", W.mousedrag), this.cancel(Y);
          })), this.register((0, u.addDisposableDomListener)(N, "wheel", (Y) => {
            if (!W.wheel) {
              if (!this.buffer.hasScrollback) {
                const de = this.viewport.getLinesScrolled(Y);
                if (de === 0) return;
                const He = U.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (Y.deltaY < 0 ? "A" : "B");
                let it = "";
                for (let qs = 0; qs < Math.abs(de); qs++) it += He;
                return this.coreService.triggerDataEvent(it, !0), this.cancel(Y, !0);
              }
              return this.viewport.handleWheel(Y) ? this.cancel(Y) : void 0;
            }
          }, { passive: !1 })), this.register((0, u.addDisposableDomListener)(N, "touchstart", (Y) => {
            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(Y), this.cancel(Y);
          }, { passive: !0 })), this.register((0, u.addDisposableDomListener)(N, "touchmove", (Y) => {
            if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(Y) ? void 0 : this.cancel(Y);
          }, { passive: !1 }));
        }
        refresh(A, N) {
          var V;
          (V = this._renderService) === null || V === void 0 || V.refreshRows(A, N);
        }
        updateCursorStyle(A) {
          var N;
          !((N = this._selectionService) === null || N === void 0) && N.shouldColumnSelect(A) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
        }
        _showCursor() {
          this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));
        }
        scrollLines(A, N, V = 0) {
          var W;
          V === 1 ? (super.scrollLines(A, N, V), this.refresh(0, this.rows - 1)) : (W = this.viewport) === null || W === void 0 || W.scrollLines(A);
        }
        paste(A) {
          (0, c.paste)(A, this.textarea, this.coreService, this.optionsService);
        }
        attachCustomKeyEventHandler(A) {
          this._customKeyEventHandler = A;
        }
        registerLinkProvider(A) {
          return this.linkifier2.registerLinkProvider(A);
        }
        registerCharacterJoiner(A) {
          if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
          const N = this._characterJoinerService.register(A);
          return this.refresh(0, this.rows - 1), N;
        }
        deregisterCharacterJoiner(A) {
          if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
          this._characterJoinerService.deregister(A) && this.refresh(0, this.rows - 1);
        }
        get markers() {
          return this.buffer.markers;
        }
        registerMarker(A) {
          return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + A);
        }
        registerDecoration(A) {
          return this._decorationService.registerDecoration(A);
        }
        hasSelection() {
          return !!this._selectionService && this._selectionService.hasSelection;
        }
        select(A, N, V) {
          this._selectionService.setSelection(A, N, V);
        }
        getSelection() {
          return this._selectionService ? this._selectionService.selectionText : "";
        }
        getSelectionPosition() {
          if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
        }
        clearSelection() {
          var A;
          (A = this._selectionService) === null || A === void 0 || A.clearSelection();
        }
        selectAll() {
          var A;
          (A = this._selectionService) === null || A === void 0 || A.selectAll();
        }
        selectLines(A, N) {
          var V;
          (V = this._selectionService) === null || V === void 0 || V.selectLines(A, N);
        }
        _keyDown(A) {
          if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && this._customKeyEventHandler(A) === !1) return !1;
          const N = this.browser.isMac && this.options.macOptionIsMeta && A.altKey;
          if (!N && !this._compositionHelper.keydown(A)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), !1;
          N || A.key !== "Dead" && A.key !== "AltGraph" || (this._unprocessedDeadKey = !0);
          const V = (0, $.evaluateKeyboardEvent)(A, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
          if (this.updateCursorStyle(A), V.type === 3 || V.type === 2) {
            const W = this.rows - 1;
            return this.scrollLines(V.type === 2 ? -W : W), this.cancel(A, !0);
          }
          return V.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, A) || (V.cancel && this.cancel(A, !0), !V.key || !!(A.key && !A.ctrlKey && !A.altKey && !A.metaKey && A.key.length === 1 && A.key.charCodeAt(0) >= 65 && A.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (V.key !== U.C0.ETX && V.key !== U.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: V.key, domEvent: A }), this._showCursor(), this.coreService.triggerDataEvent(V.key, !0), !this.optionsService.rawOptions.screenReaderMode || A.altKey || A.ctrlKey ? this.cancel(A, !0) : void (this._keyDownHandled = !0))));
        }
        _isThirdLevelShift(A, N) {
          const V = A.isMac && !this.options.macOptionIsMeta && N.altKey && !N.ctrlKey && !N.metaKey || A.isWindows && N.altKey && N.ctrlKey && !N.metaKey || A.isWindows && N.getModifierState("AltGraph");
          return N.type === "keypress" ? V : V && (!N.keyCode || N.keyCode > 47);
        }
        _keyUp(A) {
          this._keyDownSeen = !1, this._customKeyEventHandler && this._customKeyEventHandler(A) === !1 || (function(N) {
            return N.keyCode === 16 || N.keyCode === 17 || N.keyCode === 18;
          }(A) || this.focus(), this.updateCursorStyle(A), this._keyPressHandled = !1);
        }
        _keyPress(A) {
          let N;
          if (this._keyPressHandled = !1, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(A) === !1) return !1;
          if (this.cancel(A), A.charCode) N = A.charCode;
          else if (A.which === null || A.which === void 0) N = A.keyCode;
          else {
            if (A.which === 0 || A.charCode === 0) return !1;
            N = A.which;
          }
          return !(!N || (A.altKey || A.ctrlKey || A.metaKey) && !this._isThirdLevelShift(this.browser, A) || (N = String.fromCharCode(N), this._onKey.fire({ key: N, domEvent: A }), this._showCursor(), this.coreService.triggerDataEvent(N, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));
        }
        _inputEvent(A) {
          if (A.data && A.inputType === "insertText" && (!A.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
            if (this._keyPressHandled) return !1;
            this._unprocessedDeadKey = !1;
            const N = A.data;
            return this.coreService.triggerDataEvent(N, !0), this.cancel(A), !0;
          }
          return !1;
        }
        resize(A, N) {
          A !== this.cols || N !== this.rows ? super.resize(A, N) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
        }
        _afterResize(A, N) {
          var V, W;
          (V = this._charSizeService) === null || V === void 0 || V.measure(), (W = this.viewport) === null || W === void 0 || W.syncScrollArea(!0);
        }
        clear() {
          var A;
          if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
            this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
            for (let N = 1; N < this.rows; N++) this.buffer.lines.push(this.buffer.getBlankLine(j.DEFAULT_ATTR_DATA));
            this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), (A = this.viewport) === null || A === void 0 || A.reset(), this.refresh(0, this.rows - 1);
          }
        }
        reset() {
          var A, N;
          this.options.rows = this.rows, this.options.cols = this.cols;
          const V = this._customKeyEventHandler;
          this._setup(), super.reset(), (A = this._selectionService) === null || A === void 0 || A.reset(), this._decorationService.reset(), (N = this.viewport) === null || N === void 0 || N.reset(), this._customKeyEventHandler = V, this.refresh(0, this.rows - 1);
        }
        clearTextureAtlas() {
          var A;
          (A = this._renderService) === null || A === void 0 || A.clearTextureAtlas();
        }
        _reportFocus() {
          var A;
          !((A = this.element) === null || A === void 0) && A.classList.contains("focus") ? this.coreService.triggerDataEvent(U.C0.ESC + "[I") : this.coreService.triggerDataEvent(U.C0.ESC + "[O");
        }
        _reportWindowsOptions(A) {
          if (this._renderService) switch (A) {
            case q.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
              const N = this._renderService.dimensions.css.canvas.width.toFixed(0), V = this._renderService.dimensions.css.canvas.height.toFixed(0);
              this.coreService.triggerDataEvent(`${U.C0.ESC}[4;${V};${N}t`);
              break;
            case q.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
              const W = this._renderService.dimensions.css.cell.width.toFixed(0), ie = this._renderService.dimensions.css.cell.height.toFixed(0);
              this.coreService.triggerDataEvent(`${U.C0.ESC}[6;${ie};${W}t`);
          }
        }
        cancel(A, N) {
          if (this.options.cancelEvents || N) return A.preventDefault(), A.stopPropagation(), !1;
        }
      }
      a.Terminal = G;
    }, 9924: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.TimeBasedDebouncer = void 0, a.TimeBasedDebouncer = class {
        constructor(l, c = 1e3) {
          this._renderCallback = l, this._debounceThresholdMS = c, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;
        }
        dispose() {
          this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
        }
        refresh(l, c, u) {
          this._rowCount = u, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, l) : l, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c;
          const h = Date.now();
          if (h - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = h, this._innerRefresh();
          else if (!this._additionalRefreshRequested) {
            const f = h - this._lastRefreshMs, m = this._debounceThresholdMS - f;
            this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => {
              this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;
            }, m);
          }
        }
        _innerRefresh() {
          if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return;
          const l = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(l, c);
        }
      };
    }, 1680: function(o, a, l) {
      var c = this && this.__decorate || function(p, g, b, y) {
        var w, k = arguments.length, C = k < 3 ? g : y === null ? y = Object.getOwnPropertyDescriptor(g, b) : y;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") C = Reflect.decorate(p, g, b, y);
        else for (var x = p.length - 1; x >= 0; x--) (w = p[x]) && (C = (k < 3 ? w(C) : k > 3 ? w(g, b, C) : w(g, b)) || C);
        return k > 3 && C && Object.defineProperty(g, b, C), C;
      }, u = this && this.__param || function(p, g) {
        return function(b, y) {
          g(b, y, p);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Viewport = void 0;
      const h = l(3656), f = l(4725), m = l(8460), _ = l(844), v = l(2585);
      let d = a.Viewport = class extends _.Disposable {
        constructor(p, g, b, y, w, k, C, x) {
          super(), this._viewportElement = p, this._scrollArea = g, this._bufferService = b, this._optionsService = y, this._charSizeService = w, this._renderService = k, this._coreBrowserService = C, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new m.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, h.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((S) => this._activeBuffer = S.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((S) => this._renderDimensions = S)), this._handleThemeChange(x.colors), this.register(x.onChangeColors((S) => this._handleThemeChange(S))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
        }
        _handleThemeChange(p) {
          this._viewportElement.style.backgroundColor = p.background.css;
        }
        reset() {
          this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
        }
        _refresh(p) {
          if (p) return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
          this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._charSizeService.height > 0) {
            this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            const g = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
            this._lastRecordedBufferHeight !== g && (this._lastRecordedBufferHeight = g, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
          }
          const p = this._bufferService.buffer.ydisp * this._currentRowHeight;
          this._viewportElement.scrollTop !== p && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = p), this._refreshAnimationFrame = null;
        }
        syncScrollArea(p = !1) {
          if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(p);
          this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(p);
        }
        _handleScroll(p) {
          if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
          if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: !0 });
          const g = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
          this._onRequestScrollLines.fire({ amount: g, suppressScrollEvent: !0 });
        }
        _smoothScroll() {
          if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1) return;
          const p = this._smoothScrollPercent();
          this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(p * (this._smoothScrollState.target - this._smoothScrollState.origin)), p < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
        }
        _smoothScrollPercent() {
          return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
        }
        _clearSmoothScrollState() {
          this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
        }
        _bubbleScroll(p, g) {
          const b = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
          return !(g < 0 && this._viewportElement.scrollTop !== 0 || g > 0 && b < this._lastRecordedBufferHeight) || (p.cancelable && p.preventDefault(), !1);
        }
        handleWheel(p) {
          const g = this._getPixelsScrolled(p);
          return g !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + g : this._smoothScrollState.target += g, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += g, this._bubbleScroll(p, g));
        }
        scrollLines(p) {
          if (p !== 0) if (this._optionsService.rawOptions.smoothScrollDuration) {
            const g = p * this._currentRowHeight;
            this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + g, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
          } else this._onRequestScrollLines.fire({ amount: p, suppressScrollEvent: !1 });
        }
        _getPixelsScrolled(p) {
          if (p.deltaY === 0 || p.shiftKey) return 0;
          let g = this._applyScrollModifier(p.deltaY, p);
          return p.deltaMode === WheelEvent.DOM_DELTA_LINE ? g *= this._currentRowHeight : p.deltaMode === WheelEvent.DOM_DELTA_PAGE && (g *= this._currentRowHeight * this._bufferService.rows), g;
        }
        getBufferElements(p, g) {
          var b;
          let y, w = "";
          const k = [], C = g ?? this._bufferService.buffer.lines.length, x = this._bufferService.buffer.lines;
          for (let S = p; S < C; S++) {
            const T = x.get(S);
            if (!T) continue;
            const M = (b = x.get(S + 1)) === null || b === void 0 ? void 0 : b.isWrapped;
            if (w += T.translateToString(!M), !M || S === x.length - 1) {
              const E = document.createElement("div");
              E.textContent = w, k.push(E), w.length > 0 && (y = E), w = "";
            }
          }
          return { bufferElements: k, cursorElement: y };
        }
        getLinesScrolled(p) {
          if (p.deltaY === 0 || p.shiftKey) return 0;
          let g = this._applyScrollModifier(p.deltaY, p);
          return p.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (g /= this._currentRowHeight + 0, this._wheelPartialScroll += g, g = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : p.deltaMode === WheelEvent.DOM_DELTA_PAGE && (g *= this._bufferService.rows), g;
        }
        _applyScrollModifier(p, g) {
          const b = this._optionsService.rawOptions.fastScrollModifier;
          return b === "alt" && g.altKey || b === "ctrl" && g.ctrlKey || b === "shift" && g.shiftKey ? p * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : p * this._optionsService.rawOptions.scrollSensitivity;
        }
        handleTouchStart(p) {
          this._lastTouchY = p.touches[0].pageY;
        }
        handleTouchMove(p) {
          const g = this._lastTouchY - p.touches[0].pageY;
          return this._lastTouchY = p.touches[0].pageY, g !== 0 && (this._viewportElement.scrollTop += g, this._bubbleScroll(p, g));
        }
      };
      a.Viewport = d = c([u(2, v.IBufferService), u(3, v.IOptionsService), u(4, f.ICharSizeService), u(5, f.IRenderService), u(6, f.ICoreBrowserService), u(7, f.IThemeService)], d);
    }, 3107: function(o, a, l) {
      var c = this && this.__decorate || function(d, p, g, b) {
        var y, w = arguments.length, k = w < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, g) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(d, p, g, b);
        else for (var C = d.length - 1; C >= 0; C--) (y = d[C]) && (k = (w < 3 ? y(k) : w > 3 ? y(p, g, k) : y(p, g)) || k);
        return w > 3 && k && Object.defineProperty(p, g, k), k;
      }, u = this && this.__param || function(d, p) {
        return function(g, b) {
          p(g, b, d);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferDecorationRenderer = void 0;
      const h = l(3656), f = l(4725), m = l(844), _ = l(2585);
      let v = a.BufferDecorationRenderer = class extends m.Disposable {
        constructor(d, p, g, b) {
          super(), this._screenElement = d, this._bufferService = p, this._decorationService = g, this._renderService = b, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
            this._dimensionsChanged = !0, this._queueRefresh();
          })), this.register((0, h.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
          })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((y) => this._removeDecoration(y))), this.register((0, m.toDisposable)(() => {
            this._container.remove(), this._decorationElements.clear();
          }));
        }
        _queueRefresh() {
          this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => {
            this._doRefreshDecorations(), this._animationFrame = void 0;
          }));
        }
        _doRefreshDecorations() {
          for (const d of this._decorationService.decorations) this._renderDecoration(d);
          this._dimensionsChanged = !1;
        }
        _renderDecoration(d) {
          this._refreshStyle(d), this._dimensionsChanged && this._refreshXPosition(d);
        }
        _createElement(d) {
          var p, g;
          const b = document.createElement("div");
          b.classList.add("xterm-decoration"), b.classList.toggle("xterm-decoration-top-layer", ((p = d == null ? void 0 : d.options) === null || p === void 0 ? void 0 : p.layer) === "top"), b.style.width = `${Math.round((d.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, b.style.height = (d.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", b.style.top = (d.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", b.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
          const y = (g = d.options.x) !== null && g !== void 0 ? g : 0;
          return y && y > this._bufferService.cols && (b.style.display = "none"), this._refreshXPosition(d, b), b;
        }
        _refreshStyle(d) {
          const p = d.marker.line - this._bufferService.buffers.active.ydisp;
          if (p < 0 || p >= this._bufferService.rows) d.element && (d.element.style.display = "none", d.onRenderEmitter.fire(d.element));
          else {
            let g = this._decorationElements.get(d);
            g || (g = this._createElement(d), d.element = g, this._decorationElements.set(d, g), this._container.appendChild(g), d.onDispose(() => {
              this._decorationElements.delete(d), g.remove();
            })), g.style.top = p * this._renderService.dimensions.css.cell.height + "px", g.style.display = this._altBufferIsActive ? "none" : "block", d.onRenderEmitter.fire(g);
          }
        }
        _refreshXPosition(d, p = d.element) {
          var g;
          if (!p) return;
          const b = (g = d.options.x) !== null && g !== void 0 ? g : 0;
          (d.options.anchor || "left") === "right" ? p.style.right = b ? b * this._renderService.dimensions.css.cell.width + "px" : "" : p.style.left = b ? b * this._renderService.dimensions.css.cell.width + "px" : "";
        }
        _removeDecoration(d) {
          var p;
          (p = this._decorationElements.get(d)) === null || p === void 0 || p.remove(), this._decorationElements.delete(d), d.dispose();
        }
      };
      a.BufferDecorationRenderer = v = c([u(1, _.IBufferService), u(2, _.IDecorationService), u(3, f.IRenderService)], v);
    }, 5871: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ColorZoneStore = void 0, a.ColorZoneStore = class {
        constructor() {
          this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
        }
        get zones() {
          return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
        }
        clear() {
          this._zones.length = 0, this._zonePoolIndex = 0;
        }
        addDecoration(l) {
          if (l.options.overviewRulerOptions) {
            for (const c of this._zones) if (c.color === l.options.overviewRulerOptions.color && c.position === l.options.overviewRulerOptions.position) {
              if (this._lineIntersectsZone(c, l.marker.line)) return;
              if (this._lineAdjacentToZone(c, l.marker.line, l.options.overviewRulerOptions.position)) return void this._addLineToZone(c, l.marker.line);
            }
            if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = l.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = l.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = l.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = l.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
            this._zones.push({ color: l.options.overviewRulerOptions.color, position: l.options.overviewRulerOptions.position, startBufferLine: l.marker.line, endBufferLine: l.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
          }
        }
        setPadding(l) {
          this._linePadding = l;
        }
        _lineIntersectsZone(l, c) {
          return c >= l.startBufferLine && c <= l.endBufferLine;
        }
        _lineAdjacentToZone(l, c, u) {
          return c >= l.startBufferLine - this._linePadding[u || "full"] && c <= l.endBufferLine + this._linePadding[u || "full"];
        }
        _addLineToZone(l, c) {
          l.startBufferLine = Math.min(l.startBufferLine, c), l.endBufferLine = Math.max(l.endBufferLine, c);
        }
      };
    }, 5744: function(o, a, l) {
      var c = this && this.__decorate || function(y, w, k, C) {
        var x, S = arguments.length, T = S < 3 ? w : C === null ? C = Object.getOwnPropertyDescriptor(w, k) : C;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(y, w, k, C);
        else for (var M = y.length - 1; M >= 0; M--) (x = y[M]) && (T = (S < 3 ? x(T) : S > 3 ? x(w, k, T) : x(w, k)) || T);
        return S > 3 && T && Object.defineProperty(w, k, T), T;
      }, u = this && this.__param || function(y, w) {
        return function(k, C) {
          w(k, C, y);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OverviewRulerRenderer = void 0;
      const h = l(5871), f = l(3656), m = l(4725), _ = l(844), v = l(2585), d = { full: 0, left: 0, center: 0, right: 0 }, p = { full: 0, left: 0, center: 0, right: 0 }, g = { full: 0, left: 0, center: 0, right: 0 };
      let b = a.OverviewRulerRenderer = class extends _.Disposable {
        get _width() {
          return this._optionsService.options.overviewRulerWidth || 0;
        }
        constructor(y, w, k, C, x, S, T) {
          var M;
          super(), this._viewportElement = y, this._screenElement = w, this._bufferService = k, this._decorationService = C, this._renderService = x, this._optionsService = S, this._coreBrowseService = T, this._colorZoneStore = new h.ColorZoneStore(), this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (M = this._viewportElement.parentElement) === null || M === void 0 || M.insertBefore(this._canvas, this._viewportElement);
          const E = this._canvas.getContext("2d");
          if (!E) throw new Error("Ctx cannot be null");
          this._ctx = E, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, _.toDisposable)(() => {
            var R;
            (R = this._canvas) === null || R === void 0 || R.remove();
          }));
        }
        _registerDecorationListeners() {
          this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0)));
        }
        _registerBufferChangeListeners() {
          this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
          })), this.register(this._bufferService.onScroll(() => {
            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
          }));
        }
        _registerDimensionChangeListeners() {
          this.register(this._renderService.onRender(() => {
            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);
          })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))), this.register((0, f.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(!0))), this._queueRefresh(!0);
        }
        _refreshDrawConstants() {
          const y = Math.floor(this._canvas.width / 3), w = Math.ceil(this._canvas.width / 3);
          p.full = this._canvas.width, p.left = y, p.center = w, p.right = y, this._refreshDrawHeightConstants(), g.full = 0, g.left = 0, g.center = p.left, g.right = p.left + p.center;
        }
        _refreshDrawHeightConstants() {
          d.full = Math.round(2 * this._coreBrowseService.dpr);
          const y = this._canvas.height / this._bufferService.buffer.lines.length, w = Math.round(Math.max(Math.min(y, 12), 6) * this._coreBrowseService.dpr);
          d.left = w, d.center = w, d.right = w;
        }
        _refreshColorZonePadding() {
          this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * d.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
        }
        _refreshCanvasDimensions() {
          this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
        }
        _refreshDecorations() {
          this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
          for (const w of this._decorationService.decorations) this._colorZoneStore.addDecoration(w);
          this._ctx.lineWidth = 1;
          const y = this._colorZoneStore.zones;
          for (const w of y) w.position !== "full" && this._renderColorZone(w);
          for (const w of y) w.position === "full" && this._renderColorZone(w);
          this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;
        }
        _renderColorZone(y) {
          this._ctx.fillStyle = y.color, this._ctx.fillRect(g[y.position || "full"], Math.round((this._canvas.height - 1) * (y.startBufferLine / this._bufferService.buffers.active.lines.length) - d[y.position || "full"] / 2), p[y.position || "full"], Math.round((this._canvas.height - 1) * ((y.endBufferLine - y.startBufferLine) / this._bufferService.buffers.active.lines.length) + d[y.position || "full"]));
        }
        _queueRefresh(y, w) {
          this._shouldUpdateDimensions = y || this._shouldUpdateDimensions, this._shouldUpdateAnchor = w || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
            this._refreshDecorations(), this._animationFrame = void 0;
          }));
        }
      };
      a.OverviewRulerRenderer = b = c([u(2, v.IBufferService), u(3, v.IDecorationService), u(4, m.IRenderService), u(5, v.IOptionsService), u(6, m.ICoreBrowserService)], b);
    }, 2950: function(o, a, l) {
      var c = this && this.__decorate || function(v, d, p, g) {
        var b, y = arguments.length, w = y < 3 ? d : g === null ? g = Object.getOwnPropertyDescriptor(d, p) : g;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(v, d, p, g);
        else for (var k = v.length - 1; k >= 0; k--) (b = v[k]) && (w = (y < 3 ? b(w) : y > 3 ? b(d, p, w) : b(d, p)) || w);
        return y > 3 && w && Object.defineProperty(d, p, w), w;
      }, u = this && this.__param || function(v, d) {
        return function(p, g) {
          d(p, g, v);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CompositionHelper = void 0;
      const h = l(4725), f = l(2585), m = l(2584);
      let _ = a.CompositionHelper = class {
        get isComposing() {
          return this._isComposing;
        }
        constructor(v, d, p, g, b, y) {
          this._textarea = v, this._compositionView = d, this._bufferService = p, this._optionsService = g, this._coreService = b, this._renderService = y, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
        }
        compositionstart() {
          this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
        }
        compositionupdate(v) {
          this._compositionView.textContent = v.data, this.updateCompositionElements(), setTimeout(() => {
            this._compositionPosition.end = this._textarea.value.length;
          }, 0);
        }
        compositionend() {
          this._finalizeComposition(!0);
        }
        keydown(v) {
          if (this._isComposing || this._isSendingComposition) {
            if (v.keyCode === 229 || v.keyCode === 16 || v.keyCode === 17 || v.keyCode === 18) return !1;
            this._finalizeComposition(!1);
          }
          return v.keyCode !== 229 || (this._handleAnyTextareaChanges(), !1);
        }
        _finalizeComposition(v) {
          if (this._compositionView.classList.remove("active"), this._isComposing = !1, v) {
            const d = { start: this._compositionPosition.start, end: this._compositionPosition.end };
            this._isSendingComposition = !0, setTimeout(() => {
              if (this._isSendingComposition) {
                let p;
                this._isSendingComposition = !1, d.start += this._dataAlreadySent.length, p = this._isComposing ? this._textarea.value.substring(d.start, d.end) : this._textarea.value.substring(d.start), p.length > 0 && this._coreService.triggerDataEvent(p, !0);
              }
            }, 0);
          } else {
            this._isSendingComposition = !1;
            const d = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._coreService.triggerDataEvent(d, !0);
          }
        }
        _handleAnyTextareaChanges() {
          const v = this._textarea.value;
          setTimeout(() => {
            if (!this._isComposing) {
              const d = this._textarea.value, p = d.replace(v, "");
              this._dataAlreadySent = p, d.length > v.length ? this._coreService.triggerDataEvent(p, !0) : d.length < v.length ? this._coreService.triggerDataEvent(`${m.C0.DEL}`, !0) : d.length === v.length && d !== v && this._coreService.triggerDataEvent(d, !0);
            }
          }, 0);
        }
        updateCompositionElements(v) {
          if (this._isComposing) {
            if (this._bufferService.buffer.isCursorInViewport) {
              const d = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), p = this._renderService.dimensions.css.cell.height, g = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, b = d * this._renderService.dimensions.css.cell.width;
              this._compositionView.style.left = b + "px", this._compositionView.style.top = g + "px", this._compositionView.style.height = p + "px", this._compositionView.style.lineHeight = p + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
              const y = this._compositionView.getBoundingClientRect();
              this._textarea.style.left = b + "px", this._textarea.style.top = g + "px", this._textarea.style.width = Math.max(y.width, 1) + "px", this._textarea.style.height = Math.max(y.height, 1) + "px", this._textarea.style.lineHeight = y.height + "px";
            }
            v || setTimeout(() => this.updateCompositionElements(!0), 0);
          }
        }
      };
      a.CompositionHelper = _ = c([u(2, f.IBufferService), u(3, f.IOptionsService), u(4, f.ICoreService), u(5, h.IRenderService)], _);
    }, 9806: (o, a) => {
      function l(c, u, h) {
        const f = h.getBoundingClientRect(), m = c.getComputedStyle(h), _ = parseInt(m.getPropertyValue("padding-left")), v = parseInt(m.getPropertyValue("padding-top"));
        return [u.clientX - f.left - _, u.clientY - f.top - v];
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getCoords = a.getCoordsRelativeToElement = void 0, a.getCoordsRelativeToElement = l, a.getCoords = function(c, u, h, f, m, _, v, d, p) {
        if (!_) return;
        const g = l(c, u, h);
        return g ? (g[0] = Math.ceil((g[0] + (p ? v / 2 : 0)) / v), g[1] = Math.ceil(g[1] / d), g[0] = Math.min(Math.max(g[0], 1), f + (p ? 1 : 0)), g[1] = Math.min(Math.max(g[1], 1), m), g) : void 0;
      };
    }, 9504: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.moveToCellSequence = void 0;
      const c = l(2584);
      function u(d, p, g, b) {
        const y = d - h(d, g), w = p - h(p, g), k = Math.abs(y - w) - function(C, x, S) {
          let T = 0;
          const M = C - h(C, S), E = x - h(x, S);
          for (let R = 0; R < Math.abs(M - E); R++) {
            const z = f(C, x) === "A" ? -1 : 1, F = S.buffer.lines.get(M + z * R);
            F != null && F.isWrapped && T++;
          }
          return T;
        }(d, p, g);
        return v(k, _(f(d, p), b));
      }
      function h(d, p) {
        let g = 0, b = p.buffer.lines.get(d), y = b == null ? void 0 : b.isWrapped;
        for (; y && d >= 0 && d < p.rows; ) g++, b = p.buffer.lines.get(--d), y = b == null ? void 0 : b.isWrapped;
        return g;
      }
      function f(d, p) {
        return d > p ? "A" : "B";
      }
      function m(d, p, g, b, y, w) {
        let k = d, C = p, x = "";
        for (; k !== g || C !== b; ) k += y ? 1 : -1, y && k > w.cols - 1 ? (x += w.buffer.translateBufferLineToString(C, !1, d, k), k = 0, d = 0, C++) : !y && k < 0 && (x += w.buffer.translateBufferLineToString(C, !1, 0, d + 1), k = w.cols - 1, d = k, C--);
        return x + w.buffer.translateBufferLineToString(C, !1, d, k);
      }
      function _(d, p) {
        const g = p ? "O" : "[";
        return c.C0.ESC + g + d;
      }
      function v(d, p) {
        d = Math.floor(d);
        let g = "";
        for (let b = 0; b < d; b++) g += p;
        return g;
      }
      a.moveToCellSequence = function(d, p, g, b) {
        const y = g.buffer.x, w = g.buffer.y;
        if (!g.buffer.hasScrollback) return function(x, S, T, M, E, R) {
          return u(S, M, E, R).length === 0 ? "" : v(m(x, S, x, S - h(S, E), !1, E).length, _("D", R));
        }(y, w, 0, p, g, b) + u(w, p, g, b) + function(x, S, T, M, E, R) {
          let z;
          z = u(S, M, E, R).length > 0 ? M - h(M, E) : S;
          const F = M, j = function(U, $, I, O, P, q) {
            let Q;
            return Q = u(I, O, P, q).length > 0 ? O - h(O, P) : $, U < I && Q <= O || U >= I && Q < O ? "C" : "D";
          }(x, S, T, M, E, R);
          return v(m(x, z, T, F, j === "C", E).length, _(j, R));
        }(y, w, d, p, g, b);
        let k;
        if (w === p) return k = y > d ? "D" : "C", v(Math.abs(y - d), _(k, b));
        k = w > p ? "D" : "C";
        const C = Math.abs(w - p);
        return v(function(x, S) {
          return S.cols - x;
        }(w > p ? d : y, g) + (C - 1) * g.cols + 1 + ((w > p ? y : d) - 1), _(k, b));
      };
    }, 1296: function(o, a, l) {
      var c = this && this.__decorate || function(E, R, z, F) {
        var j, U = arguments.length, $ = U < 3 ? R : F === null ? F = Object.getOwnPropertyDescriptor(R, z) : F;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") $ = Reflect.decorate(E, R, z, F);
        else for (var I = E.length - 1; I >= 0; I--) (j = E[I]) && ($ = (U < 3 ? j($) : U > 3 ? j(R, z, $) : j(R, z)) || $);
        return U > 3 && $ && Object.defineProperty(R, z, $), $;
      }, u = this && this.__param || function(E, R) {
        return function(z, F) {
          R(z, F, E);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRenderer = void 0;
      const h = l(3787), f = l(2550), m = l(2223), _ = l(6171), v = l(4725), d = l(8055), p = l(8460), g = l(844), b = l(2585), y = "xterm-dom-renderer-owner-", w = "xterm-rows", k = "xterm-fg-", C = "xterm-bg-", x = "xterm-focus", S = "xterm-selection";
      let T = 1, M = a.DomRenderer = class extends g.Disposable {
        constructor(E, R, z, F, j, U, $, I, O, P) {
          super(), this._element = E, this._screenElement = R, this._viewportElement = z, this._linkifier2 = F, this._charSizeService = U, this._optionsService = $, this._bufferService = I, this._coreBrowserService = O, this._themeService = P, this._terminalClass = T++, this._rowElements = [], this.onRequestRedraw = this.register(new p.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(w), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(S), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, _.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((q) => this._injectCss(q))), this._injectCss(this._themeService.colors), this._rowFactory = j.createInstance(h.DomRendererRowFactory, document), this._element.classList.add(y + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((q) => this._handleLinkHover(q))), this.register(this._linkifier2.onHideLinkUnderline((q) => this._handleLinkLeave(q))), this.register((0, g.toDisposable)(() => {
            this._element.classList.remove(y + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
          })), this._widthCache = new f.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        _updateDimensions() {
          const E = this._coreBrowserService.dpr;
          this.dimensions.device.char.width = this._charSizeService.width * E, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * E), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / E), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / E), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
          for (const z of this._rowElements) z.style.width = `${this.dimensions.css.canvas.width}px`, z.style.height = `${this.dimensions.css.cell.height}px`, z.style.lineHeight = `${this.dimensions.css.cell.height}px`, z.style.overflow = "hidden";
          this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
          const R = `${this._terminalSelector} .${w} span { display: inline-block; height: 100%; vertical-align: top;}`;
          this._dimensionsStyleElement.textContent = R, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
        }
        _injectCss(E) {
          this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
          let R = `${this._terminalSelector} .${w} { color: ${E.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
          R += `${this._terminalSelector} .${w} .xterm-dim { color: ${d.color.multiplyOpacity(E.foreground, 0.5).css};}`, R += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, R += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", R += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${E.cursor.css};  color: ${E.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${E.cursor.css}; }}`, R += `${this._terminalSelector} .${w}.${x} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${w}.${x} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-block { background-color: ${E.cursor.css}; color: ${E.cursorAccent.css};}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${E.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${E.cursor.css} inset;}${this._terminalSelector} .${w} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${E.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, R += `${this._terminalSelector} .${S} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${S} div { position: absolute; background-color: ${E.selectionBackgroundOpaque.css};}${this._terminalSelector} .${S} div { position: absolute; background-color: ${E.selectionInactiveBackgroundOpaque.css};}`;
          for (const [z, F] of E.ansi.entries()) R += `${this._terminalSelector} .${k}${z} { color: ${F.css}; }${this._terminalSelector} .${k}${z}.xterm-dim { color: ${d.color.multiplyOpacity(F, 0.5).css}; }${this._terminalSelector} .${C}${z} { background-color: ${F.css}; }`;
          R += `${this._terminalSelector} .${k}${m.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque(E.background).css}; }${this._terminalSelector} .${k}${m.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${d.color.multiplyOpacity(d.color.opaque(E.background), 0.5).css}; }${this._terminalSelector} .${C}${m.INVERTED_DEFAULT_COLOR} { background-color: ${E.foreground.css}; }`, this._themeStyleElement.textContent = R;
        }
        _setDefaultSpacing() {
          const E = this.dimensions.css.cell.width - this._widthCache.get("W", !1, !1);
          this._rowContainer.style.letterSpacing = `${E}px`, this._rowFactory.defaultSpacing = E;
        }
        handleDevicePixelRatioChange() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        _refreshRowElements(E, R) {
          for (let z = this._rowElements.length; z <= R; z++) {
            const F = document.createElement("div");
            this._rowContainer.appendChild(F), this._rowElements.push(F);
          }
          for (; this._rowElements.length > R; ) this._rowContainer.removeChild(this._rowElements.pop());
        }
        handleResize(E, R) {
          this._refreshRowElements(E, R), this._updateDimensions();
        }
        handleCharSizeChanged() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        handleBlur() {
          this._rowContainer.classList.remove(x);
        }
        handleFocus() {
          this._rowContainer.classList.add(x), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
        }
        handleSelectionChanged(E, R, z) {
          if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(E, R, z), this.renderRows(0, this._bufferService.rows - 1), !E || !R) return;
          const F = E[1] - this._bufferService.buffer.ydisp, j = R[1] - this._bufferService.buffer.ydisp, U = Math.max(F, 0), $ = Math.min(j, this._bufferService.rows - 1);
          if (U >= this._bufferService.rows || $ < 0) return;
          const I = document.createDocumentFragment();
          if (z) {
            const O = E[0] > R[0];
            I.appendChild(this._createSelectionElement(U, O ? R[0] : E[0], O ? E[0] : R[0], $ - U + 1));
          } else {
            const O = F === U ? E[0] : 0, P = U === j ? R[0] : this._bufferService.cols;
            I.appendChild(this._createSelectionElement(U, O, P));
            const q = $ - U - 1;
            if (I.appendChild(this._createSelectionElement(U + 1, 0, this._bufferService.cols, q)), U !== $) {
              const Q = j === $ ? R[0] : this._bufferService.cols;
              I.appendChild(this._createSelectionElement($, 0, Q));
            }
          }
          this._selectionContainer.appendChild(I);
        }
        _createSelectionElement(E, R, z, F = 1) {
          const j = document.createElement("div");
          return j.style.height = F * this.dimensions.css.cell.height + "px", j.style.top = E * this.dimensions.css.cell.height + "px", j.style.left = R * this.dimensions.css.cell.width + "px", j.style.width = this.dimensions.css.cell.width * (z - R) + "px", j;
        }
        handleCursorMove() {
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        clear() {
          for (const E of this._rowElements) E.replaceChildren();
        }
        renderRows(E, R) {
          const z = this._bufferService.buffer, F = z.ybase + z.y, j = Math.min(z.x, this._bufferService.cols - 1), U = this._optionsService.rawOptions.cursorBlink, $ = this._optionsService.rawOptions.cursorStyle, I = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let O = E; O <= R; O++) {
            const P = O + z.ydisp, q = this._rowElements[O], Q = z.lines.get(P);
            if (!q || !Q) break;
            q.replaceChildren(...this._rowFactory.createRow(Q, P, P === F, $, I, j, U, this.dimensions.css.cell.width, this._widthCache, -1, -1));
          }
        }
        get _terminalSelector() {
          return `.${y}${this._terminalClass}`;
        }
        _handleLinkHover(E) {
          this._setCellUnderline(E.x1, E.x2, E.y1, E.y2, E.cols, !0);
        }
        _handleLinkLeave(E) {
          this._setCellUnderline(E.x1, E.x2, E.y1, E.y2, E.cols, !1);
        }
        _setCellUnderline(E, R, z, F, j, U) {
          z < 0 && (E = 0), F < 0 && (R = 0);
          const $ = this._bufferService.rows - 1;
          z = Math.max(Math.min(z, $), 0), F = Math.max(Math.min(F, $), 0), j = Math.min(j, this._bufferService.cols);
          const I = this._bufferService.buffer, O = I.ybase + I.y, P = Math.min(I.x, j - 1), q = this._optionsService.rawOptions.cursorBlink, Q = this._optionsService.rawOptions.cursorStyle, X = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let G = z; G <= F; ++G) {
            const he = G + I.ydisp, A = this._rowElements[G], N = I.lines.get(he);
            if (!A || !N) break;
            A.replaceChildren(...this._rowFactory.createRow(N, he, he === O, Q, X, P, q, this.dimensions.css.cell.width, this._widthCache, U ? G === z ? E : 0 : -1, U ? (G === F ? R : j) - 1 : -1));
          }
        }
      };
      a.DomRenderer = M = c([u(4, b.IInstantiationService), u(5, v.ICharSizeService), u(6, b.IOptionsService), u(7, b.IBufferService), u(8, v.ICoreBrowserService), u(9, v.IThemeService)], M);
    }, 3787: function(o, a, l) {
      var c = this && this.__decorate || function(k, C, x, S) {
        var T, M = arguments.length, E = M < 3 ? C : S === null ? S = Object.getOwnPropertyDescriptor(C, x) : S;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") E = Reflect.decorate(k, C, x, S);
        else for (var R = k.length - 1; R >= 0; R--) (T = k[R]) && (E = (M < 3 ? T(E) : M > 3 ? T(C, x, E) : T(C, x)) || E);
        return M > 3 && E && Object.defineProperty(C, x, E), E;
      }, u = this && this.__param || function(k, C) {
        return function(x, S) {
          C(x, S, k);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DomRendererRowFactory = void 0;
      const h = l(2223), f = l(643), m = l(511), _ = l(2585), v = l(8055), d = l(4725), p = l(4269), g = l(6171), b = l(3734);
      let y = a.DomRendererRowFactory = class {
        constructor(k, C, x, S, T, M, E) {
          this._document = k, this._characterJoinerService = C, this._optionsService = x, this._coreBrowserService = S, this._coreService = T, this._decorationService = M, this._themeService = E, this._workCell = new m.CellData(), this._columnSelectMode = !1, this.defaultSpacing = 0;
        }
        handleSelectionChanged(k, C, x) {
          this._selectionStart = k, this._selectionEnd = C, this._columnSelectMode = x;
        }
        createRow(k, C, x, S, T, M, E, R, z, F, j) {
          const U = [], $ = this._characterJoinerService.getJoinedCharacters(C), I = this._themeService.colors;
          let O, P = k.getNoBgTrimmedLength();
          x && P < M + 1 && (P = M + 1);
          let q = 0, Q = "", X = 0, G = 0, he = 0, A = !1, N = 0, V = !1, W = 0;
          const ie = [], Y = F !== -1 && j !== -1;
          for (let de = 0; de < P; de++) {
            k.loadCell(de, this._workCell);
            let He = this._workCell.getWidth();
            if (He === 0) continue;
            let it = !1, qs = de, ne = this._workCell;
            if ($.length > 0 && de === $[0][0]) {
              it = !0;
              const Ce = $.shift();
              ne = new p.JoinedCellData(this._workCell, k.translateToString(!0, Ce[0], Ce[1]), Ce[1] - Ce[0]), qs = Ce[1] - 1, He = ne.getWidth();
            }
            const wi = this._isCellInSelection(de, C), Qn = x && de === M, Yn = Y && de >= F && de <= j;
            let Gn = !1;
            this._decorationService.forEachDecorationAtCell(de, C, void 0, (Ce) => {
              Gn = !0;
            });
            let Sr = ne.getChars() || f.WHITESPACE_CELL_CHAR;
            if (Sr === " " && (ne.isUnderline() || ne.isOverline()) && (Sr = ""), W = He * R - z.get(Sr, ne.isBold(), ne.isItalic()), O) {
              if (q && (wi && V || !wi && !V && ne.bg === X) && (wi && V && I.selectionForeground || ne.fg === G) && ne.extended.ext === he && Yn === A && W === N && !Qn && !it && !Gn) {
                Q += Sr, q++;
                continue;
              }
              q && (O.textContent = Q), O = this._document.createElement("span"), q = 0, Q = "";
            } else O = this._document.createElement("span");
            if (X = ne.bg, G = ne.fg, he = ne.extended.ext, A = Yn, N = W, V = wi, it && M >= de && M <= qs && (M = de), !this._coreService.isCursorHidden && Qn) {
              if (ie.push("xterm-cursor"), this._coreBrowserService.isFocused) E && ie.push("xterm-cursor-blink"), ie.push(S === "bar" ? "xterm-cursor-bar" : S === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
              else if (T) switch (T) {
                case "outline":
                  ie.push("xterm-cursor-outline");
                  break;
                case "block":
                  ie.push("xterm-cursor-block");
                  break;
                case "bar":
                  ie.push("xterm-cursor-bar");
                  break;
                case "underline":
                  ie.push("xterm-cursor-underline");
              }
            }
            if (ne.isBold() && ie.push("xterm-bold"), ne.isItalic() && ie.push("xterm-italic"), ne.isDim() && ie.push("xterm-dim"), Q = ne.isInvisible() ? f.WHITESPACE_CELL_CHAR : ne.getChars() || f.WHITESPACE_CELL_CHAR, ne.isUnderline() && (ie.push(`xterm-underline-${ne.extended.underlineStyle}`), Q === " " && (Q = ""), !ne.isUnderlineColorDefault())) if (ne.isUnderlineColorRGB()) O.style.textDecorationColor = `rgb(${b.AttributeData.toColorRGB(ne.getUnderlineColor()).join(",")})`;
            else {
              let Ce = ne.getUnderlineColor();
              this._optionsService.rawOptions.drawBoldTextInBrightColors && ne.isBold() && Ce < 8 && (Ce += 8), O.style.textDecorationColor = I.ansi[Ce].css;
            }
            ne.isOverline() && (ie.push("xterm-overline"), Q === " " && (Q = "")), ne.isStrikethrough() && ie.push("xterm-strikethrough"), Yn && (O.style.textDecoration = "underline");
            let dt = ne.getFgColor(), xi = ne.getFgColorMode(), St = ne.getBgColor(), ki = ne.getBgColorMode();
            const Xn = !!ne.isInverse();
            if (Xn) {
              const Ce = dt;
              dt = St, St = Ce;
              const Vd = xi;
              xi = ki, ki = Vd;
            }
            let Kt, Jn, Qt, Si = !1;
            switch (this._decorationService.forEachDecorationAtCell(de, C, void 0, (Ce) => {
              Ce.options.layer !== "top" && Si || (Ce.backgroundColorRGB && (ki = 50331648, St = Ce.backgroundColorRGB.rgba >> 8 & 16777215, Kt = Ce.backgroundColorRGB), Ce.foregroundColorRGB && (xi = 50331648, dt = Ce.foregroundColorRGB.rgba >> 8 & 16777215, Jn = Ce.foregroundColorRGB), Si = Ce.options.layer === "top");
            }), !Si && wi && (Kt = this._coreBrowserService.isFocused ? I.selectionBackgroundOpaque : I.selectionInactiveBackgroundOpaque, St = Kt.rgba >> 8 & 16777215, ki = 50331648, Si = !0, I.selectionForeground && (xi = 50331648, dt = I.selectionForeground.rgba >> 8 & 16777215, Jn = I.selectionForeground)), Si && ie.push("xterm-decoration-top"), ki) {
              case 16777216:
              case 33554432:
                Qt = I.ansi[St], ie.push(`xterm-bg-${St}`);
                break;
              case 50331648:
                Qt = v.rgba.toColor(St >> 16, St >> 8 & 255, 255 & St), this._addStyle(O, `background-color:#${w((St >>> 0).toString(16), "0", 6)}`);
                break;
              default:
                Xn ? (Qt = I.foreground, ie.push(`xterm-bg-${h.INVERTED_DEFAULT_COLOR}`)) : Qt = I.background;
            }
            switch (Kt || ne.isDim() && (Kt = v.color.multiplyOpacity(Qt, 0.5)), xi) {
              case 16777216:
              case 33554432:
                ne.isBold() && dt < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (dt += 8), this._applyMinimumContrast(O, Qt, I.ansi[dt], ne, Kt, void 0) || ie.push(`xterm-fg-${dt}`);
                break;
              case 50331648:
                const Ce = v.rgba.toColor(dt >> 16 & 255, dt >> 8 & 255, 255 & dt);
                this._applyMinimumContrast(O, Qt, Ce, ne, Kt, Jn) || this._addStyle(O, `color:#${w(dt.toString(16), "0", 6)}`);
                break;
              default:
                this._applyMinimumContrast(O, Qt, I.foreground, ne, Kt, void 0) || Xn && ie.push(`xterm-fg-${h.INVERTED_DEFAULT_COLOR}`);
            }
            ie.length && (O.className = ie.join(" "), ie.length = 0), Qn || it || Gn ? O.textContent = Q : q++, W !== this.defaultSpacing && (O.style.letterSpacing = `${W}px`), U.push(O), de = qs;
          }
          return O && q && (O.textContent = Q), U;
        }
        _applyMinimumContrast(k, C, x, S, T, M) {
          if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, g.excludeFromContrastRatioDemands)(S.getCode())) return !1;
          const E = this._getContrastCache(S);
          let R;
          if (T || M || (R = E.getColor(C.rgba, x.rgba)), R === void 0) {
            const z = this._optionsService.rawOptions.minimumContrastRatio / (S.isDim() ? 2 : 1);
            R = v.color.ensureContrastRatio(T || C, M || x, z), E.setColor((T || C).rgba, (M || x).rgba, R ?? null);
          }
          return !!R && (this._addStyle(k, `color:${R.css}`), !0);
        }
        _getContrastCache(k) {
          return k.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
        }
        _addStyle(k, C) {
          k.setAttribute("style", `${k.getAttribute("style") || ""}${C};`);
        }
        _isCellInSelection(k, C) {
          const x = this._selectionStart, S = this._selectionEnd;
          return !(!x || !S) && (this._columnSelectMode ? x[0] <= S[0] ? k >= x[0] && C >= x[1] && k < S[0] && C <= S[1] : k < x[0] && C >= x[1] && k >= S[0] && C <= S[1] : C > x[1] && C < S[1] || x[1] === S[1] && C === x[1] && k >= x[0] && k < S[0] || x[1] < S[1] && C === S[1] && k < S[0] || x[1] < S[1] && C === x[1] && k >= x[0]);
        }
      };
      function w(k, C, x) {
        for (; k.length < x; ) k = C + k;
        return k;
      }
      a.DomRendererRowFactory = y = c([u(1, d.ICharacterJoinerService), u(2, _.IOptionsService), u(3, d.ICoreBrowserService), u(4, _.ICoreService), u(5, _.IDecorationService), u(6, d.IThemeService)], y);
    }, 2550: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.WidthCache = void 0, a.WidthCache = class {
        constructor(l) {
          this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = l.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
          const c = l.createElement("span"), u = l.createElement("span");
          u.style.fontWeight = "bold";
          const h = l.createElement("span");
          h.style.fontStyle = "italic";
          const f = l.createElement("span");
          f.style.fontWeight = "bold", f.style.fontStyle = "italic", this._measureElements = [c, u, h, f], this._container.appendChild(c), this._container.appendChild(u), this._container.appendChild(h), this._container.appendChild(f), l.body.appendChild(this._container), this.clear();
        }
        dispose() {
          this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
        }
        clear() {
          this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
        }
        setFont(l, c, u, h) {
          l === this._font && c === this._fontSize && u === this._weight && h === this._weightBold || (this._font = l, this._fontSize = c, this._weight = u, this._weightBold = h, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${u}`, this._measureElements[1].style.fontWeight = `${h}`, this._measureElements[2].style.fontWeight = `${u}`, this._measureElements[3].style.fontWeight = `${h}`, this.clear());
        }
        get(l, c, u) {
          let h = 0;
          if (!c && !u && l.length === 1 && (h = l.charCodeAt(0)) < 256) return this._flat[h] !== -9999 ? this._flat[h] : this._flat[h] = this._measure(l, 0);
          let f = l;
          c && (f += "B"), u && (f += "I");
          let m = this._holey.get(f);
          if (m === void 0) {
            let _ = 0;
            c && (_ |= 1), u && (_ |= 2), m = this._measure(l, _), this._holey.set(f, m);
          }
          return m;
        }
        _measure(l, c) {
          const u = this._measureElements[c];
          return u.textContent = l.repeat(32), u.offsetWidth / 32;
        }
      };
    }, 2223: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.TEXT_BASELINE = a.DIM_OPACITY = a.INVERTED_DEFAULT_COLOR = void 0;
      const c = l(6114);
      a.INVERTED_DEFAULT_COLOR = 257, a.DIM_OPACITY = 0.5, a.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic";
    }, 6171: (o, a) => {
      function l(c) {
        return 57508 <= c && c <= 57558;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.createRenderDimensions = a.excludeFromContrastRatioDemands = a.isRestrictedPowerlineGlyph = a.isPowerlineGlyph = a.throwIfFalsy = void 0, a.throwIfFalsy = function(c) {
        if (!c) throw new Error("value must not be falsy");
        return c;
      }, a.isPowerlineGlyph = l, a.isRestrictedPowerlineGlyph = function(c) {
        return 57520 <= c && c <= 57527;
      }, a.excludeFromContrastRatioDemands = function(c) {
        return l(c) || function(u) {
          return 9472 <= u && u <= 9631;
        }(c);
      }, a.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      };
    }, 456: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionModel = void 0, a.SelectionModel = class {
        constructor(l) {
          this._bufferService = l, this.isSelectAllActive = !1, this.selectionStartLength = 0;
        }
        clearSelection() {
          this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;
        }
        get finalSelectionStart() {
          return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        }
        get finalSelectionEnd() {
          if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
          if (this.selectionStart) {
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
              const l = this.selectionStart[0] + this.selectionStartLength;
              return l > this._bufferService.cols ? l % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols) - 1] : [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [l, this.selectionStart[1]];
            }
            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
              const l = this.selectionStart[0] + this.selectionStartLength;
              return l > this._bufferService.cols ? [l % this._bufferService.cols, this.selectionStart[1] + Math.floor(l / this._bufferService.cols)] : [Math.max(l, this.selectionEnd[0]), this.selectionEnd[1]];
            }
            return this.selectionEnd;
          }
        }
        areSelectionValuesReversed() {
          const l = this.selectionStart, c = this.selectionEnd;
          return !(!l || !c) && (l[1] > c[1] || l[1] === c[1] && l[0] > c[0]);
        }
        handleTrim(l) {
          return this.selectionStart && (this.selectionStart[1] -= l), this.selectionEnd && (this.selectionEnd[1] -= l), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);
        }
      };
    }, 428: function(o, a, l) {
      var c = this && this.__decorate || function(d, p, g, b) {
        var y, w = arguments.length, k = w < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, g) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(d, p, g, b);
        else for (var C = d.length - 1; C >= 0; C--) (y = d[C]) && (k = (w < 3 ? y(k) : w > 3 ? y(p, g, k) : y(p, g)) || k);
        return w > 3 && k && Object.defineProperty(p, g, k), k;
      }, u = this && this.__param || function(d, p) {
        return function(g, b) {
          p(g, b, d);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CharSizeService = void 0;
      const h = l(2585), f = l(8460), m = l(844);
      let _ = a.CharSizeService = class extends m.Disposable {
        get hasValidSize() {
          return this.width > 0 && this.height > 0;
        }
        constructor(d, p, g) {
          super(), this._optionsService = g, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new f.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new v(d, p, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
        }
        measure() {
          const d = this._measureStrategy.measure();
          d.width === this.width && d.height === this.height || (this.width = d.width, this.height = d.height, this._onCharSizeChange.fire());
        }
      };
      a.CharSizeService = _ = c([u(2, h.IOptionsService)], _);
      class v {
        constructor(p, g, b) {
          this._document = p, this._parentElement = g, this._optionsService = b, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
        }
        measure() {
          this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
          const p = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
          return p.width !== 0 && p.height !== 0 && (this._result.width = p.width / 32, this._result.height = Math.ceil(p.height)), this._result;
        }
      }
    }, 4269: function(o, a, l) {
      var c = this && this.__decorate || function(p, g, b, y) {
        var w, k = arguments.length, C = k < 3 ? g : y === null ? y = Object.getOwnPropertyDescriptor(g, b) : y;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") C = Reflect.decorate(p, g, b, y);
        else for (var x = p.length - 1; x >= 0; x--) (w = p[x]) && (C = (k < 3 ? w(C) : k > 3 ? w(g, b, C) : w(g, b)) || C);
        return k > 3 && C && Object.defineProperty(g, b, C), C;
      }, u = this && this.__param || function(p, g) {
        return function(b, y) {
          g(b, y, p);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CharacterJoinerService = a.JoinedCellData = void 0;
      const h = l(3734), f = l(643), m = l(511), _ = l(2585);
      class v extends h.AttributeData {
        constructor(g, b, y) {
          super(), this.content = 0, this.combinedData = "", this.fg = g.fg, this.bg = g.bg, this.combinedData = b, this._width = y;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(g) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      a.JoinedCellData = v;
      let d = a.CharacterJoinerService = class Wh {
        constructor(g) {
          this._bufferService = g, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new m.CellData();
        }
        register(g) {
          const b = { id: this._nextCharacterJoinerId++, handler: g };
          return this._characterJoiners.push(b), b.id;
        }
        deregister(g) {
          for (let b = 0; b < this._characterJoiners.length; b++) if (this._characterJoiners[b].id === g) return this._characterJoiners.splice(b, 1), !0;
          return !1;
        }
        getJoinedCharacters(g) {
          if (this._characterJoiners.length === 0) return [];
          const b = this._bufferService.buffer.lines.get(g);
          if (!b || b.length === 0) return [];
          const y = [], w = b.translateToString(!0);
          let k = 0, C = 0, x = 0, S = b.getFg(0), T = b.getBg(0);
          for (let M = 0; M < b.getTrimmedLength(); M++) if (b.loadCell(M, this._workCell), this._workCell.getWidth() !== 0) {
            if (this._workCell.fg !== S || this._workCell.bg !== T) {
              if (M - k > 1) {
                const E = this._getJoinedRanges(w, x, C, b, k);
                for (let R = 0; R < E.length; R++) y.push(E[R]);
              }
              k = M, x = C, S = this._workCell.fg, T = this._workCell.bg;
            }
            C += this._workCell.getChars().length || f.WHITESPACE_CELL_CHAR.length;
          }
          if (this._bufferService.cols - k > 1) {
            const M = this._getJoinedRanges(w, x, C, b, k);
            for (let E = 0; E < M.length; E++) y.push(M[E]);
          }
          return y;
        }
        _getJoinedRanges(g, b, y, w, k) {
          const C = g.substring(b, y);
          let x = [];
          try {
            x = this._characterJoiners[0].handler(C);
          } catch (S) {
            console.error(S);
          }
          for (let S = 1; S < this._characterJoiners.length; S++) try {
            const T = this._characterJoiners[S].handler(C);
            for (let M = 0; M < T.length; M++) Wh._mergeRanges(x, T[M]);
          } catch (T) {
            console.error(T);
          }
          return this._stringRangesToCellRanges(x, w, k), x;
        }
        _stringRangesToCellRanges(g, b, y) {
          let w = 0, k = !1, C = 0, x = g[w];
          if (x) {
            for (let S = y; S < this._bufferService.cols; S++) {
              const T = b.getWidth(S), M = b.getString(S).length || f.WHITESPACE_CELL_CHAR.length;
              if (T !== 0) {
                if (!k && x[0] <= C && (x[0] = S, k = !0), x[1] <= C) {
                  if (x[1] = S, x = g[++w], !x) break;
                  x[0] <= C ? (x[0] = S, k = !0) : k = !1;
                }
                C += M;
              }
            }
            x && (x[1] = this._bufferService.cols);
          }
        }
        static _mergeRanges(g, b) {
          let y = !1;
          for (let w = 0; w < g.length; w++) {
            const k = g[w];
            if (y) {
              if (b[1] <= k[0]) return g[w - 1][1] = b[1], g;
              if (b[1] <= k[1]) return g[w - 1][1] = Math.max(b[1], k[1]), g.splice(w, 1), g;
              g.splice(w, 1), w--;
            } else {
              if (b[1] <= k[0]) return g.splice(w, 0, b), g;
              if (b[1] <= k[1]) return k[0] = Math.min(b[0], k[0]), g;
              b[0] < k[1] && (k[0] = Math.min(b[0], k[0]), y = !0);
            }
          }
          return y ? g[g.length - 1][1] = b[1] : g.push(b), g;
        }
      };
      a.CharacterJoinerService = d = c([u(0, _.IBufferService)], d);
    }, 5114: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreBrowserService = void 0, a.CoreBrowserService = class {
        constructor(l, c) {
          this._textarea = l, this.window = c, this._isFocused = !1, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = !0), this._textarea.addEventListener("blur", () => this._isFocused = !1);
        }
        get dpr() {
          return this.window.devicePixelRatio;
        }
        get isFocused() {
          return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
        }
      };
    }, 8934: function(o, a, l) {
      var c = this && this.__decorate || function(_, v, d, p) {
        var g, b = arguments.length, y = b < 3 ? v : p === null ? p = Object.getOwnPropertyDescriptor(v, d) : p;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") y = Reflect.decorate(_, v, d, p);
        else for (var w = _.length - 1; w >= 0; w--) (g = _[w]) && (y = (b < 3 ? g(y) : b > 3 ? g(v, d, y) : g(v, d)) || y);
        return b > 3 && y && Object.defineProperty(v, d, y), y;
      }, u = this && this.__param || function(_, v) {
        return function(d, p) {
          v(d, p, _);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.MouseService = void 0;
      const h = l(4725), f = l(9806);
      let m = a.MouseService = class {
        constructor(_, v) {
          this._renderService = _, this._charSizeService = v;
        }
        getCoords(_, v, d, p, g) {
          return (0, f.getCoords)(window, _, v, d, p, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, g);
        }
        getMouseReportCoords(_, v) {
          const d = (0, f.getCoordsRelativeToElement)(window, _, v);
          if (this._charSizeService.hasValidSize) return d[0] = Math.min(Math.max(d[0], 0), this._renderService.dimensions.css.canvas.width - 1), d[1] = Math.min(Math.max(d[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(d[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(d[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(d[0]), y: Math.floor(d[1]) };
        }
      };
      a.MouseService = m = c([u(0, h.IRenderService), u(1, h.ICharSizeService)], m);
    }, 3230: function(o, a, l) {
      var c = this && this.__decorate || function(y, w, k, C) {
        var x, S = arguments.length, T = S < 3 ? w : C === null ? C = Object.getOwnPropertyDescriptor(w, k) : C;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(y, w, k, C);
        else for (var M = y.length - 1; M >= 0; M--) (x = y[M]) && (T = (S < 3 ? x(T) : S > 3 ? x(w, k, T) : x(w, k)) || T);
        return S > 3 && T && Object.defineProperty(w, k, T), T;
      }, u = this && this.__param || function(y, w) {
        return function(k, C) {
          w(k, C, y);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.RenderService = void 0;
      const h = l(3656), f = l(6193), m = l(5596), _ = l(4725), v = l(8460), d = l(844), p = l(7226), g = l(2585);
      let b = a.RenderService = class extends d.Disposable {
        get dimensions() {
          return this._renderer.value.dimensions;
        }
        constructor(y, w, k, C, x, S, T, M) {
          if (super(), this._rowCount = y, this._charSizeService = C, this._renderer = this.register(new d.MutableDisposable()), this._pausedResizeTask = new p.DebouncedIdleTask(), this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: !1 }, this._onDimensionsChange = this.register(new v.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new v.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new v.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new v.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new f.RenderDebouncer(T.window, (E, R) => this._renderRows(E, R)), this.register(this._renderDebouncer), this._screenDprMonitor = new m.ScreenDprMonitor(T.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(S.onResize(() => this._fullRefresh())), this.register(S.buffers.onBufferActivate(() => {
            var E;
            return (E = this._renderer.value) === null || E === void 0 ? void 0 : E.clear();
          })), this.register(k.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(x.onDecorationRegistered(() => this._fullRefresh())), this.register(x.onDecorationRemoved(() => this._fullRefresh())), this.register(k.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
            this.clear(), this.handleResize(S.cols, S.rows), this._fullRefresh();
          })), this.register(k.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(S.buffer.y, S.buffer.y, !0))), this.register((0, h.addDisposableDomListener)(T.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(M.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in T.window) {
            const E = new T.window.IntersectionObserver((R) => this._handleIntersectionChange(R[R.length - 1]), { threshold: 0 });
            E.observe(w), this.register({ dispose: () => E.disconnect() });
          }
        }
        _handleIntersectionChange(y) {
          this._isPaused = y.isIntersecting === void 0 ? y.intersectionRatio === 0 : !y.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);
        }
        refreshRows(y, w, k = !1) {
          this._isPaused ? this._needsFullRefresh = !0 : (k || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(y, w, this._rowCount));
        }
        _renderRows(y, w) {
          this._renderer.value && (y = Math.min(y, this._rowCount - 1), w = Math.min(w, this._rowCount - 1), this._renderer.value.renderRows(y, w), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: y, end: w }), this._onRender.fire({ start: y, end: w }), this._isNextRenderRedrawOnly = !0);
        }
        resize(y, w) {
          this._rowCount = w, this._fireOnCanvasResize();
        }
        _handleOptionsChanged() {
          this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
        }
        _fireOnCanvasResize() {
          this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
        }
        hasRenderer() {
          return !!this._renderer.value;
        }
        setRenderer(y) {
          this._renderer.value = y, this._renderer.value.onRequestRedraw((w) => this.refreshRows(w.start, w.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh();
        }
        addRefreshCallback(y) {
          return this._renderDebouncer.addRefreshCallback(y);
        }
        _fullRefresh() {
          this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);
        }
        clearTextureAtlas() {
          var y, w;
          this._renderer.value && ((w = (y = this._renderer.value).clearTextureAtlas) === null || w === void 0 || w.call(y), this._fullRefresh());
        }
        handleDevicePixelRatioChange() {
          this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
        }
        handleResize(y, w) {
          this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(y, w)) : this._renderer.value.handleResize(y, w), this._fullRefresh());
        }
        handleCharSizeChanged() {
          var y;
          (y = this._renderer.value) === null || y === void 0 || y.handleCharSizeChanged();
        }
        handleBlur() {
          var y;
          (y = this._renderer.value) === null || y === void 0 || y.handleBlur();
        }
        handleFocus() {
          var y;
          (y = this._renderer.value) === null || y === void 0 || y.handleFocus();
        }
        handleSelectionChanged(y, w, k) {
          var C;
          this._selectionState.start = y, this._selectionState.end = w, this._selectionState.columnSelectMode = k, (C = this._renderer.value) === null || C === void 0 || C.handleSelectionChanged(y, w, k);
        }
        handleCursorMove() {
          var y;
          (y = this._renderer.value) === null || y === void 0 || y.handleCursorMove();
        }
        clear() {
          var y;
          (y = this._renderer.value) === null || y === void 0 || y.clear();
        }
      };
      a.RenderService = b = c([u(2, g.IOptionsService), u(3, _.ICharSizeService), u(4, g.IDecorationService), u(5, g.IBufferService), u(6, _.ICoreBrowserService), u(7, _.IThemeService)], b);
    }, 9312: function(o, a, l) {
      var c = this && this.__decorate || function(x, S, T, M) {
        var E, R = arguments.length, z = R < 3 ? S : M === null ? M = Object.getOwnPropertyDescriptor(S, T) : M;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") z = Reflect.decorate(x, S, T, M);
        else for (var F = x.length - 1; F >= 0; F--) (E = x[F]) && (z = (R < 3 ? E(z) : R > 3 ? E(S, T, z) : E(S, T)) || z);
        return R > 3 && z && Object.defineProperty(S, T, z), z;
      }, u = this && this.__param || function(x, S) {
        return function(T, M) {
          S(T, M, x);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.SelectionService = void 0;
      const h = l(9806), f = l(9504), m = l(456), _ = l(4725), v = l(8460), d = l(844), p = l(6114), g = l(4841), b = l(511), y = l(2585), w = "", k = new RegExp(w, "g");
      let C = a.SelectionService = class extends d.Disposable {
        constructor(x, S, T, M, E, R, z, F, j) {
          super(), this._element = x, this._screenElement = S, this._linkifier = T, this._bufferService = M, this._coreService = E, this._mouseService = R, this._optionsService = z, this._renderService = F, this._coreBrowserService = j, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new b.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new v.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new v.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new v.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new v.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (U) => this._handleMouseMove(U), this._mouseUpListener = (U) => this._handleMouseUp(U), this._coreService.onUserInput(() => {
            this.hasSelection && this.clearSelection();
          }), this._trimListener = this._bufferService.buffer.lines.onTrim((U) => this._handleTrim(U)), this.register(this._bufferService.buffers.onBufferActivate((U) => this._handleBufferActivate(U))), this.enable(), this._model = new m.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, d.toDisposable)(() => {
            this._removeMouseDownListeners();
          }));
        }
        reset() {
          this.clearSelection();
        }
        disable() {
          this.clearSelection(), this._enabled = !1;
        }
        enable() {
          this._enabled = !0;
        }
        get selectionStart() {
          return this._model.finalSelectionStart;
        }
        get selectionEnd() {
          return this._model.finalSelectionEnd;
        }
        get hasSelection() {
          const x = this._model.finalSelectionStart, S = this._model.finalSelectionEnd;
          return !(!x || !S || x[0] === S[0] && x[1] === S[1]);
        }
        get selectionText() {
          const x = this._model.finalSelectionStart, S = this._model.finalSelectionEnd;
          if (!x || !S) return "";
          const T = this._bufferService.buffer, M = [];
          if (this._activeSelectionMode === 3) {
            if (x[0] === S[0]) return "";
            const E = x[0] < S[0] ? x[0] : S[0], R = x[0] < S[0] ? S[0] : x[0];
            for (let z = x[1]; z <= S[1]; z++) {
              const F = T.translateBufferLineToString(z, !0, E, R);
              M.push(F);
            }
          } else {
            const E = x[1] === S[1] ? S[0] : void 0;
            M.push(T.translateBufferLineToString(x[1], !0, x[0], E));
            for (let R = x[1] + 1; R <= S[1] - 1; R++) {
              const z = T.lines.get(R), F = T.translateBufferLineToString(R, !0);
              z != null && z.isWrapped ? M[M.length - 1] += F : M.push(F);
            }
            if (x[1] !== S[1]) {
              const R = T.lines.get(S[1]), z = T.translateBufferLineToString(S[1], !0, 0, S[0]);
              R && R.isWrapped ? M[M.length - 1] += z : M.push(z);
            }
          }
          return M.map((E) => E.replace(k, " ")).join(p.isWindows ? `\r
` : `
`);
        }
        clearSelection() {
          this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
        }
        refresh(x) {
          this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), p.isLinux && x && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
        }
        _refresh() {
          this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
        }
        _isClickInSelection(x) {
          const S = this._getMouseBufferCoords(x), T = this._model.finalSelectionStart, M = this._model.finalSelectionEnd;
          return !!(T && M && S) && this._areCoordsInSelection(S, T, M);
        }
        isCellInSelection(x, S) {
          const T = this._model.finalSelectionStart, M = this._model.finalSelectionEnd;
          return !(!T || !M) && this._areCoordsInSelection([x, S], T, M);
        }
        _areCoordsInSelection(x, S, T) {
          return x[1] > S[1] && x[1] < T[1] || S[1] === T[1] && x[1] === S[1] && x[0] >= S[0] && x[0] < T[0] || S[1] < T[1] && x[1] === T[1] && x[0] < T[0] || S[1] < T[1] && x[1] === S[1] && x[0] >= S[0];
        }
        _selectWordAtCursor(x, S) {
          var T, M;
          const E = (M = (T = this._linkifier.currentLink) === null || T === void 0 ? void 0 : T.link) === null || M === void 0 ? void 0 : M.range;
          if (E) return this._model.selectionStart = [E.start.x - 1, E.start.y - 1], this._model.selectionStartLength = (0, g.getRangeLength)(E, this._bufferService.cols), this._model.selectionEnd = void 0, !0;
          const R = this._getMouseBufferCoords(x);
          return !!R && (this._selectWordAt(R, S), this._model.selectionEnd = void 0, !0);
        }
        selectAll() {
          this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();
        }
        selectLines(x, S) {
          this._model.clearSelection(), x = Math.max(x, 0), S = Math.min(S, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, x], this._model.selectionEnd = [this._bufferService.cols, S], this.refresh(), this._onSelectionChange.fire();
        }
        _handleTrim(x) {
          this._model.handleTrim(x) && this.refresh();
        }
        _getMouseBufferCoords(x) {
          const S = this._mouseService.getCoords(x, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);
          if (S) return S[0]--, S[1]--, S[1] += this._bufferService.buffer.ydisp, S;
        }
        _getMouseEventScrollAmount(x) {
          let S = (0, h.getCoordsRelativeToElement)(this._coreBrowserService.window, x, this._screenElement)[1];
          const T = this._renderService.dimensions.css.canvas.height;
          return S >= 0 && S <= T ? 0 : (S > T && (S -= T), S = Math.min(Math.max(S, -50), 50), S /= 50, S / Math.abs(S) + Math.round(14 * S));
        }
        shouldForceSelection(x) {
          return p.isMac ? x.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : x.shiftKey;
        }
        handleMouseDown(x) {
          if (this._mouseDownTimeStamp = x.timeStamp, (x.button !== 2 || !this.hasSelection) && x.button === 0) {
            if (!this._enabled) {
              if (!this.shouldForceSelection(x)) return;
              x.stopPropagation();
            }
            x.preventDefault(), this._dragScrollAmount = 0, this._enabled && x.shiftKey ? this._handleIncrementalClick(x) : x.detail === 1 ? this._handleSingleClick(x) : x.detail === 2 ? this._handleDoubleClick(x) : x.detail === 3 && this._handleTripleClick(x), this._addMouseDownListeners(), this.refresh(!0);
          }
        }
        _addMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
        }
        _removeMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
        }
        _handleIncrementalClick(x) {
          this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(x));
        }
        _handleSingleClick(x) {
          if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(x) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(x), !this._model.selectionStart) return;
          this._model.selectionEnd = void 0;
          const S = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
          S && S.length !== this._model.selectionStart[0] && S.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
        }
        _handleDoubleClick(x) {
          this._selectWordAtCursor(x, !0) && (this._activeSelectionMode = 1);
        }
        _handleTripleClick(x) {
          const S = this._getMouseBufferCoords(x);
          S && (this._activeSelectionMode = 2, this._selectLineAt(S[1]));
        }
        shouldColumnSelect(x) {
          return x.altKey && !(p.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
        }
        _handleMouseMove(x) {
          if (x.stopImmediatePropagation(), !this._model.selectionStart) return;
          const S = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
          if (this._model.selectionEnd = this._getMouseBufferCoords(x), !this._model.selectionEnd) return void this.refresh(!0);
          this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(x), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
          const T = this._bufferService.buffer;
          if (this._model.selectionEnd[1] < T.lines.length) {
            const M = T.lines.get(this._model.selectionEnd[1]);
            M && M.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0]++;
          }
          S && S[0] === this._model.selectionEnd[0] && S[1] === this._model.selectionEnd[1] || this.refresh(!0);
        }
        _dragScroll() {
          if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
            this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: !1 });
            const x = this._bufferService.buffer;
            this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(x.ydisp + this._bufferService.rows, x.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = x.ydisp), this.refresh();
          }
        }
        _handleMouseUp(x) {
          const S = x.timeStamp - this._mouseDownTimeStamp;
          if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && S < 500 && x.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
              const T = this._mouseService.getCoords(x, this._element, this._bufferService.cols, this._bufferService.rows, !1);
              if (T && T[0] !== void 0 && T[1] !== void 0) {
                const M = (0, f.moveToCellSequence)(T[0] - 1, T[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                this._coreService.triggerDataEvent(M, !0);
              }
            }
          } else this._fireEventIfSelectionChanged();
        }
        _fireEventIfSelectionChanged() {
          const x = this._model.finalSelectionStart, S = this._model.finalSelectionEnd, T = !(!x || !S || x[0] === S[0] && x[1] === S[1]);
          T ? x && S && (this._oldSelectionStart && this._oldSelectionEnd && x[0] === this._oldSelectionStart[0] && x[1] === this._oldSelectionStart[1] && S[0] === this._oldSelectionEnd[0] && S[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(x, S, T)) : this._oldHasSelection && this._fireOnSelectionChange(x, S, T);
        }
        _fireOnSelectionChange(x, S, T) {
          this._oldSelectionStart = x, this._oldSelectionEnd = S, this._oldHasSelection = T, this._onSelectionChange.fire();
        }
        _handleBufferActivate(x) {
          this.clearSelection(), this._trimListener.dispose(), this._trimListener = x.activeBuffer.lines.onTrim((S) => this._handleTrim(S));
        }
        _convertViewportColToCharacterIndex(x, S) {
          let T = S;
          for (let M = 0; S >= M; M++) {
            const E = x.loadCell(M, this._workCell).getChars().length;
            this._workCell.getWidth() === 0 ? T-- : E > 1 && S !== M && (T += E - 1);
          }
          return T;
        }
        setSelection(x, S, T) {
          this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [x, S], this._model.selectionStartLength = T, this.refresh(), this._fireEventIfSelectionChanged();
        }
        rightClickSelect(x) {
          this._isClickInSelection(x) || (this._selectWordAtCursor(x, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());
        }
        _getWordAt(x, S, T = !0, M = !0) {
          if (x[0] >= this._bufferService.cols) return;
          const E = this._bufferService.buffer, R = E.lines.get(x[1]);
          if (!R) return;
          const z = E.translateBufferLineToString(x[1], !1);
          let F = this._convertViewportColToCharacterIndex(R, x[0]), j = F;
          const U = x[0] - F;
          let $ = 0, I = 0, O = 0, P = 0;
          if (z.charAt(F) === " ") {
            for (; F > 0 && z.charAt(F - 1) === " "; ) F--;
            for (; j < z.length && z.charAt(j + 1) === " "; ) j++;
          } else {
            let X = x[0], G = x[0];
            R.getWidth(X) === 0 && ($++, X--), R.getWidth(G) === 2 && (I++, G++);
            const he = R.getString(G).length;
            for (he > 1 && (P += he - 1, j += he - 1); X > 0 && F > 0 && !this._isCharWordSeparator(R.loadCell(X - 1, this._workCell)); ) {
              R.loadCell(X - 1, this._workCell);
              const A = this._workCell.getChars().length;
              this._workCell.getWidth() === 0 ? ($++, X--) : A > 1 && (O += A - 1, F -= A - 1), F--, X--;
            }
            for (; G < R.length && j + 1 < z.length && !this._isCharWordSeparator(R.loadCell(G + 1, this._workCell)); ) {
              R.loadCell(G + 1, this._workCell);
              const A = this._workCell.getChars().length;
              this._workCell.getWidth() === 2 ? (I++, G++) : A > 1 && (P += A - 1, j += A - 1), j++, G++;
            }
          }
          j++;
          let q = F + U - $ + O, Q = Math.min(this._bufferService.cols, j - F + $ + I - O - P);
          if (S || z.slice(F, j).trim() !== "") {
            if (T && q === 0 && R.getCodePoint(0) !== 32) {
              const X = E.lines.get(x[1] - 1);
              if (X && R.isWrapped && X.getCodePoint(this._bufferService.cols - 1) !== 32) {
                const G = this._getWordAt([this._bufferService.cols - 1, x[1] - 1], !1, !0, !1);
                if (G) {
                  const he = this._bufferService.cols - G.start;
                  q -= he, Q += he;
                }
              }
            }
            if (M && q + Q === this._bufferService.cols && R.getCodePoint(this._bufferService.cols - 1) !== 32) {
              const X = E.lines.get(x[1] + 1);
              if (X != null && X.isWrapped && X.getCodePoint(0) !== 32) {
                const G = this._getWordAt([0, x[1] + 1], !1, !1, !0);
                G && (Q += G.length);
              }
            }
            return { start: q, length: Q };
          }
        }
        _selectWordAt(x, S) {
          const T = this._getWordAt(x, S);
          if (T) {
            for (; T.start < 0; ) T.start += this._bufferService.cols, x[1]--;
            this._model.selectionStart = [T.start, x[1]], this._model.selectionStartLength = T.length;
          }
        }
        _selectToWordAt(x) {
          const S = this._getWordAt(x, !0);
          if (S) {
            let T = x[1];
            for (; S.start < 0; ) S.start += this._bufferService.cols, T--;
            if (!this._model.areSelectionValuesReversed()) for (; S.start + S.length > this._bufferService.cols; ) S.length -= this._bufferService.cols, T++;
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? S.start : S.start + S.length, T];
          }
        }
        _isCharWordSeparator(x) {
          return x.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(x.getChars()) >= 0;
        }
        _selectLineAt(x) {
          const S = this._bufferService.buffer.getWrappedRangeForLine(x), T = { start: { x: 0, y: S.first }, end: { x: this._bufferService.cols - 1, y: S.last } };
          this._model.selectionStart = [0, S.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, g.getRangeLength)(T, this._bufferService.cols);
        }
      };
      a.SelectionService = C = c([u(3, y.IBufferService), u(4, y.ICoreService), u(5, _.IMouseService), u(6, y.IOptionsService), u(7, _.IRenderService), u(8, _.ICoreBrowserService)], C);
    }, 4725: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.IThemeService = a.ICharacterJoinerService = a.ISelectionService = a.IRenderService = a.IMouseService = a.ICoreBrowserService = a.ICharSizeService = void 0;
      const c = l(8343);
      a.ICharSizeService = (0, c.createDecorator)("CharSizeService"), a.ICoreBrowserService = (0, c.createDecorator)("CoreBrowserService"), a.IMouseService = (0, c.createDecorator)("MouseService"), a.IRenderService = (0, c.createDecorator)("RenderService"), a.ISelectionService = (0, c.createDecorator)("SelectionService"), a.ICharacterJoinerService = (0, c.createDecorator)("CharacterJoinerService"), a.IThemeService = (0, c.createDecorator)("ThemeService");
    }, 6731: function(o, a, l) {
      var c = this && this.__decorate || function(C, x, S, T) {
        var M, E = arguments.length, R = E < 3 ? x : T === null ? T = Object.getOwnPropertyDescriptor(x, S) : T;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") R = Reflect.decorate(C, x, S, T);
        else for (var z = C.length - 1; z >= 0; z--) (M = C[z]) && (R = (E < 3 ? M(R) : E > 3 ? M(x, S, R) : M(x, S)) || R);
        return E > 3 && R && Object.defineProperty(x, S, R), R;
      }, u = this && this.__param || function(C, x) {
        return function(S, T) {
          x(S, T, C);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ThemeService = a.DEFAULT_ANSI_COLORS = void 0;
      const h = l(7239), f = l(8055), m = l(8460), _ = l(844), v = l(2585), d = f.css.toColor("#ffffff"), p = f.css.toColor("#000000"), g = f.css.toColor("#ffffff"), b = f.css.toColor("#000000"), y = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
      a.DEFAULT_ANSI_COLORS = Object.freeze((() => {
        const C = [f.css.toColor("#2e3436"), f.css.toColor("#cc0000"), f.css.toColor("#4e9a06"), f.css.toColor("#c4a000"), f.css.toColor("#3465a4"), f.css.toColor("#75507b"), f.css.toColor("#06989a"), f.css.toColor("#d3d7cf"), f.css.toColor("#555753"), f.css.toColor("#ef2929"), f.css.toColor("#8ae234"), f.css.toColor("#fce94f"), f.css.toColor("#729fcf"), f.css.toColor("#ad7fa8"), f.css.toColor("#34e2e2"), f.css.toColor("#eeeeec")], x = [0, 95, 135, 175, 215, 255];
        for (let S = 0; S < 216; S++) {
          const T = x[S / 36 % 6 | 0], M = x[S / 6 % 6 | 0], E = x[S % 6];
          C.push({ css: f.channels.toCss(T, M, E), rgba: f.channels.toRgba(T, M, E) });
        }
        for (let S = 0; S < 24; S++) {
          const T = 8 + 10 * S;
          C.push({ css: f.channels.toCss(T, T, T), rgba: f.channels.toRgba(T, T, T) });
        }
        return C;
      })());
      let w = a.ThemeService = class extends _.Disposable {
        get colors() {
          return this._colors;
        }
        constructor(C) {
          super(), this._optionsService = C, this._contrastCache = new h.ColorContrastCache(), this._halfContrastCache = new h.ColorContrastCache(), this._onChangeColors = this.register(new m.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: d, background: p, cursor: g, cursorAccent: b, selectionForeground: void 0, selectionBackgroundTransparent: y, selectionBackgroundOpaque: f.color.blend(p, y), selectionInactiveBackgroundTransparent: y, selectionInactiveBackgroundOpaque: f.color.blend(p, y), ansi: a.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
        }
        _setTheme(C = {}) {
          const x = this._colors;
          if (x.foreground = k(C.foreground, d), x.background = k(C.background, p), x.cursor = k(C.cursor, g), x.cursorAccent = k(C.cursorAccent, b), x.selectionBackgroundTransparent = k(C.selectionBackground, y), x.selectionBackgroundOpaque = f.color.blend(x.background, x.selectionBackgroundTransparent), x.selectionInactiveBackgroundTransparent = k(C.selectionInactiveBackground, x.selectionBackgroundTransparent), x.selectionInactiveBackgroundOpaque = f.color.blend(x.background, x.selectionInactiveBackgroundTransparent), x.selectionForeground = C.selectionForeground ? k(C.selectionForeground, f.NULL_COLOR) : void 0, x.selectionForeground === f.NULL_COLOR && (x.selectionForeground = void 0), f.color.isOpaque(x.selectionBackgroundTransparent) && (x.selectionBackgroundTransparent = f.color.opacity(x.selectionBackgroundTransparent, 0.3)), f.color.isOpaque(x.selectionInactiveBackgroundTransparent) && (x.selectionInactiveBackgroundTransparent = f.color.opacity(x.selectionInactiveBackgroundTransparent, 0.3)), x.ansi = a.DEFAULT_ANSI_COLORS.slice(), x.ansi[0] = k(C.black, a.DEFAULT_ANSI_COLORS[0]), x.ansi[1] = k(C.red, a.DEFAULT_ANSI_COLORS[1]), x.ansi[2] = k(C.green, a.DEFAULT_ANSI_COLORS[2]), x.ansi[3] = k(C.yellow, a.DEFAULT_ANSI_COLORS[3]), x.ansi[4] = k(C.blue, a.DEFAULT_ANSI_COLORS[4]), x.ansi[5] = k(C.magenta, a.DEFAULT_ANSI_COLORS[5]), x.ansi[6] = k(C.cyan, a.DEFAULT_ANSI_COLORS[6]), x.ansi[7] = k(C.white, a.DEFAULT_ANSI_COLORS[7]), x.ansi[8] = k(C.brightBlack, a.DEFAULT_ANSI_COLORS[8]), x.ansi[9] = k(C.brightRed, a.DEFAULT_ANSI_COLORS[9]), x.ansi[10] = k(C.brightGreen, a.DEFAULT_ANSI_COLORS[10]), x.ansi[11] = k(C.brightYellow, a.DEFAULT_ANSI_COLORS[11]), x.ansi[12] = k(C.brightBlue, a.DEFAULT_ANSI_COLORS[12]), x.ansi[13] = k(C.brightMagenta, a.DEFAULT_ANSI_COLORS[13]), x.ansi[14] = k(C.brightCyan, a.DEFAULT_ANSI_COLORS[14]), x.ansi[15] = k(C.brightWhite, a.DEFAULT_ANSI_COLORS[15]), C.extendedAnsi) {
            const S = Math.min(x.ansi.length - 16, C.extendedAnsi.length);
            for (let T = 0; T < S; T++) x.ansi[T + 16] = k(C.extendedAnsi[T], a.DEFAULT_ANSI_COLORS[T + 16]);
          }
          this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
        }
        restoreColor(C) {
          this._restoreColor(C), this._onChangeColors.fire(this.colors);
        }
        _restoreColor(C) {
          if (C !== void 0) switch (C) {
            case 256:
              this._colors.foreground = this._restoreColors.foreground;
              break;
            case 257:
              this._colors.background = this._restoreColors.background;
              break;
            case 258:
              this._colors.cursor = this._restoreColors.cursor;
              break;
            default:
              this._colors.ansi[C] = this._restoreColors.ansi[C];
          }
          else for (let x = 0; x < this._restoreColors.ansi.length; ++x) this._colors.ansi[x] = this._restoreColors.ansi[x];
        }
        modifyColors(C) {
          C(this._colors), this._onChangeColors.fire(this.colors);
        }
        _updateRestoreColors() {
          this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
        }
      };
      function k(C, x) {
        if (C !== void 0) try {
          return f.css.toColor(C);
        } catch {
        }
        return x;
      }
      a.ThemeService = w = c([u(0, v.IOptionsService)], w);
    }, 6349: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CircularList = void 0;
      const c = l(8460), u = l(844);
      class h extends u.Disposable {
        constructor(m) {
          super(), this._maxLength = m, this.onDeleteEmitter = this.register(new c.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new c.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new c.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(m) {
          if (this._maxLength === m) return;
          const _ = new Array(m);
          for (let v = 0; v < Math.min(m, this.length); v++) _[v] = this._array[this._getCyclicIndex(v)];
          this._array = _, this._maxLength = m, this._startIndex = 0;
        }
        get length() {
          return this._length;
        }
        set length(m) {
          if (m > this._length) for (let _ = this._length; _ < m; _++) this._array[_] = void 0;
          this._length = m;
        }
        get(m) {
          return this._array[this._getCyclicIndex(m)];
        }
        set(m, _) {
          this._array[this._getCyclicIndex(m)] = _;
        }
        push(m) {
          this._array[this._getCyclicIndex(this._length)] = m, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
        }
        recycle() {
          if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
          return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
        }
        get isFull() {
          return this._length === this._maxLength;
        }
        pop() {
          return this._array[this._getCyclicIndex(this._length-- - 1)];
        }
        splice(m, _, ...v) {
          if (_) {
            for (let d = m; d < this._length - _; d++) this._array[this._getCyclicIndex(d)] = this._array[this._getCyclicIndex(d + _)];
            this._length -= _, this.onDeleteEmitter.fire({ index: m, amount: _ });
          }
          for (let d = this._length - 1; d >= m; d--) this._array[this._getCyclicIndex(d + v.length)] = this._array[this._getCyclicIndex(d)];
          for (let d = 0; d < v.length; d++) this._array[this._getCyclicIndex(m + d)] = v[d];
          if (v.length && this.onInsertEmitter.fire({ index: m, amount: v.length }), this._length + v.length > this._maxLength) {
            const d = this._length + v.length - this._maxLength;
            this._startIndex += d, this._length = this._maxLength, this.onTrimEmitter.fire(d);
          } else this._length += v.length;
        }
        trimStart(m) {
          m > this._length && (m = this._length), this._startIndex += m, this._length -= m, this.onTrimEmitter.fire(m);
        }
        shiftElements(m, _, v) {
          if (!(_ <= 0)) {
            if (m < 0 || m >= this._length) throw new Error("start argument out of range");
            if (m + v < 0) throw new Error("Cannot shift elements in list beyond index 0");
            if (v > 0) {
              for (let p = _ - 1; p >= 0; p--) this.set(m + p + v, this.get(m + p));
              const d = m + _ + v - this._length;
              if (d > 0) for (this._length += d; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
            } else for (let d = 0; d < _; d++) this.set(m + d + v, this.get(m + d));
          }
        }
        _getCyclicIndex(m) {
          return (this._startIndex + m) % this._maxLength;
        }
      }
      a.CircularList = h;
    }, 1439: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.clone = void 0, a.clone = function l(c, u = 5) {
        if (typeof c != "object") return c;
        const h = Array.isArray(c) ? [] : {};
        for (const f in c) h[f] = u <= 1 ? c[f] : c[f] && l(c[f], u - 1);
        return h;
      };
    }, 8055: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.contrastRatio = a.toPaddedHex = a.rgba = a.rgb = a.css = a.color = a.channels = a.NULL_COLOR = void 0;
      const c = l(6114);
      let u = 0, h = 0, f = 0, m = 0;
      var _, v, d, p, g;
      function b(w) {
        const k = w.toString(16);
        return k.length < 2 ? "0" + k : k;
      }
      function y(w, k) {
        return w < k ? (k + 0.05) / (w + 0.05) : (w + 0.05) / (k + 0.05);
      }
      a.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(w) {
        w.toCss = function(k, C, x, S) {
          return S !== void 0 ? `#${b(k)}${b(C)}${b(x)}${b(S)}` : `#${b(k)}${b(C)}${b(x)}`;
        }, w.toRgba = function(k, C, x, S = 255) {
          return (k << 24 | C << 16 | x << 8 | S) >>> 0;
        };
      }(_ || (a.channels = _ = {})), function(w) {
        function k(C, x) {
          return m = Math.round(255 * x), [u, h, f] = g.toChannels(C.rgba), { css: _.toCss(u, h, f, m), rgba: _.toRgba(u, h, f, m) };
        }
        w.blend = function(C, x) {
          if (m = (255 & x.rgba) / 255, m === 1) return { css: x.css, rgba: x.rgba };
          const S = x.rgba >> 24 & 255, T = x.rgba >> 16 & 255, M = x.rgba >> 8 & 255, E = C.rgba >> 24 & 255, R = C.rgba >> 16 & 255, z = C.rgba >> 8 & 255;
          return u = E + Math.round((S - E) * m), h = R + Math.round((T - R) * m), f = z + Math.round((M - z) * m), { css: _.toCss(u, h, f), rgba: _.toRgba(u, h, f) };
        }, w.isOpaque = function(C) {
          return (255 & C.rgba) == 255;
        }, w.ensureContrastRatio = function(C, x, S) {
          const T = g.ensureContrastRatio(C.rgba, x.rgba, S);
          if (T) return g.toColor(T >> 24 & 255, T >> 16 & 255, T >> 8 & 255);
        }, w.opaque = function(C) {
          const x = (255 | C.rgba) >>> 0;
          return [u, h, f] = g.toChannels(x), { css: _.toCss(u, h, f), rgba: x };
        }, w.opacity = k, w.multiplyOpacity = function(C, x) {
          return m = 255 & C.rgba, k(C, m * x / 255);
        }, w.toColorRGB = function(C) {
          return [C.rgba >> 24 & 255, C.rgba >> 16 & 255, C.rgba >> 8 & 255];
        };
      }(v || (a.color = v = {})), function(w) {
        let k, C;
        if (!c.isNode) {
          const x = document.createElement("canvas");
          x.width = 1, x.height = 1;
          const S = x.getContext("2d", { willReadFrequently: !0 });
          S && (k = S, k.globalCompositeOperation = "copy", C = k.createLinearGradient(0, 0, 1, 1));
        }
        w.toColor = function(x) {
          if (x.match(/#[\da-f]{3,8}/i)) switch (x.length) {
            case 4:
              return u = parseInt(x.slice(1, 2).repeat(2), 16), h = parseInt(x.slice(2, 3).repeat(2), 16), f = parseInt(x.slice(3, 4).repeat(2), 16), g.toColor(u, h, f);
            case 5:
              return u = parseInt(x.slice(1, 2).repeat(2), 16), h = parseInt(x.slice(2, 3).repeat(2), 16), f = parseInt(x.slice(3, 4).repeat(2), 16), m = parseInt(x.slice(4, 5).repeat(2), 16), g.toColor(u, h, f, m);
            case 7:
              return { css: x, rgba: (parseInt(x.slice(1), 16) << 8 | 255) >>> 0 };
            case 9:
              return { css: x, rgba: parseInt(x.slice(1), 16) >>> 0 };
          }
          const S = x.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (S) return u = parseInt(S[1]), h = parseInt(S[2]), f = parseInt(S[3]), m = Math.round(255 * (S[5] === void 0 ? 1 : parseFloat(S[5]))), g.toColor(u, h, f, m);
          if (!k || !C) throw new Error("css.toColor: Unsupported css format");
          if (k.fillStyle = C, k.fillStyle = x, typeof k.fillStyle != "string") throw new Error("css.toColor: Unsupported css format");
          if (k.fillRect(0, 0, 1, 1), [u, h, f, m] = k.getImageData(0, 0, 1, 1).data, m !== 255) throw new Error("css.toColor: Unsupported css format");
          return { rgba: _.toRgba(u, h, f, m), css: x };
        };
      }(d || (a.css = d = {})), function(w) {
        function k(C, x, S) {
          const T = C / 255, M = x / 255, E = S / 255;
          return 0.2126 * (T <= 0.03928 ? T / 12.92 : Math.pow((T + 0.055) / 1.055, 2.4)) + 0.7152 * (M <= 0.03928 ? M / 12.92 : Math.pow((M + 0.055) / 1.055, 2.4)) + 0.0722 * (E <= 0.03928 ? E / 12.92 : Math.pow((E + 0.055) / 1.055, 2.4));
        }
        w.relativeLuminance = function(C) {
          return k(C >> 16 & 255, C >> 8 & 255, 255 & C);
        }, w.relativeLuminance2 = k;
      }(p || (a.rgb = p = {})), function(w) {
        function k(x, S, T) {
          const M = x >> 24 & 255, E = x >> 16 & 255, R = x >> 8 & 255;
          let z = S >> 24 & 255, F = S >> 16 & 255, j = S >> 8 & 255, U = y(p.relativeLuminance2(z, F, j), p.relativeLuminance2(M, E, R));
          for (; U < T && (z > 0 || F > 0 || j > 0); ) z -= Math.max(0, Math.ceil(0.1 * z)), F -= Math.max(0, Math.ceil(0.1 * F)), j -= Math.max(0, Math.ceil(0.1 * j)), U = y(p.relativeLuminance2(z, F, j), p.relativeLuminance2(M, E, R));
          return (z << 24 | F << 16 | j << 8 | 255) >>> 0;
        }
        function C(x, S, T) {
          const M = x >> 24 & 255, E = x >> 16 & 255, R = x >> 8 & 255;
          let z = S >> 24 & 255, F = S >> 16 & 255, j = S >> 8 & 255, U = y(p.relativeLuminance2(z, F, j), p.relativeLuminance2(M, E, R));
          for (; U < T && (z < 255 || F < 255 || j < 255); ) z = Math.min(255, z + Math.ceil(0.1 * (255 - z))), F = Math.min(255, F + Math.ceil(0.1 * (255 - F))), j = Math.min(255, j + Math.ceil(0.1 * (255 - j))), U = y(p.relativeLuminance2(z, F, j), p.relativeLuminance2(M, E, R));
          return (z << 24 | F << 16 | j << 8 | 255) >>> 0;
        }
        w.ensureContrastRatio = function(x, S, T) {
          const M = p.relativeLuminance(x >> 8), E = p.relativeLuminance(S >> 8);
          if (y(M, E) < T) {
            if (E < M) {
              const F = k(x, S, T), j = y(M, p.relativeLuminance(F >> 8));
              if (j < T) {
                const U = C(x, S, T);
                return j > y(M, p.relativeLuminance(U >> 8)) ? F : U;
              }
              return F;
            }
            const R = C(x, S, T), z = y(M, p.relativeLuminance(R >> 8));
            if (z < T) {
              const F = k(x, S, T);
              return z > y(M, p.relativeLuminance(F >> 8)) ? R : F;
            }
            return R;
          }
        }, w.reduceLuminance = k, w.increaseLuminance = C, w.toChannels = function(x) {
          return [x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, 255 & x];
        }, w.toColor = function(x, S, T, M) {
          return { css: _.toCss(x, S, T, M), rgba: _.toRgba(x, S, T, M) };
        };
      }(g || (a.rgba = g = {})), a.toPaddedHex = b, a.contrastRatio = y;
    }, 8969: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreTerminal = void 0;
      const c = l(844), u = l(2585), h = l(4348), f = l(7866), m = l(744), _ = l(7302), v = l(6975), d = l(8460), p = l(1753), g = l(1480), b = l(7994), y = l(9282), w = l(5435), k = l(5981), C = l(2660);
      let x = !1;
      class S extends c.Disposable {
        get onScroll() {
          return this._onScrollApi || (this._onScrollApi = this.register(new d.EventEmitter()), this._onScroll.event((M) => {
            var E;
            (E = this._onScrollApi) === null || E === void 0 || E.fire(M.position);
          })), this._onScrollApi.event;
        }
        get cols() {
          return this._bufferService.cols;
        }
        get rows() {
          return this._bufferService.rows;
        }
        get buffers() {
          return this._bufferService.buffers;
        }
        get options() {
          return this.optionsService.options;
        }
        set options(M) {
          for (const E in M) this.optionsService.options[E] = M[E];
        }
        constructor(M) {
          super(), this._windowsWrappingHeuristics = this.register(new c.MutableDisposable()), this._onBinary = this.register(new d.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new d.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new d.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new d.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new d.EventEmitter()), this._instantiationService = new h.InstantiationService(), this.optionsService = this.register(new _.OptionsService(M)), this._instantiationService.setService(u.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(m.BufferService)), this._instantiationService.setService(u.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(f.LogService)), this._instantiationService.setService(u.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(v.CoreService)), this._instantiationService.setService(u.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(p.CoreMouseService)), this._instantiationService.setService(u.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(g.UnicodeService)), this._instantiationService.setService(u.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(b.CharsetService), this._instantiationService.setService(u.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(C.OscLinkService), this._instantiationService.setService(u.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new w.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, d.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, d.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, d.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, d.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((E) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this.register(this._inputHandler.onScroll((E) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this._writeBuffer = this.register(new k.WriteBuffer((E, R) => this._inputHandler.parse(E, R))), this.register((0, d.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
        }
        write(M, E) {
          this._writeBuffer.write(M, E);
        }
        writeSync(M, E) {
          this._logService.logLevel <= u.LogLevelEnum.WARN && !x && (this._logService.warn("writeSync is unreliable and will be removed soon."), x = !0), this._writeBuffer.writeSync(M, E);
        }
        resize(M, E) {
          isNaN(M) || isNaN(E) || (M = Math.max(M, m.MINIMUM_COLS), E = Math.max(E, m.MINIMUM_ROWS), this._bufferService.resize(M, E));
        }
        scroll(M, E = !1) {
          this._bufferService.scroll(M, E);
        }
        scrollLines(M, E, R) {
          this._bufferService.scrollLines(M, E, R);
        }
        scrollPages(M) {
          this.scrollLines(M * (this.rows - 1));
        }
        scrollToTop() {
          this.scrollLines(-this._bufferService.buffer.ydisp);
        }
        scrollToBottom() {
          this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
        }
        scrollToLine(M) {
          const E = M - this._bufferService.buffer.ydisp;
          E !== 0 && this.scrollLines(E);
        }
        registerEscHandler(M, E) {
          return this._inputHandler.registerEscHandler(M, E);
        }
        registerDcsHandler(M, E) {
          return this._inputHandler.registerDcsHandler(M, E);
        }
        registerCsiHandler(M, E) {
          return this._inputHandler.registerCsiHandler(M, E);
        }
        registerOscHandler(M, E) {
          return this._inputHandler.registerOscHandler(M, E);
        }
        _setup() {
          this._handleWindowsPtyOptionChange();
        }
        reset() {
          this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
        }
        _handleWindowsPtyOptionChange() {
          let M = !1;
          const E = this.optionsService.rawOptions.windowsPty;
          E && E.buildNumber !== void 0 && E.buildNumber !== void 0 ? M = E.backend === "conpty" && E.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (M = !0), M ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
        }
        _enableWindowsWrappingHeuristics() {
          if (!this._windowsWrappingHeuristics.value) {
            const M = [];
            M.push(this.onLineFeed(y.updateWindowsModeWrappedState.bind(null, this._bufferService))), M.push(this.registerCsiHandler({ final: "H" }, () => ((0, y.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics.value = (0, c.toDisposable)(() => {
              for (const E of M) E.dispose();
            });
          }
        }
      }
      a.CoreTerminal = S;
    }, 8460: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.forwardEvent = a.EventEmitter = void 0, a.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = !1;
        }
        get event() {
          return this._event || (this._event = (l) => (this._listeners.push(l), { dispose: () => {
            if (!this._disposed) {
              for (let c = 0; c < this._listeners.length; c++) if (this._listeners[c] === l) return void this._listeners.splice(c, 1);
            }
          } })), this._event;
        }
        fire(l, c) {
          const u = [];
          for (let h = 0; h < this._listeners.length; h++) u.push(this._listeners[h]);
          for (let h = 0; h < u.length; h++) u[h].call(void 0, l, c);
        }
        dispose() {
          this.clearListeners(), this._disposed = !0;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, a.forwardEvent = function(l, c) {
        return l((u) => c.fire(u));
      };
    }, 5435: function(o, a, l) {
      var c = this && this.__decorate || function(U, $, I, O) {
        var P, q = arguments.length, Q = q < 3 ? $ : O === null ? O = Object.getOwnPropertyDescriptor($, I) : O;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Q = Reflect.decorate(U, $, I, O);
        else for (var X = U.length - 1; X >= 0; X--) (P = U[X]) && (Q = (q < 3 ? P(Q) : q > 3 ? P($, I, Q) : P($, I)) || Q);
        return q > 3 && Q && Object.defineProperty($, I, Q), Q;
      }, u = this && this.__param || function(U, $) {
        return function(I, O) {
          $(I, O, U);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.InputHandler = a.WindowsOptionsReportType = void 0;
      const h = l(2584), f = l(7116), m = l(2015), _ = l(844), v = l(482), d = l(8437), p = l(8460), g = l(643), b = l(511), y = l(3734), w = l(2585), k = l(6242), C = l(6351), x = l(5941), S = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, T = 131072;
      function M(U, $) {
        if (U > 24) return $.setWinLines || !1;
        switch (U) {
          case 1:
            return !!$.restoreWin;
          case 2:
            return !!$.minimizeWin;
          case 3:
            return !!$.setWinPosition;
          case 4:
            return !!$.setWinSizePixels;
          case 5:
            return !!$.raiseWin;
          case 6:
            return !!$.lowerWin;
          case 7:
            return !!$.refreshWin;
          case 8:
            return !!$.setWinSizeChars;
          case 9:
            return !!$.maximizeWin;
          case 10:
            return !!$.fullscreenWin;
          case 11:
            return !!$.getWinState;
          case 13:
            return !!$.getWinPosition;
          case 14:
            return !!$.getWinSizePixels;
          case 15:
            return !!$.getScreenSizePixels;
          case 16:
            return !!$.getCellSizePixels;
          case 18:
            return !!$.getWinSizeChars;
          case 19:
            return !!$.getScreenSizeChars;
          case 20:
            return !!$.getIconTitle;
          case 21:
            return !!$.getWinTitle;
          case 22:
            return !!$.pushTitle;
          case 23:
            return !!$.popTitle;
          case 24:
            return !!$.setWinLines;
        }
        return !1;
      }
      var E;
      (function(U) {
        U[U.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", U[U.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
      })(E || (a.WindowsOptionsReportType = E = {}));
      let R = 0;
      class z extends _.Disposable {
        getAttrData() {
          return this._curAttrData;
        }
        constructor($, I, O, P, q, Q, X, G, he = new m.EscapeSequenceParser()) {
          super(), this._bufferService = $, this._charsetService = I, this._coreService = O, this._logService = P, this._optionsService = q, this._oscLinkService = Q, this._coreMouseService = X, this._unicodeService = G, this._parser = he, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new v.StringToUtf32(), this._utf8Decoder = new v.Utf8ToUtf32(), this._workCell = new b.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = d.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = d.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new p.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new p.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new p.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new p.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new p.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new p.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new p.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new p.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new p.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new p.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new p.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new p.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new p.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new F(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((A) => this._activeBuffer = A.activeBuffer)), this._parser.setCsiHandlerFallback((A, N) => {
            this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(A), params: N.toArray() });
          }), this._parser.setEscHandlerFallback((A) => {
            this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(A) });
          }), this._parser.setExecuteHandlerFallback((A) => {
            this._logService.debug("Unknown EXECUTE code: ", { code: A });
          }), this._parser.setOscHandlerFallback((A, N, V) => {
            this._logService.debug("Unknown OSC code: ", { identifier: A, action: N, data: V });
          }), this._parser.setDcsHandlerFallback((A, N, V) => {
            N === "HOOK" && (V = V.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(A), action: N, payload: V });
          }), this._parser.setPrintHandler((A, N, V) => this.print(A, N, V)), this._parser.registerCsiHandler({ final: "@" }, (A) => this.insertChars(A)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (A) => this.scrollLeft(A)), this._parser.registerCsiHandler({ final: "A" }, (A) => this.cursorUp(A)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (A) => this.scrollRight(A)), this._parser.registerCsiHandler({ final: "B" }, (A) => this.cursorDown(A)), this._parser.registerCsiHandler({ final: "C" }, (A) => this.cursorForward(A)), this._parser.registerCsiHandler({ final: "D" }, (A) => this.cursorBackward(A)), this._parser.registerCsiHandler({ final: "E" }, (A) => this.cursorNextLine(A)), this._parser.registerCsiHandler({ final: "F" }, (A) => this.cursorPrecedingLine(A)), this._parser.registerCsiHandler({ final: "G" }, (A) => this.cursorCharAbsolute(A)), this._parser.registerCsiHandler({ final: "H" }, (A) => this.cursorPosition(A)), this._parser.registerCsiHandler({ final: "I" }, (A) => this.cursorForwardTab(A)), this._parser.registerCsiHandler({ final: "J" }, (A) => this.eraseInDisplay(A, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (A) => this.eraseInDisplay(A, !0)), this._parser.registerCsiHandler({ final: "K" }, (A) => this.eraseInLine(A, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (A) => this.eraseInLine(A, !0)), this._parser.registerCsiHandler({ final: "L" }, (A) => this.insertLines(A)), this._parser.registerCsiHandler({ final: "M" }, (A) => this.deleteLines(A)), this._parser.registerCsiHandler({ final: "P" }, (A) => this.deleteChars(A)), this._parser.registerCsiHandler({ final: "S" }, (A) => this.scrollUp(A)), this._parser.registerCsiHandler({ final: "T" }, (A) => this.scrollDown(A)), this._parser.registerCsiHandler({ final: "X" }, (A) => this.eraseChars(A)), this._parser.registerCsiHandler({ final: "Z" }, (A) => this.cursorBackwardTab(A)), this._parser.registerCsiHandler({ final: "`" }, (A) => this.charPosAbsolute(A)), this._parser.registerCsiHandler({ final: "a" }, (A) => this.hPositionRelative(A)), this._parser.registerCsiHandler({ final: "b" }, (A) => this.repeatPrecedingCharacter(A)), this._parser.registerCsiHandler({ final: "c" }, (A) => this.sendDeviceAttributesPrimary(A)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (A) => this.sendDeviceAttributesSecondary(A)), this._parser.registerCsiHandler({ final: "d" }, (A) => this.linePosAbsolute(A)), this._parser.registerCsiHandler({ final: "e" }, (A) => this.vPositionRelative(A)), this._parser.registerCsiHandler({ final: "f" }, (A) => this.hVPosition(A)), this._parser.registerCsiHandler({ final: "g" }, (A) => this.tabClear(A)), this._parser.registerCsiHandler({ final: "h" }, (A) => this.setMode(A)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (A) => this.setModePrivate(A)), this._parser.registerCsiHandler({ final: "l" }, (A) => this.resetMode(A)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (A) => this.resetModePrivate(A)), this._parser.registerCsiHandler({ final: "m" }, (A) => this.charAttributes(A)), this._parser.registerCsiHandler({ final: "n" }, (A) => this.deviceStatus(A)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (A) => this.deviceStatusPrivate(A)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (A) => this.softReset(A)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (A) => this.setCursorStyle(A)), this._parser.registerCsiHandler({ final: "r" }, (A) => this.setScrollRegion(A)), this._parser.registerCsiHandler({ final: "s" }, (A) => this.saveCursor(A)), this._parser.registerCsiHandler({ final: "t" }, (A) => this.windowOptions(A)), this._parser.registerCsiHandler({ final: "u" }, (A) => this.restoreCursor(A)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (A) => this.insertColumns(A)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (A) => this.deleteColumns(A)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (A) => this.selectProtected(A)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (A) => this.requestMode(A, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (A) => this.requestMode(A, !1)), this._parser.setExecuteHandler(h.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(h.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(h.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(h.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(h.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(h.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(h.C0.HT, () => this.tab()), this._parser.setExecuteHandler(h.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(h.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(h.C1.IND, () => this.index()), this._parser.setExecuteHandler(h.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(h.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new k.OscHandler((A) => (this.setTitle(A), this.setIconName(A), !0))), this._parser.registerOscHandler(1, new k.OscHandler((A) => this.setIconName(A))), this._parser.registerOscHandler(2, new k.OscHandler((A) => this.setTitle(A))), this._parser.registerOscHandler(4, new k.OscHandler((A) => this.setOrReportIndexedColor(A))), this._parser.registerOscHandler(8, new k.OscHandler((A) => this.setHyperlink(A))), this._parser.registerOscHandler(10, new k.OscHandler((A) => this.setOrReportFgColor(A))), this._parser.registerOscHandler(11, new k.OscHandler((A) => this.setOrReportBgColor(A))), this._parser.registerOscHandler(12, new k.OscHandler((A) => this.setOrReportCursorColor(A))), this._parser.registerOscHandler(104, new k.OscHandler((A) => this.restoreIndexedColor(A))), this._parser.registerOscHandler(110, new k.OscHandler((A) => this.restoreFgColor(A))), this._parser.registerOscHandler(111, new k.OscHandler((A) => this.restoreBgColor(A))), this._parser.registerOscHandler(112, new k.OscHandler((A) => this.restoreCursorColor(A))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
          for (const A in f.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: A }, () => this.selectCharset("(" + A)), this._parser.registerEscHandler({ intermediates: ")", final: A }, () => this.selectCharset(")" + A)), this._parser.registerEscHandler({ intermediates: "*", final: A }, () => this.selectCharset("*" + A)), this._parser.registerEscHandler({ intermediates: "+", final: A }, () => this.selectCharset("+" + A)), this._parser.registerEscHandler({ intermediates: "-", final: A }, () => this.selectCharset("-" + A)), this._parser.registerEscHandler({ intermediates: ".", final: A }, () => this.selectCharset("." + A)), this._parser.registerEscHandler({ intermediates: "/", final: A }, () => this.selectCharset("/" + A));
          this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((A) => (this._logService.error("Parsing error: ", A), A)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new C.DcsHandler((A, N) => this.requestStatusString(A, N)));
        }
        _preserveStack($, I, O, P) {
          this._parseStack.paused = !0, this._parseStack.cursorStartX = $, this._parseStack.cursorStartY = I, this._parseStack.decodedLength = O, this._parseStack.position = P;
        }
        _logSlowResolvingAsync($) {
          this._logService.logLevel <= w.LogLevelEnum.WARN && Promise.race([$, new Promise((I, O) => setTimeout(() => O("#SLOW_TIMEOUT"), 5e3))]).catch((I) => {
            if (I !== "#SLOW_TIMEOUT") throw I;
            console.warn("async parser handler taking longer than 5000 ms");
          });
        }
        _getCurrentLinkId() {
          return this._curAttrData.extended.urlId;
        }
        parse($, I) {
          let O, P = this._activeBuffer.x, q = this._activeBuffer.y, Q = 0;
          const X = this._parseStack.paused;
          if (X) {
            if (O = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, I)) return this._logSlowResolvingAsync(O), O;
            P = this._parseStack.cursorStartX, q = this._parseStack.cursorStartY, this._parseStack.paused = !1, $.length > T && (Q = this._parseStack.position + T);
          }
          if (this._logService.logLevel <= w.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof $ == "string" ? ` "${$}"` : ` "${Array.prototype.map.call($, (G) => String.fromCharCode(G)).join("")}"`), typeof $ == "string" ? $.split("").map((G) => G.charCodeAt(0)) : $), this._parseBuffer.length < $.length && this._parseBuffer.length < T && (this._parseBuffer = new Uint32Array(Math.min($.length, T))), X || this._dirtyRowTracker.clearRange(), $.length > T) for (let G = Q; G < $.length; G += T) {
            const he = G + T < $.length ? G + T : $.length, A = typeof $ == "string" ? this._stringDecoder.decode($.substring(G, he), this._parseBuffer) : this._utf8Decoder.decode($.subarray(G, he), this._parseBuffer);
            if (O = this._parser.parse(this._parseBuffer, A)) return this._preserveStack(P, q, A, G), this._logSlowResolvingAsync(O), O;
          }
          else if (!X) {
            const G = typeof $ == "string" ? this._stringDecoder.decode($, this._parseBuffer) : this._utf8Decoder.decode($, this._parseBuffer);
            if (O = this._parser.parse(this._parseBuffer, G)) return this._preserveStack(P, q, G, 0), this._logSlowResolvingAsync(O), O;
          }
          this._activeBuffer.x === P && this._activeBuffer.y === q || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
        }
        print($, I, O) {
          let P, q;
          const Q = this._charsetService.charset, X = this._optionsService.rawOptions.screenReaderMode, G = this._bufferService.cols, he = this._coreService.decPrivateModes.wraparound, A = this._coreService.modes.insertMode, N = this._curAttrData;
          let V = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && O - I > 0 && V.getWidth(this._activeBuffer.x - 1) === 2 && V.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, N.fg, N.bg, N.extended);
          for (let W = I; W < O; ++W) {
            if (P = $[W], q = this._unicodeService.wcwidth(P), P < 127 && Q) {
              const ie = Q[String.fromCharCode(P)];
              ie && (P = ie.charCodeAt(0));
            }
            if (X && this._onA11yChar.fire((0, v.stringFromCodePoint)(P)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), q || !this._activeBuffer.x) {
              if (this._activeBuffer.x + q - 1 >= G) {
                if (he) {
                  for (; this._activeBuffer.x < G; ) V.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, N.fg, N.bg, N.extended);
                  this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), V = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                } else if (this._activeBuffer.x = G - 1, q === 2) continue;
              }
              if (A && (V.insertCells(this._activeBuffer.x, q, this._activeBuffer.getNullCell(N), N), V.getWidth(G - 1) === 2 && V.setCellFromCodePoint(G - 1, g.NULL_CELL_CODE, g.NULL_CELL_WIDTH, N.fg, N.bg, N.extended)), V.setCellFromCodePoint(this._activeBuffer.x++, P, q, N.fg, N.bg, N.extended), q > 0) for (; --q; ) V.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, N.fg, N.bg, N.extended);
            } else V.getWidth(this._activeBuffer.x - 1) ? V.addCodepointToCell(this._activeBuffer.x - 1, P) : V.addCodepointToCell(this._activeBuffer.x - 2, P);
          }
          O - I > 0 && (V.loadCell(this._activeBuffer.x - 1, this._workCell), this._workCell.getWidth() === 2 || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < G && O - I > 0 && V.getWidth(this._activeBuffer.x) === 0 && !V.hasContent(this._activeBuffer.x) && V.setCellFromCodePoint(this._activeBuffer.x, 0, 1, N.fg, N.bg, N.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        registerCsiHandler($, I) {
          return $.final !== "t" || $.prefix || $.intermediates ? this._parser.registerCsiHandler($, I) : this._parser.registerCsiHandler($, (O) => !M(O.params[0], this._optionsService.rawOptions.windowOptions) || I(O));
        }
        registerDcsHandler($, I) {
          return this._parser.registerDcsHandler($, new C.DcsHandler(I));
        }
        registerEscHandler($, I) {
          return this._parser.registerEscHandler($, I);
        }
        registerOscHandler($, I) {
          return this._parser.registerOscHandler($, new k.OscHandler(I));
        }
        bell() {
          return this._onRequestBell.fire(), !0;
        }
        lineFeed() {
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
        }
        carriageReturn() {
          return this._activeBuffer.x = 0, !0;
        }
        backspace() {
          var $;
          if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
          if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
          else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (!(($ = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) === null || $ === void 0) && $.isWrapped)) {
            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
            const I = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            I.hasWidth(this._activeBuffer.x) && !I.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
          }
          return this._restrictCursor(), !0;
        }
        tab() {
          if (this._activeBuffer.x >= this._bufferService.cols) return !0;
          const $ = this._activeBuffer.x;
          return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - $), !0;
        }
        shiftOut() {
          return this._charsetService.setgLevel(1), !0;
        }
        shiftIn() {
          return this._charsetService.setgLevel(0), !0;
        }
        _restrictCursor($ = this._bufferService.cols - 1) {
          this._activeBuffer.x = Math.min($, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _setCursor($, I) {
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = $, this._activeBuffer.y = this._activeBuffer.scrollTop + I) : (this._activeBuffer.x = $, this._activeBuffer.y = I), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _moveCursor($, I) {
          this._restrictCursor(), this._setCursor(this._activeBuffer.x + $, this._activeBuffer.y + I);
        }
        cursorUp($) {
          const I = this._activeBuffer.y - this._activeBuffer.scrollTop;
          return I >= 0 ? this._moveCursor(0, -Math.min(I, $.params[0] || 1)) : this._moveCursor(0, -($.params[0] || 1)), !0;
        }
        cursorDown($) {
          const I = this._activeBuffer.scrollBottom - this._activeBuffer.y;
          return I >= 0 ? this._moveCursor(0, Math.min(I, $.params[0] || 1)) : this._moveCursor(0, $.params[0] || 1), !0;
        }
        cursorForward($) {
          return this._moveCursor($.params[0] || 1, 0), !0;
        }
        cursorBackward($) {
          return this._moveCursor(-($.params[0] || 1), 0), !0;
        }
        cursorNextLine($) {
          return this.cursorDown($), this._activeBuffer.x = 0, !0;
        }
        cursorPrecedingLine($) {
          return this.cursorUp($), this._activeBuffer.x = 0, !0;
        }
        cursorCharAbsolute($) {
          return this._setCursor(($.params[0] || 1) - 1, this._activeBuffer.y), !0;
        }
        cursorPosition($) {
          return this._setCursor($.length >= 2 ? ($.params[1] || 1) - 1 : 0, ($.params[0] || 1) - 1), !0;
        }
        charPosAbsolute($) {
          return this._setCursor(($.params[0] || 1) - 1, this._activeBuffer.y), !0;
        }
        hPositionRelative($) {
          return this._moveCursor($.params[0] || 1, 0), !0;
        }
        linePosAbsolute($) {
          return this._setCursor(this._activeBuffer.x, ($.params[0] || 1) - 1), !0;
        }
        vPositionRelative($) {
          return this._moveCursor(0, $.params[0] || 1), !0;
        }
        hVPosition($) {
          return this.cursorPosition($), !0;
        }
        tabClear($) {
          const I = $.params[0];
          return I === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : I === 3 && (this._activeBuffer.tabs = {}), !0;
        }
        cursorForwardTab($) {
          if (this._activeBuffer.x >= this._bufferService.cols) return !0;
          let I = $.params[0] || 1;
          for (; I--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
          return !0;
        }
        cursorBackwardTab($) {
          if (this._activeBuffer.x >= this._bufferService.cols) return !0;
          let I = $.params[0] || 1;
          for (; I--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
          return !0;
        }
        selectProtected($) {
          const I = $.params[0];
          return I === 1 && (this._curAttrData.bg |= 536870912), I !== 2 && I !== 0 || (this._curAttrData.bg &= -536870913), !0;
        }
        _eraseInBufferLine($, I, O, P = !1, q = !1) {
          const Q = this._activeBuffer.lines.get(this._activeBuffer.ybase + $);
          Q.replaceCells(I, O, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), q), P && (Q.isWrapped = !1);
        }
        _resetBufferLine($, I = !1) {
          const O = this._activeBuffer.lines.get(this._activeBuffer.ybase + $);
          O && (O.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), I), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + $), O.isWrapped = !1);
        }
        eraseInDisplay($, I = !1) {
          let O;
          switch (this._restrictCursor(this._bufferService.cols), $.params[0]) {
            case 0:
              for (O = this._activeBuffer.y, this._dirtyRowTracker.markDirty(O), this._eraseInBufferLine(O++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, I); O < this._bufferService.rows; O++) this._resetBufferLine(O, I);
              this._dirtyRowTracker.markDirty(O);
              break;
            case 1:
              for (O = this._activeBuffer.y, this._dirtyRowTracker.markDirty(O), this._eraseInBufferLine(O, 0, this._activeBuffer.x + 1, !0, I), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(O + 1).isWrapped = !1); O--; ) this._resetBufferLine(O, I);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 2:
              for (O = this._bufferService.rows, this._dirtyRowTracker.markDirty(O - 1); O--; ) this._resetBufferLine(O, I);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 3:
              const P = this._activeBuffer.lines.length - this._bufferService.rows;
              P > 0 && (this._activeBuffer.lines.trimStart(P), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - P, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - P, 0), this._onScroll.fire(0));
          }
          return !0;
        }
        eraseInLine($, I = !1) {
          switch (this._restrictCursor(this._bufferService.cols), $.params[0]) {
            case 0:
              this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, I);
              break;
            case 1:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, I);
              break;
            case 2:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, I);
          }
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
        }
        insertLines($) {
          this._restrictCursor();
          let I = $.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const O = this._activeBuffer.ybase + this._activeBuffer.y, P = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, q = this._bufferService.rows - 1 + this._activeBuffer.ybase - P + 1;
          for (; I--; ) this._activeBuffer.lines.splice(q - 1, 1), this._activeBuffer.lines.splice(O, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
        }
        deleteLines($) {
          this._restrictCursor();
          let I = $.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const O = this._activeBuffer.ybase + this._activeBuffer.y;
          let P;
          for (P = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, P = this._bufferService.rows - 1 + this._activeBuffer.ybase - P; I--; ) this._activeBuffer.lines.splice(O, 1), this._activeBuffer.lines.splice(P, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
        }
        insertChars($) {
          this._restrictCursor();
          const I = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return I && (I.insertCells(this._activeBuffer.x, $.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
        }
        deleteChars($) {
          this._restrictCursor();
          const I = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return I && (I.deleteCells(this._activeBuffer.x, $.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
        }
        scrollUp($) {
          let I = $.params[0] || 1;
          for (; I--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        scrollDown($) {
          let I = $.params[0] || 1;
          for (; I--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(d.DEFAULT_ATTR_DATA));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        scrollLeft($) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const I = $.params[0] || 1;
          for (let O = this._activeBuffer.scrollTop; O <= this._activeBuffer.scrollBottom; ++O) {
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + O);
            P.deleteCells(0, I, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), P.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        scrollRight($) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const I = $.params[0] || 1;
          for (let O = this._activeBuffer.scrollTop; O <= this._activeBuffer.scrollBottom; ++O) {
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + O);
            P.insertCells(0, I, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), P.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        insertColumns($) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const I = $.params[0] || 1;
          for (let O = this._activeBuffer.scrollTop; O <= this._activeBuffer.scrollBottom; ++O) {
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + O);
            P.insertCells(this._activeBuffer.x, I, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), P.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        deleteColumns($) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
          const I = $.params[0] || 1;
          for (let O = this._activeBuffer.scrollTop; O <= this._activeBuffer.scrollBottom; ++O) {
            const P = this._activeBuffer.lines.get(this._activeBuffer.ybase + O);
            P.deleteCells(this._activeBuffer.x, I, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), P.isWrapped = !1;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
        }
        eraseChars($) {
          this._restrictCursor();
          const I = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return I && (I.replaceCells(this._activeBuffer.x, this._activeBuffer.x + ($.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
        }
        repeatPrecedingCharacter($) {
          if (!this._parser.precedingCodepoint) return !0;
          const I = $.params[0] || 1, O = new Uint32Array(I);
          for (let P = 0; P < I; ++P) O[P] = this._parser.precedingCodepoint;
          return this.print(O, 0, O.length), !0;
        }
        sendDeviceAttributesPrimary($) {
          return $.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(h.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(h.C0.ESC + "[?6c")), !0;
        }
        sendDeviceAttributesSecondary($) {
          return $.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(h.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(h.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent($.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(h.C0.ESC + "[>83;40003;0c")), !0;
        }
        _is($) {
          return (this._optionsService.rawOptions.termName + "").indexOf($) === 0;
        }
        setMode($) {
          for (let I = 0; I < $.length; I++) switch ($.params[I]) {
            case 4:
              this._coreService.modes.insertMode = !0;
              break;
            case 20:
              this._optionsService.options.convertEol = !0;
          }
          return !0;
        }
        setModePrivate($) {
          for (let I = 0; I < $.length; I++) switch ($.params[I]) {
            case 1:
              this._coreService.decPrivateModes.applicationCursorKeys = !0;
              break;
            case 2:
              this._charsetService.setgCharset(0, f.DEFAULT_CHARSET), this._charsetService.setgCharset(1, f.DEFAULT_CHARSET), this._charsetService.setgCharset(2, f.DEFAULT_CHARSET), this._charsetService.setgCharset(3, f.DEFAULT_CHARSET);
              break;
            case 3:
              this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
              break;
            case 6:
              this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
              break;
            case 7:
              this._coreService.decPrivateModes.wraparound = !0;
              break;
            case 12:
              this._optionsService.options.cursorBlink = !0;
              break;
            case 45:
              this._coreService.decPrivateModes.reverseWraparound = !0;
              break;
            case 66:
              this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
              break;
            case 9:
              this._coreMouseService.activeProtocol = "X10";
              break;
            case 1e3:
              this._coreMouseService.activeProtocol = "VT200";
              break;
            case 1002:
              this._coreMouseService.activeProtocol = "DRAG";
              break;
            case 1003:
              this._coreMouseService.activeProtocol = "ANY";
              break;
            case 1004:
              this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
              break;
            case 1005:
              this._logService.debug("DECSET 1005 not supported (see #2507)");
              break;
            case 1006:
              this._coreMouseService.activeEncoding = "SGR";
              break;
            case 1015:
              this._logService.debug("DECSET 1015 not supported (see #2507)");
              break;
            case 1016:
              this._coreMouseService.activeEncoding = "SGR_PIXELS";
              break;
            case 25:
              this._coreService.isCursorHidden = !1;
              break;
            case 1048:
              this.saveCursor();
              break;
            case 1049:
              this.saveCursor();
            case 47:
            case 1047:
              this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
              break;
            case 2004:
              this._coreService.decPrivateModes.bracketedPasteMode = !0;
          }
          return !0;
        }
        resetMode($) {
          for (let I = 0; I < $.length; I++) switch ($.params[I]) {
            case 4:
              this._coreService.modes.insertMode = !1;
              break;
            case 20:
              this._optionsService.options.convertEol = !1;
          }
          return !0;
        }
        resetModePrivate($) {
          for (let I = 0; I < $.length; I++) switch ($.params[I]) {
            case 1:
              this._coreService.decPrivateModes.applicationCursorKeys = !1;
              break;
            case 3:
              this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
              break;
            case 6:
              this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
              break;
            case 7:
              this._coreService.decPrivateModes.wraparound = !1;
              break;
            case 12:
              this._optionsService.options.cursorBlink = !1;
              break;
            case 45:
              this._coreService.decPrivateModes.reverseWraparound = !1;
              break;
            case 66:
              this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
              break;
            case 9:
            case 1e3:
            case 1002:
            case 1003:
              this._coreMouseService.activeProtocol = "NONE";
              break;
            case 1004:
              this._coreService.decPrivateModes.sendFocus = !1;
              break;
            case 1005:
              this._logService.debug("DECRST 1005 not supported (see #2507)");
              break;
            case 1006:
            case 1016:
              this._coreMouseService.activeEncoding = "DEFAULT";
              break;
            case 1015:
              this._logService.debug("DECRST 1015 not supported (see #2507)");
              break;
            case 25:
              this._coreService.isCursorHidden = !0;
              break;
            case 1048:
              this.restoreCursor();
              break;
            case 1049:
            case 47:
            case 1047:
              this._bufferService.buffers.activateNormalBuffer(), $.params[I] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
              break;
            case 2004:
              this._coreService.decPrivateModes.bracketedPasteMode = !1;
          }
          return !0;
        }
        requestMode($, I) {
          const O = this._coreService.decPrivateModes, { activeProtocol: P, activeEncoding: q } = this._coreMouseService, Q = this._coreService, { buffers: X, cols: G } = this._bufferService, { active: he, alt: A } = X, N = this._optionsService.rawOptions, V = (de) => de ? 1 : 2, W = $.params[0];
          return ie = W, Y = I ? W === 2 ? 4 : W === 4 ? V(Q.modes.insertMode) : W === 12 ? 3 : W === 20 ? V(N.convertEol) : 0 : W === 1 ? V(O.applicationCursorKeys) : W === 3 ? N.windowOptions.setWinLines ? G === 80 ? 2 : G === 132 ? 1 : 0 : 0 : W === 6 ? V(O.origin) : W === 7 ? V(O.wraparound) : W === 8 ? 3 : W === 9 ? V(P === "X10") : W === 12 ? V(N.cursorBlink) : W === 25 ? V(!Q.isCursorHidden) : W === 45 ? V(O.reverseWraparound) : W === 66 ? V(O.applicationKeypad) : W === 67 ? 4 : W === 1e3 ? V(P === "VT200") : W === 1002 ? V(P === "DRAG") : W === 1003 ? V(P === "ANY") : W === 1004 ? V(O.sendFocus) : W === 1005 ? 4 : W === 1006 ? V(q === "SGR") : W === 1015 ? 4 : W === 1016 ? V(q === "SGR_PIXELS") : W === 1048 ? 1 : W === 47 || W === 1047 || W === 1049 ? V(he === A) : W === 2004 ? V(O.bracketedPasteMode) : 0, Q.triggerDataEvent(`${h.C0.ESC}[${I ? "" : "?"}${ie};${Y}$y`), !0;
          var ie, Y;
        }
        _updateAttrColor($, I, O, P, q) {
          return I === 2 ? ($ |= 50331648, $ &= -16777216, $ |= y.AttributeData.fromColorRGB([O, P, q])) : I === 5 && ($ &= -50331904, $ |= 33554432 | 255 & O), $;
        }
        _extractColor($, I, O) {
          const P = [0, 0, -1, 0, 0, 0];
          let q = 0, Q = 0;
          do {
            if (P[Q + q] = $.params[I + Q], $.hasSubParams(I + Q)) {
              const X = $.getSubParams(I + Q);
              let G = 0;
              do
                P[1] === 5 && (q = 1), P[Q + G + 1 + q] = X[G];
              while (++G < X.length && G + Q + 1 + q < P.length);
              break;
            }
            if (P[1] === 5 && Q + q >= 2 || P[1] === 2 && Q + q >= 5) break;
            P[1] && (q = 1);
          } while (++Q + I < $.length && Q + q < P.length);
          for (let X = 2; X < P.length; ++X) P[X] === -1 && (P[X] = 0);
          switch (P[0]) {
            case 38:
              O.fg = this._updateAttrColor(O.fg, P[1], P[3], P[4], P[5]);
              break;
            case 48:
              O.bg = this._updateAttrColor(O.bg, P[1], P[3], P[4], P[5]);
              break;
            case 58:
              O.extended = O.extended.clone(), O.extended.underlineColor = this._updateAttrColor(O.extended.underlineColor, P[1], P[3], P[4], P[5]);
          }
          return Q;
        }
        _processUnderline($, I) {
          I.extended = I.extended.clone(), (!~$ || $ > 5) && ($ = 1), I.extended.underlineStyle = $, I.fg |= 268435456, $ === 0 && (I.fg &= -268435457), I.updateExtended();
        }
        _processSGR0($) {
          $.fg = d.DEFAULT_ATTR_DATA.fg, $.bg = d.DEFAULT_ATTR_DATA.bg, $.extended = $.extended.clone(), $.extended.underlineStyle = 0, $.extended.underlineColor &= -67108864, $.updateExtended();
        }
        charAttributes($) {
          if ($.length === 1 && $.params[0] === 0) return this._processSGR0(this._curAttrData), !0;
          const I = $.length;
          let O;
          const P = this._curAttrData;
          for (let q = 0; q < I; q++) O = $.params[q], O >= 30 && O <= 37 ? (P.fg &= -50331904, P.fg |= 16777216 | O - 30) : O >= 40 && O <= 47 ? (P.bg &= -50331904, P.bg |= 16777216 | O - 40) : O >= 90 && O <= 97 ? (P.fg &= -50331904, P.fg |= 16777224 | O - 90) : O >= 100 && O <= 107 ? (P.bg &= -50331904, P.bg |= 16777224 | O - 100) : O === 0 ? this._processSGR0(P) : O === 1 ? P.fg |= 134217728 : O === 3 ? P.bg |= 67108864 : O === 4 ? (P.fg |= 268435456, this._processUnderline($.hasSubParams(q) ? $.getSubParams(q)[0] : 1, P)) : O === 5 ? P.fg |= 536870912 : O === 7 ? P.fg |= 67108864 : O === 8 ? P.fg |= 1073741824 : O === 9 ? P.fg |= 2147483648 : O === 2 ? P.bg |= 134217728 : O === 21 ? this._processUnderline(2, P) : O === 22 ? (P.fg &= -134217729, P.bg &= -134217729) : O === 23 ? P.bg &= -67108865 : O === 24 ? (P.fg &= -268435457, this._processUnderline(0, P)) : O === 25 ? P.fg &= -536870913 : O === 27 ? P.fg &= -67108865 : O === 28 ? P.fg &= -1073741825 : O === 29 ? P.fg &= 2147483647 : O === 39 ? (P.fg &= -67108864, P.fg |= 16777215 & d.DEFAULT_ATTR_DATA.fg) : O === 49 ? (P.bg &= -67108864, P.bg |= 16777215 & d.DEFAULT_ATTR_DATA.bg) : O === 38 || O === 48 || O === 58 ? q += this._extractColor($, q, P) : O === 53 ? P.bg |= 1073741824 : O === 55 ? P.bg &= -1073741825 : O === 59 ? (P.extended = P.extended.clone(), P.extended.underlineColor = -1, P.updateExtended()) : O === 100 ? (P.fg &= -67108864, P.fg |= 16777215 & d.DEFAULT_ATTR_DATA.fg, P.bg &= -67108864, P.bg |= 16777215 & d.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", O);
          return !0;
        }
        deviceStatus($) {
          switch ($.params[0]) {
            case 5:
              this._coreService.triggerDataEvent(`${h.C0.ESC}[0n`);
              break;
            case 6:
              const I = this._activeBuffer.y + 1, O = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${h.C0.ESC}[${I};${O}R`);
          }
          return !0;
        }
        deviceStatusPrivate($) {
          if ($.params[0] === 6) {
            const I = this._activeBuffer.y + 1, O = this._activeBuffer.x + 1;
            this._coreService.triggerDataEvent(`${h.C0.ESC}[?${I};${O}R`);
          }
          return !0;
        }
        softReset($) {
          return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = d.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
        }
        setCursorStyle($) {
          const I = $.params[0] || 1;
          switch (I) {
            case 1:
            case 2:
              this._optionsService.options.cursorStyle = "block";
              break;
            case 3:
            case 4:
              this._optionsService.options.cursorStyle = "underline";
              break;
            case 5:
            case 6:
              this._optionsService.options.cursorStyle = "bar";
          }
          const O = I % 2 == 1;
          return this._optionsService.options.cursorBlink = O, !0;
        }
        setScrollRegion($) {
          const I = $.params[0] || 1;
          let O;
          return ($.length < 2 || (O = $.params[1]) > this._bufferService.rows || O === 0) && (O = this._bufferService.rows), O > I && (this._activeBuffer.scrollTop = I - 1, this._activeBuffer.scrollBottom = O - 1, this._setCursor(0, 0)), !0;
        }
        windowOptions($) {
          if (!M($.params[0], this._optionsService.rawOptions.windowOptions)) return !0;
          const I = $.length > 1 ? $.params[1] : 0;
          switch ($.params[0]) {
            case 14:
              I !== 2 && this._onRequestWindowsOptionsReport.fire(E.GET_WIN_SIZE_PIXELS);
              break;
            case 16:
              this._onRequestWindowsOptionsReport.fire(E.GET_CELL_SIZE_PIXELS);
              break;
            case 18:
              this._bufferService && this._coreService.triggerDataEvent(`${h.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
              break;
            case 22:
              I !== 0 && I !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), I !== 0 && I !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
              break;
            case 23:
              I !== 0 && I !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), I !== 0 && I !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
          }
          return !0;
        }
        saveCursor($) {
          return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
        }
        restoreCursor($) {
          return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
        }
        setTitle($) {
          return this._windowTitle = $, this._onTitleChange.fire($), !0;
        }
        setIconName($) {
          return this._iconName = $, !0;
        }
        setOrReportIndexedColor($) {
          const I = [], O = $.split(";");
          for (; O.length > 1; ) {
            const P = O.shift(), q = O.shift();
            if (/^\d+$/.exec(P)) {
              const Q = parseInt(P);
              if (j(Q)) if (q === "?") I.push({ type: 0, index: Q });
              else {
                const X = (0, x.parseColor)(q);
                X && I.push({ type: 1, index: Q, color: X });
              }
            }
          }
          return I.length && this._onColor.fire(I), !0;
        }
        setHyperlink($) {
          const I = $.split(";");
          return !(I.length < 2) && (I[1] ? this._createHyperlink(I[0], I[1]) : !I[0] && this._finishHyperlink());
        }
        _createHyperlink($, I) {
          this._getCurrentLinkId() && this._finishHyperlink();
          const O = $.split(":");
          let P;
          const q = O.findIndex((Q) => Q.startsWith("id="));
          return q !== -1 && (P = O[q].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: P, uri: I }), this._curAttrData.updateExtended(), !0;
        }
        _finishHyperlink() {
          return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
        }
        _setOrReportSpecialColor($, I) {
          const O = $.split(";");
          for (let P = 0; P < O.length && !(I >= this._specialColors.length); ++P, ++I) if (O[P] === "?") this._onColor.fire([{ type: 0, index: this._specialColors[I] }]);
          else {
            const q = (0, x.parseColor)(O[P]);
            q && this._onColor.fire([{ type: 1, index: this._specialColors[I], color: q }]);
          }
          return !0;
        }
        setOrReportFgColor($) {
          return this._setOrReportSpecialColor($, 0);
        }
        setOrReportBgColor($) {
          return this._setOrReportSpecialColor($, 1);
        }
        setOrReportCursorColor($) {
          return this._setOrReportSpecialColor($, 2);
        }
        restoreIndexedColor($) {
          if (!$) return this._onColor.fire([{ type: 2 }]), !0;
          const I = [], O = $.split(";");
          for (let P = 0; P < O.length; ++P) if (/^\d+$/.exec(O[P])) {
            const q = parseInt(O[P]);
            j(q) && I.push({ type: 2, index: q });
          }
          return I.length && this._onColor.fire(I), !0;
        }
        restoreFgColor($) {
          return this._onColor.fire([{ type: 2, index: 256 }]), !0;
        }
        restoreBgColor($) {
          return this._onColor.fire([{ type: 2, index: 257 }]), !0;
        }
        restoreCursorColor($) {
          return this._onColor.fire([{ type: 2, index: 258 }]), !0;
        }
        nextLine() {
          return this._activeBuffer.x = 0, this.index(), !0;
        }
        keypadApplicationMode() {
          return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
        }
        keypadNumericMode() {
          return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
        }
        selectDefaultCharset() {
          return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, f.DEFAULT_CHARSET), !0;
        }
        selectCharset($) {
          return $.length !== 2 ? (this.selectDefaultCharset(), !0) : ($[0] === "/" || this._charsetService.setgCharset(S[$[0]], f.CHARSETS[$[1]] || f.DEFAULT_CHARSET), !0);
        }
        index() {
          return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
        }
        tabSet() {
          return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
        }
        reverseIndex() {
          if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
            const $ = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, $, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
          } else this._activeBuffer.y--, this._restrictCursor();
          return !0;
        }
        fullReset() {
          return this._parser.reset(), this._onRequestReset.fire(), !0;
        }
        reset() {
          this._curAttrData = d.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = d.DEFAULT_ATTR_DATA.clone();
        }
        _eraseAttrData() {
          return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
        }
        setgLevel($) {
          return this._charsetService.setgLevel($), !0;
        }
        screenAlignmentPattern() {
          const $ = new b.CellData();
          $.content = 4194373, $.fg = this._curAttrData.fg, $.bg = this._curAttrData.bg, this._setCursor(0, 0);
          for (let I = 0; I < this._bufferService.rows; ++I) {
            const O = this._activeBuffer.ybase + this._activeBuffer.y + I, P = this._activeBuffer.lines.get(O);
            P && (P.fill($), P.isWrapped = !1);
          }
          return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
        }
        requestStatusString($, I) {
          const O = this._bufferService.buffer, P = this._optionsService.rawOptions;
          return ((q) => (this._coreService.triggerDataEvent(`${h.C0.ESC}${q}${h.C0.ESC}\\`), !0))($ === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : $ === '"p' ? 'P1$r61;1"p' : $ === "r" ? `P1$r${O.scrollTop + 1};${O.scrollBottom + 1}r` : $ === "m" ? "P1$r0m" : $ === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[P.cursorStyle] - (P.cursorBlink ? 1 : 0)} q` : "P0$r");
        }
        markRangeDirty($, I) {
          this._dirtyRowTracker.markRangeDirty($, I);
        }
      }
      a.InputHandler = z;
      let F = class {
        constructor(U) {
          this._bufferService = U, this.clearRange();
        }
        clearRange() {
          this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
        }
        markDirty(U) {
          U < this.start ? this.start = U : U > this.end && (this.end = U);
        }
        markRangeDirty(U, $) {
          U > $ && (R = U, U = $, $ = R), U < this.start && (this.start = U), $ > this.end && (this.end = $);
        }
        markAllDirty() {
          this.markRangeDirty(0, this._bufferService.rows - 1);
        }
      };
      function j(U) {
        return 0 <= U && U < 256;
      }
      F = c([u(0, w.IBufferService)], F);
    }, 844: (o, a) => {
      function l(c) {
        for (const u of c) u.dispose();
        c.length = 0;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getDisposeArrayDisposable = a.disposeArray = a.toDisposable = a.MutableDisposable = a.Disposable = void 0, a.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = !1;
        }
        dispose() {
          this._isDisposed = !0;
          for (const c of this._disposables) c.dispose();
          this._disposables.length = 0;
        }
        register(c) {
          return this._disposables.push(c), c;
        }
        unregister(c) {
          const u = this._disposables.indexOf(c);
          u !== -1 && this._disposables.splice(u, 1);
        }
      }, a.MutableDisposable = class {
        constructor() {
          this._isDisposed = !1;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(c) {
          var u;
          this._isDisposed || c === this._value || ((u = this._value) === null || u === void 0 || u.dispose(), this._value = c);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          var c;
          this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0;
        }
      }, a.toDisposable = function(c) {
        return { dispose: c };
      }, a.disposeArray = l, a.getDisposeArrayDisposable = function(c) {
        return { dispose: () => l(c) };
      };
    }, 1505: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.FourKeyMap = a.TwoKeyMap = void 0;
      class l {
        constructor() {
          this._data = {};
        }
        set(u, h, f) {
          this._data[u] || (this._data[u] = {}), this._data[u][h] = f;
        }
        get(u, h) {
          return this._data[u] ? this._data[u][h] : void 0;
        }
        clear() {
          this._data = {};
        }
      }
      a.TwoKeyMap = l, a.FourKeyMap = class {
        constructor() {
          this._data = new l();
        }
        set(c, u, h, f, m) {
          this._data.get(c, u) || this._data.set(c, u, new l()), this._data.get(c, u).set(h, f, m);
        }
        get(c, u, h, f) {
          var m;
          return (m = this._data.get(c, u)) === null || m === void 0 ? void 0 : m.get(h, f);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 6114: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.isChromeOS = a.isLinux = a.isWindows = a.isIphone = a.isIpad = a.isMac = a.getSafariVersion = a.isSafari = a.isLegacyEdge = a.isFirefox = a.isNode = void 0, a.isNode = typeof navigator > "u";
      const l = a.isNode ? "node" : navigator.userAgent, c = a.isNode ? "node" : navigator.platform;
      a.isFirefox = l.includes("Firefox"), a.isLegacyEdge = l.includes("Edge"), a.isSafari = /^((?!chrome|android).)*safari/i.test(l), a.getSafariVersion = function() {
        if (!a.isSafari) return 0;
        const u = l.match(/Version\/(\d+)/);
        return u === null || u.length < 2 ? 0 : parseInt(u[1]);
      }, a.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c), a.isIpad = c === "iPad", a.isIphone = c === "iPhone", a.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c), a.isLinux = c.indexOf("Linux") >= 0, a.isChromeOS = /\bCrOS\b/.test(l);
    }, 6106: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.SortedList = void 0;
      let l = 0;
      a.SortedList = class {
        constructor(c) {
          this._getKey = c, this._array = [];
        }
        clear() {
          this._array.length = 0;
        }
        insert(c) {
          this._array.length !== 0 ? (l = this._search(this._getKey(c)), this._array.splice(l, 0, c)) : this._array.push(c);
        }
        delete(c) {
          if (this._array.length === 0) return !1;
          const u = this._getKey(c);
          if (u === void 0 || (l = this._search(u), l === -1) || this._getKey(this._array[l]) !== u) return !1;
          do
            if (this._array[l] === c) return this._array.splice(l, 1), !0;
          while (++l < this._array.length && this._getKey(this._array[l]) === u);
          return !1;
        }
        *getKeyIterator(c) {
          if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
            yield this._array[l];
          while (++l < this._array.length && this._getKey(this._array[l]) === c);
        }
        forEachByKey(c, u) {
          if (this._array.length !== 0 && (l = this._search(c), !(l < 0 || l >= this._array.length) && this._getKey(this._array[l]) === c)) do
            u(this._array[l]);
          while (++l < this._array.length && this._getKey(this._array[l]) === c);
        }
        values() {
          return [...this._array].values();
        }
        _search(c) {
          let u = 0, h = this._array.length - 1;
          for (; h >= u; ) {
            let f = u + h >> 1;
            const m = this._getKey(this._array[f]);
            if (m > c) h = f - 1;
            else {
              if (!(m < c)) {
                for (; f > 0 && this._getKey(this._array[f - 1]) === c; ) f--;
                return f;
              }
              u = f + 1;
            }
          }
          return u;
        }
      };
    }, 7226: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DebouncedIdleTask = a.IdleTaskQueue = a.PriorityTaskQueue = void 0;
      const c = l(6114);
      class u {
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(m) {
          this._tasks.push(m), this._start();
        }
        flush() {
          for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(m) {
          this._idleCallback = void 0;
          let _ = 0, v = 0, d = m.timeRemaining(), p = 0;
          for (; this._i < this._tasks.length; ) {
            if (_ = Date.now(), this._tasks[this._i]() || this._i++, _ = Math.max(1, Date.now() - _), v = Math.max(_, v), p = m.timeRemaining(), 1.5 * v > p) return d - _ < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(d - _))}ms`), void this._start();
            d = p;
          }
          this.clear();
        }
      }
      class h extends u {
        _requestCallback(m) {
          return setTimeout(() => m(this._createDeadline(16)));
        }
        _cancelCallback(m) {
          clearTimeout(m);
        }
        _createDeadline(m) {
          const _ = Date.now() + m;
          return { timeRemaining: () => Math.max(0, _ - Date.now()) };
        }
      }
      a.PriorityTaskQueue = h, a.IdleTaskQueue = !c.isNode && "requestIdleCallback" in window ? class extends u {
        _requestCallback(f) {
          return requestIdleCallback(f);
        }
        _cancelCallback(f) {
          cancelIdleCallback(f);
        }
      } : h, a.DebouncedIdleTask = class {
        constructor() {
          this._queue = new a.IdleTaskQueue();
        }
        set(f) {
          this._queue.clear(), this._queue.enqueue(f);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 9282: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.updateWindowsModeWrappedState = void 0;
      const c = l(643);
      a.updateWindowsModeWrappedState = function(u) {
        const h = u.buffer.lines.get(u.buffer.ybase + u.buffer.y - 1), f = h == null ? void 0 : h.get(u.cols - 1), m = u.buffer.lines.get(u.buffer.ybase + u.buffer.y);
        m && f && (m.isWrapped = f[c.CHAR_DATA_CODE_INDEX] !== c.NULL_CELL_CODE && f[c.CHAR_DATA_CODE_INDEX] !== c.WHITESPACE_CELL_CODE);
      };
    }, 3734: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ExtendedAttrs = a.AttributeData = void 0;
      class l {
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new c();
        }
        static toColorRGB(h) {
          return [h >>> 16 & 255, h >>> 8 & 255, 255 & h];
        }
        static fromColorRGB(h) {
          return (255 & h[0]) << 16 | (255 & h[1]) << 8 | 255 & h[2];
        }
        clone() {
          const h = new l();
          return h.fg = this.fg, h.bg = this.bg, h.extended = this.extended.clone(), h;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return (50331648 & this.fg) == 50331648;
        }
        isBgRGB() {
          return (50331648 & this.bg) == 50331648;
        }
        isFgPalette() {
          return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
        }
        isBgPalette() {
          return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
        }
        isFgDefault() {
          return (50331648 & this.fg) == 0;
        }
        isBgDefault() {
          return (50331648 & this.bg) == 0;
        }
        isAttributeDefault() {
          return this.fg === 0 && this.bg === 0;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
            case 16777216:
            case 33554432:
              return 255 & this.extended.underlineColor;
            case 50331648:
              return 16777215 & this.extended.underlineColor;
            default:
              return this.getFgColor();
          }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
      }
      a.AttributeData = l;
      class c {
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(h) {
          this._ext = h;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(h) {
          this._ext &= -469762049, this._ext |= h << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(h) {
          this._ext &= -67108864, this._ext |= 67108863 & h;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(h) {
          this._urlId = h;
        }
        constructor(h = 0, f = 0) {
          this._ext = 0, this._urlId = 0, this._ext = h, this._urlId = f;
        }
        clone() {
          return new c(this._ext, this._urlId);
        }
        isEmpty() {
          return this.underlineStyle === 0 && this._urlId === 0;
        }
      }
      a.ExtendedAttrs = c;
    }, 9092: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Buffer = a.MAX_BUFFER_SIZE = void 0;
      const c = l(6349), u = l(7226), h = l(3734), f = l(8437), m = l(4634), _ = l(511), v = l(643), d = l(4863), p = l(7116);
      a.MAX_BUFFER_SIZE = 4294967295, a.Buffer = class {
        constructor(g, b, y) {
          this._hasScrollback = g, this._optionsService = b, this._bufferService = y, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = f.DEFAULT_ATTR_DATA.clone(), this.savedCharset = p.DEFAULT_CHARSET, this.markers = [], this._nullCell = _.CellData.fromCharData([0, v.NULL_CELL_CHAR, v.NULL_CELL_WIDTH, v.NULL_CELL_CODE]), this._whitespaceCell = _.CellData.fromCharData([0, v.WHITESPACE_CELL_CHAR, v.WHITESPACE_CELL_WIDTH, v.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new u.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        getNullCell(g) {
          return g ? (this._nullCell.fg = g.fg, this._nullCell.bg = g.bg, this._nullCell.extended = g.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new h.ExtendedAttrs()), this._nullCell;
        }
        getWhitespaceCell(g) {
          return g ? (this._whitespaceCell.fg = g.fg, this._whitespaceCell.bg = g.bg, this._whitespaceCell.extended = g.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new h.ExtendedAttrs()), this._whitespaceCell;
        }
        getBlankLine(g, b) {
          return new f.BufferLine(this._bufferService.cols, this.getNullCell(g), b);
        }
        get hasScrollback() {
          return this._hasScrollback && this.lines.maxLength > this._rows;
        }
        get isCursorInViewport() {
          const g = this.ybase + this.y - this.ydisp;
          return g >= 0 && g < this._rows;
        }
        _getCorrectBufferLength(g) {
          if (!this._hasScrollback) return g;
          const b = g + this._optionsService.rawOptions.scrollback;
          return b > a.MAX_BUFFER_SIZE ? a.MAX_BUFFER_SIZE : b;
        }
        fillViewportRows(g) {
          if (this.lines.length === 0) {
            g === void 0 && (g = f.DEFAULT_ATTR_DATA);
            let b = this._rows;
            for (; b--; ) this.lines.push(this.getBlankLine(g));
          }
        }
        clear() {
          this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        resize(g, b) {
          const y = this.getNullCell(f.DEFAULT_ATTR_DATA);
          let w = 0;
          const k = this._getCorrectBufferLength(b);
          if (k > this.lines.maxLength && (this.lines.maxLength = k), this.lines.length > 0) {
            if (this._cols < g) for (let x = 0; x < this.lines.length; x++) w += +this.lines.get(x).resize(g, y);
            let C = 0;
            if (this._rows < b) for (let x = this._rows; x < b; x++) this.lines.length < b + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new f.BufferLine(g, y)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + C + 1 ? (this.ybase--, C++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new f.BufferLine(g, y)));
            else for (let x = this._rows; x > b; x--) this.lines.length > b + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
            if (k < this.lines.maxLength) {
              const x = this.lines.length - k;
              x > 0 && (this.lines.trimStart(x), this.ybase = Math.max(this.ybase - x, 0), this.ydisp = Math.max(this.ydisp - x, 0), this.savedY = Math.max(this.savedY - x, 0)), this.lines.maxLength = k;
            }
            this.x = Math.min(this.x, g - 1), this.y = Math.min(this.y, b - 1), C && (this.y += C), this.savedX = Math.min(this.savedX, g - 1), this.scrollTop = 0;
          }
          if (this.scrollBottom = b - 1, this._isReflowEnabled && (this._reflow(g, b), this._cols > g)) for (let C = 0; C < this.lines.length; C++) w += +this.lines.get(C).resize(g, y);
          this._cols = g, this._rows = b, this._memoryCleanupQueue.clear(), w > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
        }
        _batchedMemoryCleanup() {
          let g = !0;
          this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, g = !1);
          let b = 0;
          for (; this._memoryCleanupPosition < this.lines.length; ) if (b += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), b > 100) return !0;
          return g;
        }
        get _isReflowEnabled() {
          const g = this._optionsService.rawOptions.windowsPty;
          return g && g.buildNumber ? this._hasScrollback && g.backend === "conpty" && g.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
        }
        _reflow(g, b) {
          this._cols !== g && (g > this._cols ? this._reflowLarger(g, b) : this._reflowSmaller(g, b));
        }
        _reflowLarger(g, b) {
          const y = (0, m.reflowLargerGetLinesToRemove)(this.lines, this._cols, g, this.ybase + this.y, this.getNullCell(f.DEFAULT_ATTR_DATA));
          if (y.length > 0) {
            const w = (0, m.reflowLargerCreateNewLayout)(this.lines, y);
            (0, m.reflowLargerApplyNewLayout)(this.lines, w.layout), this._reflowLargerAdjustViewport(g, b, w.countRemoved);
          }
        }
        _reflowLargerAdjustViewport(g, b, y) {
          const w = this.getNullCell(f.DEFAULT_ATTR_DATA);
          let k = y;
          for (; k-- > 0; ) this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < b && this.lines.push(new f.BufferLine(g, w))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
          this.savedY = Math.max(this.savedY - y, 0);
        }
        _reflowSmaller(g, b) {
          const y = this.getNullCell(f.DEFAULT_ATTR_DATA), w = [];
          let k = 0;
          for (let C = this.lines.length - 1; C >= 0; C--) {
            let x = this.lines.get(C);
            if (!x || !x.isWrapped && x.getTrimmedLength() <= g) continue;
            const S = [x];
            for (; x.isWrapped && C > 0; ) x = this.lines.get(--C), S.unshift(x);
            const T = this.ybase + this.y;
            if (T >= C && T < C + S.length) continue;
            const M = S[S.length - 1].getTrimmedLength(), E = (0, m.reflowSmallerGetNewLineLengths)(S, this._cols, g), R = E.length - S.length;
            let z;
            z = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + R) : Math.max(0, this.lines.length - this.lines.maxLength + R);
            const F = [];
            for (let P = 0; P < R; P++) {
              const q = this.getBlankLine(f.DEFAULT_ATTR_DATA, !0);
              F.push(q);
            }
            F.length > 0 && (w.push({ start: C + S.length + k, newLines: F }), k += F.length), S.push(...F);
            let j = E.length - 1, U = E[j];
            U === 0 && (j--, U = E[j]);
            let $ = S.length - R - 1, I = M;
            for (; $ >= 0; ) {
              const P = Math.min(I, U);
              if (S[j] === void 0) break;
              if (S[j].copyCellsFrom(S[$], I - P, U - P, P, !0), U -= P, U === 0 && (j--, U = E[j]), I -= P, I === 0) {
                $--;
                const q = Math.max($, 0);
                I = (0, m.getWrappedLineTrimmedLength)(S, q, this._cols);
              }
            }
            for (let P = 0; P < S.length; P++) E[P] < g && S[P].setCell(E[P], y);
            let O = R - z;
            for (; O-- > 0; ) this.ybase === 0 ? this.y < b - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + k) - b && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
            this.savedY = Math.min(this.savedY + R, this.ybase + b - 1);
          }
          if (w.length > 0) {
            const C = [], x = [];
            for (let j = 0; j < this.lines.length; j++) x.push(this.lines.get(j));
            const S = this.lines.length;
            let T = S - 1, M = 0, E = w[M];
            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + k);
            let R = 0;
            for (let j = Math.min(this.lines.maxLength - 1, S + k - 1); j >= 0; j--) if (E && E.start > T + R) {
              for (let U = E.newLines.length - 1; U >= 0; U--) this.lines.set(j--, E.newLines[U]);
              j++, C.push({ index: T + 1, amount: E.newLines.length }), R += E.newLines.length, E = w[++M];
            } else this.lines.set(j, x[T--]);
            let z = 0;
            for (let j = C.length - 1; j >= 0; j--) C[j].index += z, this.lines.onInsertEmitter.fire(C[j]), z += C[j].amount;
            const F = Math.max(0, S + k - this.lines.maxLength);
            F > 0 && this.lines.onTrimEmitter.fire(F);
          }
        }
        translateBufferLineToString(g, b, y = 0, w) {
          const k = this.lines.get(g);
          return k ? k.translateToString(b, y, w) : "";
        }
        getWrappedRangeForLine(g) {
          let b = g, y = g;
          for (; b > 0 && this.lines.get(b).isWrapped; ) b--;
          for (; y + 1 < this.lines.length && this.lines.get(y + 1).isWrapped; ) y++;
          return { first: b, last: y };
        }
        setupTabStops(g) {
          for (g != null ? this.tabs[g] || (g = this.prevStop(g)) : (this.tabs = {}, g = 0); g < this._cols; g += this._optionsService.rawOptions.tabStopWidth) this.tabs[g] = !0;
        }
        prevStop(g) {
          for (g == null && (g = this.x); !this.tabs[--g] && g > 0; ) ;
          return g >= this._cols ? this._cols - 1 : g < 0 ? 0 : g;
        }
        nextStop(g) {
          for (g == null && (g = this.x); !this.tabs[++g] && g < this._cols; ) ;
          return g >= this._cols ? this._cols - 1 : g < 0 ? 0 : g;
        }
        clearMarkers(g) {
          this._isClearing = !0;
          for (let b = 0; b < this.markers.length; b++) this.markers[b].line === g && (this.markers[b].dispose(), this.markers.splice(b--, 1));
          this._isClearing = !1;
        }
        clearAllMarkers() {
          this._isClearing = !0;
          for (let g = 0; g < this.markers.length; g++) this.markers[g].dispose(), this.markers.splice(g--, 1);
          this._isClearing = !1;
        }
        addMarker(g) {
          const b = new d.Marker(g);
          return this.markers.push(b), b.register(this.lines.onTrim((y) => {
            b.line -= y, b.line < 0 && b.dispose();
          })), b.register(this.lines.onInsert((y) => {
            b.line >= y.index && (b.line += y.amount);
          })), b.register(this.lines.onDelete((y) => {
            b.line >= y.index && b.line < y.index + y.amount && b.dispose(), b.line > y.index && (b.line -= y.amount);
          })), b.register(b.onDispose(() => this._removeMarker(b))), b;
        }
        _removeMarker(g) {
          this._isClearing || this.markers.splice(this.markers.indexOf(g), 1);
        }
      };
    }, 8437: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLine = a.DEFAULT_ATTR_DATA = void 0;
      const c = l(3734), u = l(511), h = l(643), f = l(482);
      a.DEFAULT_ATTR_DATA = Object.freeze(new c.AttributeData());
      let m = 0;
      class _ {
        constructor(d, p, g = !1) {
          this.isWrapped = g, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * d);
          const b = p || u.CellData.fromCharData([0, h.NULL_CELL_CHAR, h.NULL_CELL_WIDTH, h.NULL_CELL_CODE]);
          for (let y = 0; y < d; ++y) this.setCell(y, b);
          this.length = d;
        }
        get(d) {
          const p = this._data[3 * d + 0], g = 2097151 & p;
          return [this._data[3 * d + 1], 2097152 & p ? this._combined[d] : g ? (0, f.stringFromCodePoint)(g) : "", p >> 22, 2097152 & p ? this._combined[d].charCodeAt(this._combined[d].length - 1) : g];
        }
        set(d, p) {
          this._data[3 * d + 1] = p[h.CHAR_DATA_ATTR_INDEX], p[h.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[d] = p[1], this._data[3 * d + 0] = 2097152 | d | p[h.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * d + 0] = p[h.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | p[h.CHAR_DATA_WIDTH_INDEX] << 22;
        }
        getWidth(d) {
          return this._data[3 * d + 0] >> 22;
        }
        hasWidth(d) {
          return 12582912 & this._data[3 * d + 0];
        }
        getFg(d) {
          return this._data[3 * d + 1];
        }
        getBg(d) {
          return this._data[3 * d + 2];
        }
        hasContent(d) {
          return 4194303 & this._data[3 * d + 0];
        }
        getCodePoint(d) {
          const p = this._data[3 * d + 0];
          return 2097152 & p ? this._combined[d].charCodeAt(this._combined[d].length - 1) : 2097151 & p;
        }
        isCombined(d) {
          return 2097152 & this._data[3 * d + 0];
        }
        getString(d) {
          const p = this._data[3 * d + 0];
          return 2097152 & p ? this._combined[d] : 2097151 & p ? (0, f.stringFromCodePoint)(2097151 & p) : "";
        }
        isProtected(d) {
          return 536870912 & this._data[3 * d + 2];
        }
        loadCell(d, p) {
          return m = 3 * d, p.content = this._data[m + 0], p.fg = this._data[m + 1], p.bg = this._data[m + 2], 2097152 & p.content && (p.combinedData = this._combined[d]), 268435456 & p.bg && (p.extended = this._extendedAttrs[d]), p;
        }
        setCell(d, p) {
          2097152 & p.content && (this._combined[d] = p.combinedData), 268435456 & p.bg && (this._extendedAttrs[d] = p.extended), this._data[3 * d + 0] = p.content, this._data[3 * d + 1] = p.fg, this._data[3 * d + 2] = p.bg;
        }
        setCellFromCodePoint(d, p, g, b, y, w) {
          268435456 & y && (this._extendedAttrs[d] = w), this._data[3 * d + 0] = p | g << 22, this._data[3 * d + 1] = b, this._data[3 * d + 2] = y;
        }
        addCodepointToCell(d, p) {
          let g = this._data[3 * d + 0];
          2097152 & g ? this._combined[d] += (0, f.stringFromCodePoint)(p) : (2097151 & g ? (this._combined[d] = (0, f.stringFromCodePoint)(2097151 & g) + (0, f.stringFromCodePoint)(p), g &= -2097152, g |= 2097152) : g = p | 4194304, this._data[3 * d + 0] = g);
        }
        insertCells(d, p, g, b) {
          if ((d %= this.length) && this.getWidth(d - 1) === 2 && this.setCellFromCodePoint(d - 1, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs()), p < this.length - d) {
            const y = new u.CellData();
            for (let w = this.length - d - p - 1; w >= 0; --w) this.setCell(d + p + w, this.loadCell(d + w, y));
            for (let w = 0; w < p; ++w) this.setCell(d + w, g);
          } else for (let y = d; y < this.length; ++y) this.setCell(y, g);
          this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs());
        }
        deleteCells(d, p, g, b) {
          if (d %= this.length, p < this.length - d) {
            const y = new u.CellData();
            for (let w = 0; w < this.length - d - p; ++w) this.setCell(d + w, this.loadCell(d + p + w, y));
            for (let w = this.length - p; w < this.length; ++w) this.setCell(w, g);
          } else for (let y = d; y < this.length; ++y) this.setCell(y, g);
          d && this.getWidth(d - 1) === 2 && this.setCellFromCodePoint(d - 1, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs()), this.getWidth(d) !== 0 || this.hasContent(d) || this.setCellFromCodePoint(d, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs());
        }
        replaceCells(d, p, g, b, y = !1) {
          if (y) for (d && this.getWidth(d - 1) === 2 && !this.isProtected(d - 1) && this.setCellFromCodePoint(d - 1, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs()), p < this.length && this.getWidth(p - 1) === 2 && !this.isProtected(p) && this.setCellFromCodePoint(p, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs()); d < p && d < this.length; ) this.isProtected(d) || this.setCell(d, g), d++;
          else for (d && this.getWidth(d - 1) === 2 && this.setCellFromCodePoint(d - 1, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs()), p < this.length && this.getWidth(p - 1) === 2 && this.setCellFromCodePoint(p, 0, 1, (b == null ? void 0 : b.fg) || 0, (b == null ? void 0 : b.bg) || 0, (b == null ? void 0 : b.extended) || new c.ExtendedAttrs()); d < p && d < this.length; ) this.setCell(d++, g);
        }
        resize(d, p) {
          if (d === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
          const g = 3 * d;
          if (d > this.length) {
            if (this._data.buffer.byteLength >= 4 * g) this._data = new Uint32Array(this._data.buffer, 0, g);
            else {
              const b = new Uint32Array(g);
              b.set(this._data), this._data = b;
            }
            for (let b = this.length; b < d; ++b) this.setCell(b, p);
          } else {
            this._data = this._data.subarray(0, g);
            const b = Object.keys(this._combined);
            for (let w = 0; w < b.length; w++) {
              const k = parseInt(b[w], 10);
              k >= d && delete this._combined[k];
            }
            const y = Object.keys(this._extendedAttrs);
            for (let w = 0; w < y.length; w++) {
              const k = parseInt(y[w], 10);
              k >= d && delete this._extendedAttrs[k];
            }
          }
          return this.length = d, 4 * g * 2 < this._data.buffer.byteLength;
        }
        cleanupMemory() {
          if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
            const d = new Uint32Array(this._data.length);
            return d.set(this._data), this._data = d, 1;
          }
          return 0;
        }
        fill(d, p = !1) {
          if (p) for (let g = 0; g < this.length; ++g) this.isProtected(g) || this.setCell(g, d);
          else {
            this._combined = {}, this._extendedAttrs = {};
            for (let g = 0; g < this.length; ++g) this.setCell(g, d);
          }
        }
        copyFrom(d) {
          this.length !== d.length ? this._data = new Uint32Array(d._data) : this._data.set(d._data), this.length = d.length, this._combined = {};
          for (const p in d._combined) this._combined[p] = d._combined[p];
          this._extendedAttrs = {};
          for (const p in d._extendedAttrs) this._extendedAttrs[p] = d._extendedAttrs[p];
          this.isWrapped = d.isWrapped;
        }
        clone() {
          const d = new _(0);
          d._data = new Uint32Array(this._data), d.length = this.length;
          for (const p in this._combined) d._combined[p] = this._combined[p];
          for (const p in this._extendedAttrs) d._extendedAttrs[p] = this._extendedAttrs[p];
          return d.isWrapped = this.isWrapped, d;
        }
        getTrimmedLength() {
          for (let d = this.length - 1; d >= 0; --d) if (4194303 & this._data[3 * d + 0]) return d + (this._data[3 * d + 0] >> 22);
          return 0;
        }
        getNoBgTrimmedLength() {
          for (let d = this.length - 1; d >= 0; --d) if (4194303 & this._data[3 * d + 0] || 50331648 & this._data[3 * d + 2]) return d + (this._data[3 * d + 0] >> 22);
          return 0;
        }
        copyCellsFrom(d, p, g, b, y) {
          const w = d._data;
          if (y) for (let C = b - 1; C >= 0; C--) {
            for (let x = 0; x < 3; x++) this._data[3 * (g + C) + x] = w[3 * (p + C) + x];
            268435456 & w[3 * (p + C) + 2] && (this._extendedAttrs[g + C] = d._extendedAttrs[p + C]);
          }
          else for (let C = 0; C < b; C++) {
            for (let x = 0; x < 3; x++) this._data[3 * (g + C) + x] = w[3 * (p + C) + x];
            268435456 & w[3 * (p + C) + 2] && (this._extendedAttrs[g + C] = d._extendedAttrs[p + C]);
          }
          const k = Object.keys(d._combined);
          for (let C = 0; C < k.length; C++) {
            const x = parseInt(k[C], 10);
            x >= p && (this._combined[x - p + g] = d._combined[x]);
          }
        }
        translateToString(d = !1, p = 0, g = this.length) {
          d && (g = Math.min(g, this.getTrimmedLength()));
          let b = "";
          for (; p < g; ) {
            const y = this._data[3 * p + 0], w = 2097151 & y;
            b += 2097152 & y ? this._combined[p] : w ? (0, f.stringFromCodePoint)(w) : h.WHITESPACE_CELL_CHAR, p += y >> 22 || 1;
          }
          return b;
        }
      }
      a.BufferLine = _;
    }, 4841: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getRangeLength = void 0, a.getRangeLength = function(l, c) {
        if (l.start.y > l.end.y) throw new Error(`Buffer range end (${l.end.x}, ${l.end.y}) cannot be before start (${l.start.x}, ${l.start.y})`);
        return c * (l.end.y - l.start.y) + (l.end.x - l.start.x + 1);
      };
    }, 4634: (o, a) => {
      function l(c, u, h) {
        if (u === c.length - 1) return c[u].getTrimmedLength();
        const f = !c[u].hasContent(h - 1) && c[u].getWidth(h - 1) === 1, m = c[u + 1].getWidth(0) === 2;
        return f && m ? h - 1 : h;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getWrappedLineTrimmedLength = a.reflowSmallerGetNewLineLengths = a.reflowLargerApplyNewLayout = a.reflowLargerCreateNewLayout = a.reflowLargerGetLinesToRemove = void 0, a.reflowLargerGetLinesToRemove = function(c, u, h, f, m) {
        const _ = [];
        for (let v = 0; v < c.length - 1; v++) {
          let d = v, p = c.get(++d);
          if (!p.isWrapped) continue;
          const g = [c.get(v)];
          for (; d < c.length && p.isWrapped; ) g.push(p), p = c.get(++d);
          if (f >= v && f < d) {
            v += g.length - 1;
            continue;
          }
          let b = 0, y = l(g, b, u), w = 1, k = 0;
          for (; w < g.length; ) {
            const x = l(g, w, u), S = x - k, T = h - y, M = Math.min(S, T);
            g[b].copyCellsFrom(g[w], k, y, M, !1), y += M, y === h && (b++, y = 0), k += M, k === x && (w++, k = 0), y === 0 && b !== 0 && g[b - 1].getWidth(h - 1) === 2 && (g[b].copyCellsFrom(g[b - 1], h - 1, y++, 1, !1), g[b - 1].setCell(h - 1, m));
          }
          g[b].replaceCells(y, h, m);
          let C = 0;
          for (let x = g.length - 1; x > 0 && (x > b || g[x].getTrimmedLength() === 0); x--) C++;
          C > 0 && (_.push(v + g.length - C), _.push(C)), v += g.length - 1;
        }
        return _;
      }, a.reflowLargerCreateNewLayout = function(c, u) {
        const h = [];
        let f = 0, m = u[f], _ = 0;
        for (let v = 0; v < c.length; v++) if (m === v) {
          const d = u[++f];
          c.onDeleteEmitter.fire({ index: v - _, amount: d }), v += d - 1, _ += d, m = u[++f];
        } else h.push(v);
        return { layout: h, countRemoved: _ };
      }, a.reflowLargerApplyNewLayout = function(c, u) {
        const h = [];
        for (let f = 0; f < u.length; f++) h.push(c.get(u[f]));
        for (let f = 0; f < h.length; f++) c.set(f, h[f]);
        c.length = u.length;
      }, a.reflowSmallerGetNewLineLengths = function(c, u, h) {
        const f = [], m = c.map((p, g) => l(c, g, u)).reduce((p, g) => p + g);
        let _ = 0, v = 0, d = 0;
        for (; d < m; ) {
          if (m - d < h) {
            f.push(m - d);
            break;
          }
          _ += h;
          const p = l(c, v, u);
          _ > p && (_ -= p, v++);
          const g = c[v].getWidth(_ - 1) === 2;
          g && _--;
          const b = g ? h - 1 : h;
          f.push(b), d += b;
        }
        return f;
      }, a.getWrappedLineTrimmedLength = l;
    }, 5295: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferSet = void 0;
      const c = l(8460), u = l(844), h = l(9092);
      class f extends u.Disposable {
        constructor(_, v) {
          super(), this._optionsService = _, this._bufferService = v, this._onBufferActivate = this.register(new c.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
        }
        reset() {
          this._normal = new h.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new h.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
        }
        get alt() {
          return this._alt;
        }
        get active() {
          return this._activeBuffer;
        }
        get normal() {
          return this._normal;
        }
        activateNormalBuffer() {
          this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
        }
        activateAltBuffer(_) {
          this._activeBuffer !== this._alt && (this._alt.fillViewportRows(_), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
        }
        resize(_, v) {
          this._normal.resize(_, v), this._alt.resize(_, v), this.setupTabStops(_);
        }
        setupTabStops(_) {
          this._normal.setupTabStops(_), this._alt.setupTabStops(_);
        }
      }
      a.BufferSet = f;
    }, 511: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CellData = void 0;
      const c = l(482), u = l(643), h = l(3734);
      class f extends h.AttributeData {
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new h.ExtendedAttrs(), this.combinedData = "";
        }
        static fromCharData(_) {
          const v = new f();
          return v.setFromCharData(_), v;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, c.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(_) {
          this.fg = _[u.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let v = !1;
          if (_[u.CHAR_DATA_CHAR_INDEX].length > 2) v = !0;
          else if (_[u.CHAR_DATA_CHAR_INDEX].length === 2) {
            const d = _[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= d && d <= 56319) {
              const p = _[u.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= p && p <= 57343 ? this.content = 1024 * (d - 55296) + p - 56320 + 65536 | _[u.CHAR_DATA_WIDTH_INDEX] << 22 : v = !0;
            } else v = !0;
          } else this.content = _[u.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | _[u.CHAR_DATA_WIDTH_INDEX] << 22;
          v && (this.combinedData = _[u.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | _[u.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      a.CellData = f;
    }, 643: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.WHITESPACE_CELL_CODE = a.WHITESPACE_CELL_WIDTH = a.WHITESPACE_CELL_CHAR = a.NULL_CELL_CODE = a.NULL_CELL_WIDTH = a.NULL_CELL_CHAR = a.CHAR_DATA_CODE_INDEX = a.CHAR_DATA_WIDTH_INDEX = a.CHAR_DATA_CHAR_INDEX = a.CHAR_DATA_ATTR_INDEX = a.DEFAULT_EXT = a.DEFAULT_ATTR = a.DEFAULT_COLOR = void 0, a.DEFAULT_COLOR = 0, a.DEFAULT_ATTR = 256 | a.DEFAULT_COLOR << 9, a.DEFAULT_EXT = 0, a.CHAR_DATA_ATTR_INDEX = 0, a.CHAR_DATA_CHAR_INDEX = 1, a.CHAR_DATA_WIDTH_INDEX = 2, a.CHAR_DATA_CODE_INDEX = 3, a.NULL_CELL_CHAR = "", a.NULL_CELL_WIDTH = 1, a.NULL_CELL_CODE = 0, a.WHITESPACE_CELL_CHAR = " ", a.WHITESPACE_CELL_WIDTH = 1, a.WHITESPACE_CELL_CODE = 32;
    }, 4863: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Marker = void 0;
      const c = l(8460), u = l(844);
      class h {
        get id() {
          return this._id;
        }
        constructor(m) {
          this.line = m, this.isDisposed = !1, this._disposables = [], this._id = h._nextId++, this._onDispose = this.register(new c.EventEmitter()), this.onDispose = this._onDispose.event;
        }
        dispose() {
          this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, u.disposeArray)(this._disposables), this._disposables.length = 0);
        }
        register(m) {
          return this._disposables.push(m), m;
        }
      }
      a.Marker = h, h._nextId = 1;
    }, 7116: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DEFAULT_CHARSET = a.CHARSETS = void 0, a.CHARSETS = {}, a.DEFAULT_CHARSET = a.CHARSETS.B, a.CHARSETS[0] = { "`": "", a: "", b: "", c: "", d: "", e: "", f: "", g: "", h: "", i: "", j: "", k: "", l: "", m: "", n: "", o: "", p: "", q: "", r: "", s: "", t: "", u: "", v: "", w: "", x: "", y: "", z: "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.A = { "#": "" }, a.CHARSETS.B = void 0, a.CHARSETS[4] = { "#": "", "@": "", "[": "ij", "\\": "", "]": "|", "{": "", "|": "f", "}": "", "~": "" }, a.CHARSETS.C = a.CHARSETS[5] = { "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.R = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Q = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.K = { "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Y = { "#": "", "@": "", "[": "", "\\": "", "]": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.E = a.CHARSETS[6] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS.Z = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "" }, a.CHARSETS.H = a.CHARSETS[7] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, a.CHARSETS["="] = { "#": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "" };
    }, 2584: (o, a) => {
      var l, c, u;
      Object.defineProperty(a, "__esModule", { value: !0 }), a.C1_ESCAPED = a.C1 = a.C0 = void 0, function(h) {
        h.NUL = "\0", h.SOH = "", h.STX = "", h.ETX = "", h.EOT = "", h.ENQ = "", h.ACK = "", h.BEL = "\x07", h.BS = "\b", h.HT = "	", h.LF = `
`, h.VT = "\v", h.FF = "\f", h.CR = "\r", h.SO = "", h.SI = "", h.DLE = "", h.DC1 = "", h.DC2 = "", h.DC3 = "", h.DC4 = "", h.NAK = "", h.SYN = "", h.ETB = "", h.CAN = "", h.EM = "", h.SUB = "", h.ESC = "\x1B", h.FS = "", h.GS = "", h.RS = "", h.US = "", h.SP = " ", h.DEL = "";
      }(l || (a.C0 = l = {})), function(h) {
        h.PAD = "", h.HOP = "", h.BPH = "", h.NBH = "", h.IND = "", h.NEL = "", h.SSA = "", h.ESA = "", h.HTS = "", h.HTJ = "", h.VTS = "", h.PLD = "", h.PLU = "", h.RI = "", h.SS2 = "", h.SS3 = "", h.DCS = "", h.PU1 = "", h.PU2 = "", h.STS = "", h.CCH = "", h.MW = "", h.SPA = "", h.EPA = "", h.SOS = "", h.SGCI = "", h.SCI = "", h.CSI = "", h.ST = "", h.OSC = "", h.PM = "", h.APC = "";
      }(c || (a.C1 = c = {})), function(h) {
        h.ST = `${l.ESC}\\`;
      }(u || (a.C1_ESCAPED = u = {}));
    }, 7399: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.evaluateKeyboardEvent = void 0;
      const c = l(2584), u = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
      a.evaluateKeyboardEvent = function(h, f, m, _) {
        const v = { type: 0, cancel: !1, key: void 0 }, d = (h.shiftKey ? 1 : 0) | (h.altKey ? 2 : 0) | (h.ctrlKey ? 4 : 0) | (h.metaKey ? 8 : 0);
        switch (h.keyCode) {
          case 0:
            h.key === "UIKeyInputUpArrow" ? v.key = f ? c.C0.ESC + "OA" : c.C0.ESC + "[A" : h.key === "UIKeyInputLeftArrow" ? v.key = f ? c.C0.ESC + "OD" : c.C0.ESC + "[D" : h.key === "UIKeyInputRightArrow" ? v.key = f ? c.C0.ESC + "OC" : c.C0.ESC + "[C" : h.key === "UIKeyInputDownArrow" && (v.key = f ? c.C0.ESC + "OB" : c.C0.ESC + "[B");
            break;
          case 8:
            if (h.altKey) {
              v.key = c.C0.ESC + c.C0.DEL;
              break;
            }
            v.key = c.C0.DEL;
            break;
          case 9:
            if (h.shiftKey) {
              v.key = c.C0.ESC + "[Z";
              break;
            }
            v.key = c.C0.HT, v.cancel = !0;
            break;
          case 13:
            v.key = h.altKey ? c.C0.ESC + c.C0.CR : c.C0.CR, v.cancel = !0;
            break;
          case 27:
            v.key = c.C0.ESC, h.altKey && (v.key = c.C0.ESC + c.C0.ESC), v.cancel = !0;
            break;
          case 37:
            if (h.metaKey) break;
            d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "D", v.key === c.C0.ESC + "[1;3D" && (v.key = c.C0.ESC + (m ? "b" : "[1;5D"))) : v.key = f ? c.C0.ESC + "OD" : c.C0.ESC + "[D";
            break;
          case 39:
            if (h.metaKey) break;
            d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "C", v.key === c.C0.ESC + "[1;3C" && (v.key = c.C0.ESC + (m ? "f" : "[1;5C"))) : v.key = f ? c.C0.ESC + "OC" : c.C0.ESC + "[C";
            break;
          case 38:
            if (h.metaKey) break;
            d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "A", m || v.key !== c.C0.ESC + "[1;3A" || (v.key = c.C0.ESC + "[1;5A")) : v.key = f ? c.C0.ESC + "OA" : c.C0.ESC + "[A";
            break;
          case 40:
            if (h.metaKey) break;
            d ? (v.key = c.C0.ESC + "[1;" + (d + 1) + "B", m || v.key !== c.C0.ESC + "[1;3B" || (v.key = c.C0.ESC + "[1;5B")) : v.key = f ? c.C0.ESC + "OB" : c.C0.ESC + "[B";
            break;
          case 45:
            h.shiftKey || h.ctrlKey || (v.key = c.C0.ESC + "[2~");
            break;
          case 46:
            v.key = d ? c.C0.ESC + "[3;" + (d + 1) + "~" : c.C0.ESC + "[3~";
            break;
          case 36:
            v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "H" : f ? c.C0.ESC + "OH" : c.C0.ESC + "[H";
            break;
          case 35:
            v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "F" : f ? c.C0.ESC + "OF" : c.C0.ESC + "[F";
            break;
          case 33:
            h.shiftKey ? v.type = 2 : h.ctrlKey ? v.key = c.C0.ESC + "[5;" + (d + 1) + "~" : v.key = c.C0.ESC + "[5~";
            break;
          case 34:
            h.shiftKey ? v.type = 3 : h.ctrlKey ? v.key = c.C0.ESC + "[6;" + (d + 1) + "~" : v.key = c.C0.ESC + "[6~";
            break;
          case 112:
            v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "P" : c.C0.ESC + "OP";
            break;
          case 113:
            v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "Q" : c.C0.ESC + "OQ";
            break;
          case 114:
            v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "R" : c.C0.ESC + "OR";
            break;
          case 115:
            v.key = d ? c.C0.ESC + "[1;" + (d + 1) + "S" : c.C0.ESC + "OS";
            break;
          case 116:
            v.key = d ? c.C0.ESC + "[15;" + (d + 1) + "~" : c.C0.ESC + "[15~";
            break;
          case 117:
            v.key = d ? c.C0.ESC + "[17;" + (d + 1) + "~" : c.C0.ESC + "[17~";
            break;
          case 118:
            v.key = d ? c.C0.ESC + "[18;" + (d + 1) + "~" : c.C0.ESC + "[18~";
            break;
          case 119:
            v.key = d ? c.C0.ESC + "[19;" + (d + 1) + "~" : c.C0.ESC + "[19~";
            break;
          case 120:
            v.key = d ? c.C0.ESC + "[20;" + (d + 1) + "~" : c.C0.ESC + "[20~";
            break;
          case 121:
            v.key = d ? c.C0.ESC + "[21;" + (d + 1) + "~" : c.C0.ESC + "[21~";
            break;
          case 122:
            v.key = d ? c.C0.ESC + "[23;" + (d + 1) + "~" : c.C0.ESC + "[23~";
            break;
          case 123:
            v.key = d ? c.C0.ESC + "[24;" + (d + 1) + "~" : c.C0.ESC + "[24~";
            break;
          default:
            if (!h.ctrlKey || h.shiftKey || h.altKey || h.metaKey) if (m && !_ || !h.altKey || h.metaKey) !m || h.altKey || h.ctrlKey || h.shiftKey || !h.metaKey ? h.key && !h.ctrlKey && !h.altKey && !h.metaKey && h.keyCode >= 48 && h.key.length === 1 ? v.key = h.key : h.key && h.ctrlKey && (h.key === "_" && (v.key = c.C0.US), h.key === "@" && (v.key = c.C0.NUL)) : h.keyCode === 65 && (v.type = 1);
            else {
              const p = u[h.keyCode], g = p == null ? void 0 : p[h.shiftKey ? 1 : 0];
              if (g) v.key = c.C0.ESC + g;
              else if (h.keyCode >= 65 && h.keyCode <= 90) {
                const b = h.ctrlKey ? h.keyCode - 64 : h.keyCode + 32;
                let y = String.fromCharCode(b);
                h.shiftKey && (y = y.toUpperCase()), v.key = c.C0.ESC + y;
              } else if (h.keyCode === 32) v.key = c.C0.ESC + (h.ctrlKey ? c.C0.NUL : " ");
              else if (h.key === "Dead" && h.code.startsWith("Key")) {
                let b = h.code.slice(3, 4);
                h.shiftKey || (b = b.toLowerCase()), v.key = c.C0.ESC + b, v.cancel = !0;
              }
            }
            else h.keyCode >= 65 && h.keyCode <= 90 ? v.key = String.fromCharCode(h.keyCode - 64) : h.keyCode === 32 ? v.key = c.C0.NUL : h.keyCode >= 51 && h.keyCode <= 55 ? v.key = String.fromCharCode(h.keyCode - 51 + 27) : h.keyCode === 56 ? v.key = c.C0.DEL : h.keyCode === 219 ? v.key = c.C0.ESC : h.keyCode === 220 ? v.key = c.C0.FS : h.keyCode === 221 && (v.key = c.C0.GS);
        }
        return v;
      };
    }, 482: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Utf8ToUtf32 = a.StringToUtf32 = a.utf32ToString = a.stringFromCodePoint = void 0, a.stringFromCodePoint = function(l) {
        return l > 65535 ? (l -= 65536, String.fromCharCode(55296 + (l >> 10)) + String.fromCharCode(l % 1024 + 56320)) : String.fromCharCode(l);
      }, a.utf32ToString = function(l, c = 0, u = l.length) {
        let h = "";
        for (let f = c; f < u; ++f) {
          let m = l[f];
          m > 65535 ? (m -= 65536, h += String.fromCharCode(55296 + (m >> 10)) + String.fromCharCode(m % 1024 + 56320)) : h += String.fromCharCode(m);
        }
        return h;
      }, a.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(l, c) {
          const u = l.length;
          if (!u) return 0;
          let h = 0, f = 0;
          if (this._interim) {
            const m = l.charCodeAt(f++);
            56320 <= m && m <= 57343 ? c[h++] = 1024 * (this._interim - 55296) + m - 56320 + 65536 : (c[h++] = this._interim, c[h++] = m), this._interim = 0;
          }
          for (let m = f; m < u; ++m) {
            const _ = l.charCodeAt(m);
            if (55296 <= _ && _ <= 56319) {
              if (++m >= u) return this._interim = _, h;
              const v = l.charCodeAt(m);
              56320 <= v && v <= 57343 ? c[h++] = 1024 * (_ - 55296) + v - 56320 + 65536 : (c[h++] = _, c[h++] = v);
            } else _ !== 65279 && (c[h++] = _);
          }
          return h;
        }
      }, a.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(l, c) {
          const u = l.length;
          if (!u) return 0;
          let h, f, m, _, v = 0, d = 0, p = 0;
          if (this.interim[0]) {
            let y = !1, w = this.interim[0];
            w &= (224 & w) == 192 ? 31 : (240 & w) == 224 ? 15 : 7;
            let k, C = 0;
            for (; (k = 63 & this.interim[++C]) && C < 4; ) w <<= 6, w |= k;
            const x = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, S = x - C;
            for (; p < S; ) {
              if (p >= u) return 0;
              if (k = l[p++], (192 & k) != 128) {
                p--, y = !0;
                break;
              }
              this.interim[C++] = k, w <<= 6, w |= 63 & k;
            }
            y || (x === 2 ? w < 128 ? p-- : c[v++] = w : x === 3 ? w < 2048 || w >= 55296 && w <= 57343 || w === 65279 || (c[v++] = w) : w < 65536 || w > 1114111 || (c[v++] = w)), this.interim.fill(0);
          }
          const g = u - 4;
          let b = p;
          for (; b < u; ) {
            for (; !(!(b < g) || 128 & (h = l[b]) || 128 & (f = l[b + 1]) || 128 & (m = l[b + 2]) || 128 & (_ = l[b + 3])); ) c[v++] = h, c[v++] = f, c[v++] = m, c[v++] = _, b += 4;
            if (h = l[b++], h < 128) c[v++] = h;
            else if ((224 & h) == 192) {
              if (b >= u) return this.interim[0] = h, v;
              if (f = l[b++], (192 & f) != 128) {
                b--;
                continue;
              }
              if (d = (31 & h) << 6 | 63 & f, d < 128) {
                b--;
                continue;
              }
              c[v++] = d;
            } else if ((240 & h) == 224) {
              if (b >= u) return this.interim[0] = h, v;
              if (f = l[b++], (192 & f) != 128) {
                b--;
                continue;
              }
              if (b >= u) return this.interim[0] = h, this.interim[1] = f, v;
              if (m = l[b++], (192 & m) != 128) {
                b--;
                continue;
              }
              if (d = (15 & h) << 12 | (63 & f) << 6 | 63 & m, d < 2048 || d >= 55296 && d <= 57343 || d === 65279) continue;
              c[v++] = d;
            } else if ((248 & h) == 240) {
              if (b >= u) return this.interim[0] = h, v;
              if (f = l[b++], (192 & f) != 128) {
                b--;
                continue;
              }
              if (b >= u) return this.interim[0] = h, this.interim[1] = f, v;
              if (m = l[b++], (192 & m) != 128) {
                b--;
                continue;
              }
              if (b >= u) return this.interim[0] = h, this.interim[1] = f, this.interim[2] = m, v;
              if (_ = l[b++], (192 & _) != 128) {
                b--;
                continue;
              }
              if (d = (7 & h) << 18 | (63 & f) << 12 | (63 & m) << 6 | 63 & _, d < 65536 || d > 1114111) continue;
              c[v++] = d;
            }
          }
          return v;
        }
      };
    }, 225: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeV6 = void 0;
      const l = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], c = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
      let u;
      a.UnicodeV6 = class {
        constructor() {
          if (this.version = "6", !u) {
            u = new Uint8Array(65536), u.fill(1), u[0] = 0, u.fill(0, 1, 32), u.fill(0, 127, 160), u.fill(2, 4352, 4448), u[9001] = 2, u[9002] = 2, u.fill(2, 11904, 42192), u[12351] = 1, u.fill(2, 44032, 55204), u.fill(2, 63744, 64256), u.fill(2, 65040, 65050), u.fill(2, 65072, 65136), u.fill(2, 65280, 65377), u.fill(2, 65504, 65511);
            for (let h = 0; h < l.length; ++h) u.fill(0, l[h][0], l[h][1] + 1);
          }
        }
        wcwidth(h) {
          return h < 32 ? 0 : h < 127 ? 1 : h < 65536 ? u[h] : function(f, m) {
            let _, v = 0, d = m.length - 1;
            if (f < m[0][0] || f > m[d][1]) return !1;
            for (; d >= v; ) if (_ = v + d >> 1, f > m[_][1]) v = _ + 1;
            else {
              if (!(f < m[_][0])) return !0;
              d = _ - 1;
            }
            return !1;
          }(h, c) ? 0 : h >= 131072 && h <= 196605 || h >= 196608 && h <= 262141 ? 2 : 1;
        }
      };
    }, 5981: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.WriteBuffer = void 0;
      const c = l(8460), u = l(844);
      class h extends u.Disposable {
        constructor(m) {
          super(), this._action = m, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new c.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
        }
        handleUserInput() {
          this._didUserInput = !0;
        }
        writeSync(m, _) {
          if (_ !== void 0 && this._syncCalls > _) return void (this._syncCalls = 0);
          if (this._pendingData += m.length, this._writeBuffer.push(m), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
          let v;
          for (this._isSyncWriting = !0; v = this._writeBuffer.shift(); ) {
            this._action(v);
            const d = this._callbacks.shift();
            d && d();
          }
          this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
        }
        write(m, _) {
          if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
          if (!this._writeBuffer.length) {
            if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += m.length, this._writeBuffer.push(m), this._callbacks.push(_), void this._innerWrite();
            setTimeout(() => this._innerWrite());
          }
          this._pendingData += m.length, this._writeBuffer.push(m), this._callbacks.push(_);
        }
        _innerWrite(m = 0, _ = !0) {
          const v = m || Date.now();
          for (; this._writeBuffer.length > this._bufferOffset; ) {
            const d = this._writeBuffer[this._bufferOffset], p = this._action(d, _);
            if (p) {
              const b = (y) => Date.now() - v >= 12 ? setTimeout(() => this._innerWrite(0, y)) : this._innerWrite(v, y);
              return void p.catch((y) => (queueMicrotask(() => {
                throw y;
              }), Promise.resolve(!1))).then(b);
            }
            const g = this._callbacks[this._bufferOffset];
            if (g && g(), this._bufferOffset++, this._pendingData -= d.length, Date.now() - v >= 12) break;
          }
          this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
        }
      }
      a.WriteBuffer = h;
    }, 5941: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.toRgbString = a.parseColor = void 0;
      const l = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, c = /^[\da-f]+$/;
      function u(h, f) {
        const m = h.toString(16), _ = m.length < 2 ? "0" + m : m;
        switch (f) {
          case 4:
            return m[0];
          case 8:
            return _;
          case 12:
            return (_ + _).slice(0, 3);
          default:
            return _ + _;
        }
      }
      a.parseColor = function(h) {
        if (!h) return;
        let f = h.toLowerCase();
        if (f.indexOf("rgb:") === 0) {
          f = f.slice(4);
          const m = l.exec(f);
          if (m) {
            const _ = m[1] ? 15 : m[4] ? 255 : m[7] ? 4095 : 65535;
            return [Math.round(parseInt(m[1] || m[4] || m[7] || m[10], 16) / _ * 255), Math.round(parseInt(m[2] || m[5] || m[8] || m[11], 16) / _ * 255), Math.round(parseInt(m[3] || m[6] || m[9] || m[12], 16) / _ * 255)];
          }
        } else if (f.indexOf("#") === 0 && (f = f.slice(1), c.exec(f) && [3, 6, 9, 12].includes(f.length))) {
          const m = f.length / 3, _ = [0, 0, 0];
          for (let v = 0; v < 3; ++v) {
            const d = parseInt(f.slice(m * v, m * v + m), 16);
            _[v] = m === 1 ? d << 4 : m === 2 ? d : m === 3 ? d >> 4 : d >> 8;
          }
          return _;
        }
      }, a.toRgbString = function(h, f = 16) {
        const [m, _, v] = h;
        return `rgb:${u(m, f)}/${u(_, f)}/${u(v, f)}`;
      };
    }, 5770: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.PAYLOAD_LIMIT = void 0, a.PAYLOAD_LIMIT = 1e7;
    }, 6351: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DcsHandler = a.DcsParser = void 0;
      const c = l(482), u = l(8742), h = l(5770), f = [];
      a.DcsParser = class {
        constructor() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._active = f, this._ident = 0, this._handlerFb = () => {
          }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = f;
        }
        registerHandler(_, v) {
          this._handlers[_] === void 0 && (this._handlers[_] = []);
          const d = this._handlers[_];
          return d.push(v), { dispose: () => {
            const p = d.indexOf(v);
            p !== -1 && d.splice(p, 1);
          } };
        }
        clearHandler(_) {
          this._handlers[_] && delete this._handlers[_];
        }
        setHandlerFallback(_) {
          this._handlerFb = _;
        }
        reset() {
          if (this._active.length) for (let _ = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; _ >= 0; --_) this._active[_].unhook(!1);
          this._stack.paused = !1, this._active = f, this._ident = 0;
        }
        hook(_, v) {
          if (this.reset(), this._ident = _, this._active = this._handlers[_] || f, this._active.length) for (let d = this._active.length - 1; d >= 0; d--) this._active[d].hook(v);
          else this._handlerFb(this._ident, "HOOK", v);
        }
        put(_, v, d) {
          if (this._active.length) for (let p = this._active.length - 1; p >= 0; p--) this._active[p].put(_, v, d);
          else this._handlerFb(this._ident, "PUT", (0, c.utf32ToString)(_, v, d));
        }
        unhook(_, v = !0) {
          if (this._active.length) {
            let d = !1, p = this._active.length - 1, g = !1;
            if (this._stack.paused && (p = this._stack.loopPosition - 1, d = v, g = this._stack.fallThrough, this._stack.paused = !1), !g && d === !1) {
              for (; p >= 0 && (d = this._active[p].unhook(_), d !== !0); p--) if (d instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = p, this._stack.fallThrough = !1, d;
              p--;
            }
            for (; p >= 0; p--) if (d = this._active[p].unhook(!1), d instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = p, this._stack.fallThrough = !0, d;
          } else this._handlerFb(this._ident, "UNHOOK", _);
          this._active = f, this._ident = 0;
        }
      };
      const m = new u.Params();
      m.addParam(0), a.DcsHandler = class {
        constructor(_) {
          this._handler = _, this._data = "", this._params = m, this._hitLimit = !1;
        }
        hook(_) {
          this._params = _.length > 1 || _.params[0] ? _.clone() : m, this._data = "", this._hitLimit = !1;
        }
        put(_, v, d) {
          this._hitLimit || (this._data += (0, c.utf32ToString)(_, v, d), this._data.length > h.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
        }
        unhook(_) {
          let v = !1;
          if (this._hitLimit) v = !1;
          else if (_ && (v = this._handler(this._data, this._params), v instanceof Promise)) return v.then((d) => (this._params = m, this._data = "", this._hitLimit = !1, d));
          return this._params = m, this._data = "", this._hitLimit = !1, v;
        }
      };
    }, 2015: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.EscapeSequenceParser = a.VT500_TRANSITION_TABLE = a.TransitionTable = void 0;
      const c = l(844), u = l(8742), h = l(6242), f = l(6351);
      class m {
        constructor(p) {
          this.table = new Uint8Array(p);
        }
        setDefault(p, g) {
          this.table.fill(p << 4 | g);
        }
        add(p, g, b, y) {
          this.table[g << 8 | p] = b << 4 | y;
        }
        addMany(p, g, b, y) {
          for (let w = 0; w < p.length; w++) this.table[g << 8 | p[w]] = b << 4 | y;
        }
      }
      a.TransitionTable = m;
      const _ = 160;
      a.VT500_TRANSITION_TABLE = function() {
        const d = new m(4095), p = Array.apply(null, Array(256)).map((C, x) => x), g = (C, x) => p.slice(C, x), b = g(32, 127), y = g(0, 24);
        y.push(25), y.push.apply(y, g(28, 32));
        const w = g(0, 14);
        let k;
        for (k in d.setDefault(1, 0), d.addMany(b, 0, 2, 0), w) d.addMany([24, 26, 153, 154], k, 3, 0), d.addMany(g(128, 144), k, 3, 0), d.addMany(g(144, 152), k, 3, 0), d.add(156, k, 0, 0), d.add(27, k, 11, 1), d.add(157, k, 4, 8), d.addMany([152, 158, 159], k, 0, 7), d.add(155, k, 11, 3), d.add(144, k, 11, 9);
        return d.addMany(y, 0, 3, 0), d.addMany(y, 1, 3, 1), d.add(127, 1, 0, 1), d.addMany(y, 8, 0, 8), d.addMany(y, 3, 3, 3), d.add(127, 3, 0, 3), d.addMany(y, 4, 3, 4), d.add(127, 4, 0, 4), d.addMany(y, 6, 3, 6), d.addMany(y, 5, 3, 5), d.add(127, 5, 0, 5), d.addMany(y, 2, 3, 2), d.add(127, 2, 0, 2), d.add(93, 1, 4, 8), d.addMany(b, 8, 5, 8), d.add(127, 8, 5, 8), d.addMany([156, 27, 24, 26, 7], 8, 6, 0), d.addMany(g(28, 32), 8, 0, 8), d.addMany([88, 94, 95], 1, 0, 7), d.addMany(b, 7, 0, 7), d.addMany(y, 7, 0, 7), d.add(156, 7, 0, 0), d.add(127, 7, 0, 7), d.add(91, 1, 11, 3), d.addMany(g(64, 127), 3, 7, 0), d.addMany(g(48, 60), 3, 8, 4), d.addMany([60, 61, 62, 63], 3, 9, 4), d.addMany(g(48, 60), 4, 8, 4), d.addMany(g(64, 127), 4, 7, 0), d.addMany([60, 61, 62, 63], 4, 0, 6), d.addMany(g(32, 64), 6, 0, 6), d.add(127, 6, 0, 6), d.addMany(g(64, 127), 6, 0, 0), d.addMany(g(32, 48), 3, 9, 5), d.addMany(g(32, 48), 5, 9, 5), d.addMany(g(48, 64), 5, 0, 6), d.addMany(g(64, 127), 5, 7, 0), d.addMany(g(32, 48), 4, 9, 5), d.addMany(g(32, 48), 1, 9, 2), d.addMany(g(32, 48), 2, 9, 2), d.addMany(g(48, 127), 2, 10, 0), d.addMany(g(48, 80), 1, 10, 0), d.addMany(g(81, 88), 1, 10, 0), d.addMany([89, 90, 92], 1, 10, 0), d.addMany(g(96, 127), 1, 10, 0), d.add(80, 1, 11, 9), d.addMany(y, 9, 0, 9), d.add(127, 9, 0, 9), d.addMany(g(28, 32), 9, 0, 9), d.addMany(g(32, 48), 9, 9, 12), d.addMany(g(48, 60), 9, 8, 10), d.addMany([60, 61, 62, 63], 9, 9, 10), d.addMany(y, 11, 0, 11), d.addMany(g(32, 128), 11, 0, 11), d.addMany(g(28, 32), 11, 0, 11), d.addMany(y, 10, 0, 10), d.add(127, 10, 0, 10), d.addMany(g(28, 32), 10, 0, 10), d.addMany(g(48, 60), 10, 8, 10), d.addMany([60, 61, 62, 63], 10, 0, 11), d.addMany(g(32, 48), 10, 9, 12), d.addMany(y, 12, 0, 12), d.add(127, 12, 0, 12), d.addMany(g(28, 32), 12, 0, 12), d.addMany(g(32, 48), 12, 9, 12), d.addMany(g(48, 64), 12, 0, 11), d.addMany(g(64, 127), 12, 12, 13), d.addMany(g(64, 127), 10, 12, 13), d.addMany(g(64, 127), 9, 12, 13), d.addMany(y, 13, 13, 13), d.addMany(b, 13, 13, 13), d.add(127, 13, 0, 13), d.addMany([27, 156, 24, 26], 13, 14, 0), d.add(_, 0, 2, 0), d.add(_, 8, 5, 8), d.add(_, 6, 0, 6), d.add(_, 11, 0, 11), d.add(_, 13, 13, 13), d;
      }();
      class v extends c.Disposable {
        constructor(p = a.VT500_TRANSITION_TABLE) {
          super(), this._transitions = p, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new u.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (g, b, y) => {
          }, this._executeHandlerFb = (g) => {
          }, this._csiHandlerFb = (g, b) => {
          }, this._escHandlerFb = (g) => {
          }, this._errorHandlerFb = (g) => g, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, c.toDisposable)(() => {
            this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
          })), this._oscParser = this.register(new h.OscParser()), this._dcsParser = this.register(new f.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0);
        }
        _identifier(p, g = [64, 126]) {
          let b = 0;
          if (p.prefix) {
            if (p.prefix.length > 1) throw new Error("only one byte as prefix supported");
            if (b = p.prefix.charCodeAt(0), b && 60 > b || b > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
          }
          if (p.intermediates) {
            if (p.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
            for (let w = 0; w < p.intermediates.length; ++w) {
              const k = p.intermediates.charCodeAt(w);
              if (32 > k || k > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
              b <<= 8, b |= k;
            }
          }
          if (p.final.length !== 1) throw new Error("final must be a single byte");
          const y = p.final.charCodeAt(0);
          if (g[0] > y || y > g[1]) throw new Error(`final must be in range ${g[0]} .. ${g[1]}`);
          return b <<= 8, b |= y, b;
        }
        identToString(p) {
          const g = [];
          for (; p; ) g.push(String.fromCharCode(255 & p)), p >>= 8;
          return g.reverse().join("");
        }
        setPrintHandler(p) {
          this._printHandler = p;
        }
        clearPrintHandler() {
          this._printHandler = this._printHandlerFb;
        }
        registerEscHandler(p, g) {
          const b = this._identifier(p, [48, 126]);
          this._escHandlers[b] === void 0 && (this._escHandlers[b] = []);
          const y = this._escHandlers[b];
          return y.push(g), { dispose: () => {
            const w = y.indexOf(g);
            w !== -1 && y.splice(w, 1);
          } };
        }
        clearEscHandler(p) {
          this._escHandlers[this._identifier(p, [48, 126])] && delete this._escHandlers[this._identifier(p, [48, 126])];
        }
        setEscHandlerFallback(p) {
          this._escHandlerFb = p;
        }
        setExecuteHandler(p, g) {
          this._executeHandlers[p.charCodeAt(0)] = g;
        }
        clearExecuteHandler(p) {
          this._executeHandlers[p.charCodeAt(0)] && delete this._executeHandlers[p.charCodeAt(0)];
        }
        setExecuteHandlerFallback(p) {
          this._executeHandlerFb = p;
        }
        registerCsiHandler(p, g) {
          const b = this._identifier(p);
          this._csiHandlers[b] === void 0 && (this._csiHandlers[b] = []);
          const y = this._csiHandlers[b];
          return y.push(g), { dispose: () => {
            const w = y.indexOf(g);
            w !== -1 && y.splice(w, 1);
          } };
        }
        clearCsiHandler(p) {
          this._csiHandlers[this._identifier(p)] && delete this._csiHandlers[this._identifier(p)];
        }
        setCsiHandlerFallback(p) {
          this._csiHandlerFb = p;
        }
        registerDcsHandler(p, g) {
          return this._dcsParser.registerHandler(this._identifier(p), g);
        }
        clearDcsHandler(p) {
          this._dcsParser.clearHandler(this._identifier(p));
        }
        setDcsHandlerFallback(p) {
          this._dcsParser.setHandlerFallback(p);
        }
        registerOscHandler(p, g) {
          return this._oscParser.registerHandler(p, g);
        }
        clearOscHandler(p) {
          this._oscParser.clearHandler(p);
        }
        setOscHandlerFallback(p) {
          this._oscParser.setHandlerFallback(p);
        }
        setErrorHandler(p) {
          this._errorHandler = p;
        }
        clearErrorHandler() {
          this._errorHandler = this._errorHandlerFb;
        }
        reset() {
          this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
        }
        _preserveStack(p, g, b, y, w) {
          this._parseStack.state = p, this._parseStack.handlers = g, this._parseStack.handlerPos = b, this._parseStack.transition = y, this._parseStack.chunkPos = w;
        }
        parse(p, g, b) {
          let y, w = 0, k = 0, C = 0;
          if (this._parseStack.state) if (this._parseStack.state === 2) this._parseStack.state = 0, C = this._parseStack.chunkPos + 1;
          else {
            if (b === void 0 || this._parseStack.state === 1) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
            const x = this._parseStack.handlers;
            let S = this._parseStack.handlerPos - 1;
            switch (this._parseStack.state) {
              case 3:
                if (b === !1 && S > -1) {
                  for (; S >= 0 && (y = x[S](this._params), y !== !0); S--) if (y instanceof Promise) return this._parseStack.handlerPos = S, y;
                }
                this._parseStack.handlers = [];
                break;
              case 4:
                if (b === !1 && S > -1) {
                  for (; S >= 0 && (y = x[S](), y !== !0); S--) if (y instanceof Promise) return this._parseStack.handlerPos = S, y;
                }
                this._parseStack.handlers = [];
                break;
              case 6:
                if (w = p[this._parseStack.chunkPos], y = this._dcsParser.unhook(w !== 24 && w !== 26, b), y) return y;
                w === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 5:
                if (w = p[this._parseStack.chunkPos], y = this._oscParser.end(w !== 24 && w !== 26, b), y) return y;
                w === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
            }
            this._parseStack.state = 0, C = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
          }
          for (let x = C; x < g; ++x) {
            switch (w = p[x], k = this._transitions.table[this.currentState << 8 | (w < 160 ? w : _)], k >> 4) {
              case 2:
                for (let R = x + 1; ; ++R) {
                  if (R >= g || (w = p[R]) < 32 || w > 126 && w < _) {
                    this._printHandler(p, x, R), x = R - 1;
                    break;
                  }
                  if (++R >= g || (w = p[R]) < 32 || w > 126 && w < _) {
                    this._printHandler(p, x, R), x = R - 1;
                    break;
                  }
                  if (++R >= g || (w = p[R]) < 32 || w > 126 && w < _) {
                    this._printHandler(p, x, R), x = R - 1;
                    break;
                  }
                  if (++R >= g || (w = p[R]) < 32 || w > 126 && w < _) {
                    this._printHandler(p, x, R), x = R - 1;
                    break;
                  }
                }
                break;
              case 3:
                this._executeHandlers[w] ? this._executeHandlers[w]() : this._executeHandlerFb(w), this.precedingCodepoint = 0;
                break;
              case 0:
                break;
              case 1:
                if (this._errorHandler({ position: x, code: w, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort) return;
                break;
              case 7:
                const S = this._csiHandlers[this._collect << 8 | w];
                let T = S ? S.length - 1 : -1;
                for (; T >= 0 && (y = S[T](this._params), y !== !0); T--) if (y instanceof Promise) return this._preserveStack(3, S, T, k, x), y;
                T < 0 && this._csiHandlerFb(this._collect << 8 | w, this._params), this.precedingCodepoint = 0;
                break;
              case 8:
                do
                  switch (w) {
                    case 59:
                      this._params.addParam(0);
                      break;
                    case 58:
                      this._params.addSubParam(-1);
                      break;
                    default:
                      this._params.addDigit(w - 48);
                  }
                while (++x < g && (w = p[x]) > 47 && w < 60);
                x--;
                break;
              case 9:
                this._collect <<= 8, this._collect |= w;
                break;
              case 10:
                const M = this._escHandlers[this._collect << 8 | w];
                let E = M ? M.length - 1 : -1;
                for (; E >= 0 && (y = M[E](), y !== !0); E--) if (y instanceof Promise) return this._preserveStack(4, M, E, k, x), y;
                E < 0 && this._escHandlerFb(this._collect << 8 | w), this.precedingCodepoint = 0;
                break;
              case 11:
                this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 12:
                this._dcsParser.hook(this._collect << 8 | w, this._params);
                break;
              case 13:
                for (let R = x + 1; ; ++R) if (R >= g || (w = p[R]) === 24 || w === 26 || w === 27 || w > 127 && w < _) {
                  this._dcsParser.put(p, x, R), x = R - 1;
                  break;
                }
                break;
              case 14:
                if (y = this._dcsParser.unhook(w !== 24 && w !== 26), y) return this._preserveStack(6, [], 0, k, x), y;
                w === 27 && (k |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                break;
              case 4:
                this._oscParser.start();
                break;
              case 5:
                for (let R = x + 1; ; R++) if (R >= g || (w = p[R]) < 32 || w > 127 && w < _) {
                  this._oscParser.put(p, x, R), x = R - 1;
                  break;
                }
                break;
              case 6:
                if (y = this._oscParser.end(w !== 24 && w !== 26), y) return this._preserveStack(5, [], 0, k, x), y;
                w === 27 && (k |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
            }
            this.currentState = 15 & k;
          }
        }
      }
      a.EscapeSequenceParser = v;
    }, 6242: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OscHandler = a.OscParser = void 0;
      const c = l(5770), u = l(482), h = [];
      a.OscParser = class {
        constructor() {
          this._state = 0, this._active = h, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
        }
        registerHandler(f, m) {
          this._handlers[f] === void 0 && (this._handlers[f] = []);
          const _ = this._handlers[f];
          return _.push(m), { dispose: () => {
            const v = _.indexOf(m);
            v !== -1 && _.splice(v, 1);
          } };
        }
        clearHandler(f) {
          this._handlers[f] && delete this._handlers[f];
        }
        setHandlerFallback(f) {
          this._handlerFb = f;
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = h;
        }
        reset() {
          if (this._state === 2) for (let f = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; f >= 0; --f) this._active[f].end(!1);
          this._stack.paused = !1, this._active = h, this._id = -1, this._state = 0;
        }
        _start() {
          if (this._active = this._handlers[this._id] || h, this._active.length) for (let f = this._active.length - 1; f >= 0; f--) this._active[f].start();
          else this._handlerFb(this._id, "START");
        }
        _put(f, m, _) {
          if (this._active.length) for (let v = this._active.length - 1; v >= 0; v--) this._active[v].put(f, m, _);
          else this._handlerFb(this._id, "PUT", (0, u.utf32ToString)(f, m, _));
        }
        start() {
          this.reset(), this._state = 1;
        }
        put(f, m, _) {
          if (this._state !== 3) {
            if (this._state === 1) for (; m < _; ) {
              const v = f[m++];
              if (v === 59) {
                this._state = 2, this._start();
                break;
              }
              if (v < 48 || 57 < v) return void (this._state = 3);
              this._id === -1 && (this._id = 0), this._id = 10 * this._id + v - 48;
            }
            this._state === 2 && _ - m > 0 && this._put(f, m, _);
          }
        }
        end(f, m = !0) {
          if (this._state !== 0) {
            if (this._state !== 3) if (this._state === 1 && this._start(), this._active.length) {
              let _ = !1, v = this._active.length - 1, d = !1;
              if (this._stack.paused && (v = this._stack.loopPosition - 1, _ = m, d = this._stack.fallThrough, this._stack.paused = !1), !d && _ === !1) {
                for (; v >= 0 && (_ = this._active[v].end(f), _ !== !0); v--) if (_ instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = v, this._stack.fallThrough = !1, _;
                v--;
              }
              for (; v >= 0; v--) if (_ = this._active[v].end(!1), _ instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = v, this._stack.fallThrough = !0, _;
            } else this._handlerFb(this._id, "END", f);
            this._active = h, this._id = -1, this._state = 0;
          }
        }
      }, a.OscHandler = class {
        constructor(f) {
          this._handler = f, this._data = "", this._hitLimit = !1;
        }
        start() {
          this._data = "", this._hitLimit = !1;
        }
        put(f, m, _) {
          this._hitLimit || (this._data += (0, u.utf32ToString)(f, m, _), this._data.length > c.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
        }
        end(f) {
          let m = !1;
          if (this._hitLimit) m = !1;
          else if (f && (m = this._handler(this._data), m instanceof Promise)) return m.then((_) => (this._data = "", this._hitLimit = !1, _));
          return this._data = "", this._hitLimit = !1, m;
        }
      };
    }, 8742: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.Params = void 0;
      const l = 2147483647;
      class c {
        static fromArray(h) {
          const f = new c();
          if (!h.length) return f;
          for (let m = Array.isArray(h[0]) ? 1 : 0; m < h.length; ++m) {
            const _ = h[m];
            if (Array.isArray(_)) for (let v = 0; v < _.length; ++v) f.addSubParam(_[v]);
            else f.addParam(_);
          }
          return f;
        }
        constructor(h = 32, f = 32) {
          if (this.maxLength = h, this.maxSubParamsLength = f, f > 256) throw new Error("maxSubParamsLength must not be greater than 256");
          this.params = new Int32Array(h), this.length = 0, this._subParams = new Int32Array(f), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(h), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
        }
        clone() {
          const h = new c(this.maxLength, this.maxSubParamsLength);
          return h.params.set(this.params), h.length = this.length, h._subParams.set(this._subParams), h._subParamsLength = this._subParamsLength, h._subParamsIdx.set(this._subParamsIdx), h._rejectDigits = this._rejectDigits, h._rejectSubDigits = this._rejectSubDigits, h._digitIsSub = this._digitIsSub, h;
        }
        toArray() {
          const h = [];
          for (let f = 0; f < this.length; ++f) {
            h.push(this.params[f]);
            const m = this._subParamsIdx[f] >> 8, _ = 255 & this._subParamsIdx[f];
            _ - m > 0 && h.push(Array.prototype.slice.call(this._subParams, m, _));
          }
          return h;
        }
        reset() {
          this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
        }
        addParam(h) {
          if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;
          else {
            if (h < -1) throw new Error("values lesser than -1 are not allowed");
            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = h > l ? l : h;
          }
        }
        addSubParam(h) {
          if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;
          else {
            if (h < -1) throw new Error("values lesser than -1 are not allowed");
            this._subParams[this._subParamsLength++] = h > l ? l : h, this._subParamsIdx[this.length - 1]++;
          }
        }
        hasSubParams(h) {
          return (255 & this._subParamsIdx[h]) - (this._subParamsIdx[h] >> 8) > 0;
        }
        getSubParams(h) {
          const f = this._subParamsIdx[h] >> 8, m = 255 & this._subParamsIdx[h];
          return m - f > 0 ? this._subParams.subarray(f, m) : null;
        }
        getSubParamsAll() {
          const h = {};
          for (let f = 0; f < this.length; ++f) {
            const m = this._subParamsIdx[f] >> 8, _ = 255 & this._subParamsIdx[f];
            _ - m > 0 && (h[f] = this._subParams.slice(m, _));
          }
          return h;
        }
        addDigit(h) {
          let f;
          if (this._rejectDigits || !(f = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
          const m = this._digitIsSub ? this._subParams : this.params, _ = m[f - 1];
          m[f - 1] = ~_ ? Math.min(10 * _ + h, l) : h;
        }
      }
      a.Params = c;
    }, 5741: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.AddonManager = void 0, a.AddonManager = class {
        constructor() {
          this._addons = [];
        }
        dispose() {
          for (let l = this._addons.length - 1; l >= 0; l--) this._addons[l].instance.dispose();
        }
        loadAddon(l, c) {
          const u = { instance: c, dispose: c.dispose, isDisposed: !1 };
          this._addons.push(u), c.dispose = () => this._wrappedAddonDispose(u), c.activate(l);
        }
        _wrappedAddonDispose(l) {
          if (l.isDisposed) return;
          let c = -1;
          for (let u = 0; u < this._addons.length; u++) if (this._addons[u] === l) {
            c = u;
            break;
          }
          if (c === -1) throw new Error("Could not dispose an addon that has not been loaded");
          l.isDisposed = !0, l.dispose.apply(l.instance), this._addons.splice(c, 1);
        }
      };
    }, 8771: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferApiView = void 0;
      const c = l(3785), u = l(511);
      a.BufferApiView = class {
        constructor(h, f) {
          this._buffer = h, this.type = f;
        }
        init(h) {
          return this._buffer = h, this;
        }
        get cursorY() {
          return this._buffer.y;
        }
        get cursorX() {
          return this._buffer.x;
        }
        get viewportY() {
          return this._buffer.ydisp;
        }
        get baseY() {
          return this._buffer.ybase;
        }
        get length() {
          return this._buffer.lines.length;
        }
        getLine(h) {
          const f = this._buffer.lines.get(h);
          if (f) return new c.BufferLineApiView(f);
        }
        getNullCell() {
          return new u.CellData();
        }
      };
    }, 3785: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferLineApiView = void 0;
      const c = l(511);
      a.BufferLineApiView = class {
        constructor(u) {
          this._line = u;
        }
        get isWrapped() {
          return this._line.isWrapped;
        }
        get length() {
          return this._line.length;
        }
        getCell(u, h) {
          if (!(u < 0 || u >= this._line.length)) return h ? (this._line.loadCell(u, h), h) : this._line.loadCell(u, new c.CellData());
        }
        translateToString(u, h, f) {
          return this._line.translateToString(u, h, f);
        }
      };
    }, 8285: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferNamespaceApi = void 0;
      const c = l(8771), u = l(8460), h = l(844);
      class f extends h.Disposable {
        constructor(_) {
          super(), this._core = _, this._onBufferChange = this.register(new u.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new c.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new c.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
        }
        get active() {
          if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
          if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
          throw new Error("Active buffer is neither normal nor alternate");
        }
        get normal() {
          return this._normal.init(this._core.buffers.normal);
        }
        get alternate() {
          return this._alternate.init(this._core.buffers.alt);
        }
      }
      a.BufferNamespaceApi = f;
    }, 7975: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.ParserApi = void 0, a.ParserApi = class {
        constructor(l) {
          this._core = l;
        }
        registerCsiHandler(l, c) {
          return this._core.registerCsiHandler(l, (u) => c(u.toArray()));
        }
        addCsiHandler(l, c) {
          return this.registerCsiHandler(l, c);
        }
        registerDcsHandler(l, c) {
          return this._core.registerDcsHandler(l, (u, h) => c(u, h.toArray()));
        }
        addDcsHandler(l, c) {
          return this.registerDcsHandler(l, c);
        }
        registerEscHandler(l, c) {
          return this._core.registerEscHandler(l, c);
        }
        addEscHandler(l, c) {
          return this.registerEscHandler(l, c);
        }
        registerOscHandler(l, c) {
          return this._core.registerOscHandler(l, c);
        }
        addOscHandler(l, c) {
          return this.registerOscHandler(l, c);
        }
      };
    }, 7090: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeApi = void 0, a.UnicodeApi = class {
        constructor(l) {
          this._core = l;
        }
        register(l) {
          this._core.unicodeService.register(l);
        }
        get versions() {
          return this._core.unicodeService.versions;
        }
        get activeVersion() {
          return this._core.unicodeService.activeVersion;
        }
        set activeVersion(l) {
          this._core.unicodeService.activeVersion = l;
        }
      };
    }, 744: function(o, a, l) {
      var c = this && this.__decorate || function(d, p, g, b) {
        var y, w = arguments.length, k = w < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, g) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(d, p, g, b);
        else for (var C = d.length - 1; C >= 0; C--) (y = d[C]) && (k = (w < 3 ? y(k) : w > 3 ? y(p, g, k) : y(p, g)) || k);
        return w > 3 && k && Object.defineProperty(p, g, k), k;
      }, u = this && this.__param || function(d, p) {
        return function(g, b) {
          p(g, b, d);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.BufferService = a.MINIMUM_ROWS = a.MINIMUM_COLS = void 0;
      const h = l(8460), f = l(844), m = l(5295), _ = l(2585);
      a.MINIMUM_COLS = 2, a.MINIMUM_ROWS = 1;
      let v = a.BufferService = class extends f.Disposable {
        get buffer() {
          return this.buffers.active;
        }
        constructor(d) {
          super(), this.isUserScrolling = !1, this._onResize = this.register(new h.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new h.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(d.rawOptions.cols || 0, a.MINIMUM_COLS), this.rows = Math.max(d.rawOptions.rows || 0, a.MINIMUM_ROWS), this.buffers = this.register(new m.BufferSet(d, this));
        }
        resize(d, p) {
          this.cols = d, this.rows = p, this.buffers.resize(d, p), this._onResize.fire({ cols: d, rows: p });
        }
        reset() {
          this.buffers.reset(), this.isUserScrolling = !1;
        }
        scroll(d, p = !1) {
          const g = this.buffer;
          let b;
          b = this._cachedBlankLine, b && b.length === this.cols && b.getFg(0) === d.fg && b.getBg(0) === d.bg || (b = g.getBlankLine(d, p), this._cachedBlankLine = b), b.isWrapped = p;
          const y = g.ybase + g.scrollTop, w = g.ybase + g.scrollBottom;
          if (g.scrollTop === 0) {
            const k = g.lines.isFull;
            w === g.lines.length - 1 ? k ? g.lines.recycle().copyFrom(b) : g.lines.push(b.clone()) : g.lines.splice(w + 1, 0, b.clone()), k ? this.isUserScrolling && (g.ydisp = Math.max(g.ydisp - 1, 0)) : (g.ybase++, this.isUserScrolling || g.ydisp++);
          } else {
            const k = w - y + 1;
            g.lines.shiftElements(y + 1, k - 1, -1), g.lines.set(w, b.clone());
          }
          this.isUserScrolling || (g.ydisp = g.ybase), this._onScroll.fire(g.ydisp);
        }
        scrollLines(d, p, g) {
          const b = this.buffer;
          if (d < 0) {
            if (b.ydisp === 0) return;
            this.isUserScrolling = !0;
          } else d + b.ydisp >= b.ybase && (this.isUserScrolling = !1);
          const y = b.ydisp;
          b.ydisp = Math.max(Math.min(b.ydisp + d, b.ybase), 0), y !== b.ydisp && (p || this._onScroll.fire(b.ydisp));
        }
      };
      a.BufferService = v = c([u(0, _.IOptionsService)], v);
    }, 7994: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CharsetService = void 0, a.CharsetService = class {
        constructor() {
          this.glevel = 0, this._charsets = [];
        }
        reset() {
          this.charset = void 0, this._charsets = [], this.glevel = 0;
        }
        setgLevel(l) {
          this.glevel = l, this.charset = this._charsets[l];
        }
        setgCharset(l, c) {
          this._charsets[l] = c, this.glevel === l && (this.charset = c);
        }
      };
    }, 1753: function(o, a, l) {
      var c = this && this.__decorate || function(b, y, w, k) {
        var C, x = arguments.length, S = x < 3 ? y : k === null ? k = Object.getOwnPropertyDescriptor(y, w) : k;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(b, y, w, k);
        else for (var T = b.length - 1; T >= 0; T--) (C = b[T]) && (S = (x < 3 ? C(S) : x > 3 ? C(y, w, S) : C(y, w)) || S);
        return x > 3 && S && Object.defineProperty(y, w, S), S;
      }, u = this && this.__param || function(b, y) {
        return function(w, k) {
          y(w, k, b);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreMouseService = void 0;
      const h = l(2585), f = l(8460), m = l(844), _ = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: (b) => b.button !== 4 && b.action === 1 && (b.ctrl = !1, b.alt = !1, b.shift = !1, !0) }, VT200: { events: 19, restrict: (b) => b.action !== 32 }, DRAG: { events: 23, restrict: (b) => b.action !== 32 || b.button !== 3 }, ANY: { events: 31, restrict: (b) => !0 } };
      function v(b, y) {
        let w = (b.ctrl ? 16 : 0) | (b.shift ? 4 : 0) | (b.alt ? 8 : 0);
        return b.button === 4 ? (w |= 64, w |= b.action) : (w |= 3 & b.button, 4 & b.button && (w |= 64), 8 & b.button && (w |= 128), b.action === 32 ? w |= 32 : b.action !== 0 || y || (w |= 3)), w;
      }
      const d = String.fromCharCode, p = { DEFAULT: (b) => {
        const y = [v(b, !1) + 32, b.col + 32, b.row + 32];
        return y[0] > 255 || y[1] > 255 || y[2] > 255 ? "" : `\x1B[M${d(y[0])}${d(y[1])}${d(y[2])}`;
      }, SGR: (b) => {
        const y = b.action === 0 && b.button !== 4 ? "m" : "M";
        return `\x1B[<${v(b, !0)};${b.col};${b.row}${y}`;
      }, SGR_PIXELS: (b) => {
        const y = b.action === 0 && b.button !== 4 ? "m" : "M";
        return `\x1B[<${v(b, !0)};${b.x};${b.y}${y}`;
      } };
      let g = a.CoreMouseService = class extends m.Disposable {
        constructor(b, y) {
          super(), this._bufferService = b, this._coreService = y, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new f.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
          for (const w of Object.keys(_)) this.addProtocol(w, _[w]);
          for (const w of Object.keys(p)) this.addEncoding(w, p[w]);
          this.reset();
        }
        addProtocol(b, y) {
          this._protocols[b] = y;
        }
        addEncoding(b, y) {
          this._encodings[b] = y;
        }
        get activeProtocol() {
          return this._activeProtocol;
        }
        get areMouseEventsActive() {
          return this._protocols[this._activeProtocol].events !== 0;
        }
        set activeProtocol(b) {
          if (!this._protocols[b]) throw new Error(`unknown protocol "${b}"`);
          this._activeProtocol = b, this._onProtocolChange.fire(this._protocols[b].events);
        }
        get activeEncoding() {
          return this._activeEncoding;
        }
        set activeEncoding(b) {
          if (!this._encodings[b]) throw new Error(`unknown encoding "${b}"`);
          this._activeEncoding = b;
        }
        reset() {
          this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
        }
        triggerMouseEvent(b) {
          if (b.col < 0 || b.col >= this._bufferService.cols || b.row < 0 || b.row >= this._bufferService.rows || b.button === 4 && b.action === 32 || b.button === 3 && b.action !== 32 || b.button !== 4 && (b.action === 2 || b.action === 3) || (b.col++, b.row++, b.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, b, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(b)) return !1;
          const y = this._encodings[this._activeEncoding](b);
          return y && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(y) : this._coreService.triggerDataEvent(y, !0)), this._lastEvent = b, !0;
        }
        explainEvents(b) {
          return { down: !!(1 & b), up: !!(2 & b), drag: !!(4 & b), move: !!(8 & b), wheel: !!(16 & b) };
        }
        _equalEvents(b, y, w) {
          if (w) {
            if (b.x !== y.x || b.y !== y.y) return !1;
          } else if (b.col !== y.col || b.row !== y.row) return !1;
          return b.button === y.button && b.action === y.action && b.ctrl === y.ctrl && b.alt === y.alt && b.shift === y.shift;
        }
      };
      a.CoreMouseService = g = c([u(0, h.IBufferService), u(1, h.ICoreService)], g);
    }, 6975: function(o, a, l) {
      var c = this && this.__decorate || function(g, b, y, w) {
        var k, C = arguments.length, x = C < 3 ? b : w === null ? w = Object.getOwnPropertyDescriptor(b, y) : w;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") x = Reflect.decorate(g, b, y, w);
        else for (var S = g.length - 1; S >= 0; S--) (k = g[S]) && (x = (C < 3 ? k(x) : C > 3 ? k(b, y, x) : k(b, y)) || x);
        return C > 3 && x && Object.defineProperty(b, y, x), x;
      }, u = this && this.__param || function(g, b) {
        return function(y, w) {
          b(y, w, g);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.CoreService = void 0;
      const h = l(1439), f = l(8460), m = l(844), _ = l(2585), v = Object.freeze({ insertMode: !1 }), d = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 });
      let p = a.CoreService = class extends m.Disposable {
        constructor(g, b, y) {
          super(), this._bufferService = g, this._logService = b, this._optionsService = y, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new f.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new f.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new f.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new f.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, h.clone)(v), this.decPrivateModes = (0, h.clone)(d);
        }
        reset() {
          this.modes = (0, h.clone)(v), this.decPrivateModes = (0, h.clone)(d);
        }
        triggerDataEvent(g, b = !1) {
          if (this._optionsService.rawOptions.disableStdin) return;
          const y = this._bufferService.buffer;
          b && this._optionsService.rawOptions.scrollOnUserInput && y.ybase !== y.ydisp && this._onRequestScrollToBottom.fire(), b && this._onUserInput.fire(), this._logService.debug(`sending data "${g}"`, () => g.split("").map((w) => w.charCodeAt(0))), this._onData.fire(g);
        }
        triggerBinaryEvent(g) {
          this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${g}"`, () => g.split("").map((b) => b.charCodeAt(0))), this._onBinary.fire(g));
        }
      };
      a.CoreService = p = c([u(0, _.IBufferService), u(1, _.ILogService), u(2, _.IOptionsService)], p);
    }, 9074: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.DecorationService = void 0;
      const c = l(8055), u = l(8460), h = l(844), f = l(6106);
      let m = 0, _ = 0;
      class v extends h.Disposable {
        get decorations() {
          return this._decorations.values();
        }
        constructor() {
          super(), this._decorations = new f.SortedList((g) => g == null ? void 0 : g.marker.line), this._onDecorationRegistered = this.register(new u.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new u.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, h.toDisposable)(() => this.reset()));
        }
        registerDecoration(g) {
          if (g.marker.isDisposed) return;
          const b = new d(g);
          if (b) {
            const y = b.marker.onDispose(() => b.dispose());
            b.onDispose(() => {
              b && (this._decorations.delete(b) && this._onDecorationRemoved.fire(b), y.dispose());
            }), this._decorations.insert(b), this._onDecorationRegistered.fire(b);
          }
          return b;
        }
        reset() {
          for (const g of this._decorations.values()) g.dispose();
          this._decorations.clear();
        }
        *getDecorationsAtCell(g, b, y) {
          var w, k, C;
          let x = 0, S = 0;
          for (const T of this._decorations.getKeyIterator(b)) x = (w = T.options.x) !== null && w !== void 0 ? w : 0, S = x + ((k = T.options.width) !== null && k !== void 0 ? k : 1), g >= x && g < S && (!y || ((C = T.options.layer) !== null && C !== void 0 ? C : "bottom") === y) && (yield T);
        }
        forEachDecorationAtCell(g, b, y, w) {
          this._decorations.forEachByKey(b, (k) => {
            var C, x, S;
            m = (C = k.options.x) !== null && C !== void 0 ? C : 0, _ = m + ((x = k.options.width) !== null && x !== void 0 ? x : 1), g >= m && g < _ && (!y || ((S = k.options.layer) !== null && S !== void 0 ? S : "bottom") === y) && w(k);
          });
        }
      }
      a.DecorationService = v;
      class d extends h.Disposable {
        get isDisposed() {
          return this._isDisposed;
        }
        get backgroundColorRGB() {
          return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = c.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
        }
        get foregroundColorRGB() {
          return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = c.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
        }
        constructor(g) {
          super(), this.options = g, this.onRenderEmitter = this.register(new u.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new u.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = g.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
        }
        dispose() {
          this._onDispose.fire(), super.dispose();
        }
      }
    }, 4348: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.InstantiationService = a.ServiceCollection = void 0;
      const c = l(2585), u = l(8343);
      class h {
        constructor(...m) {
          this._entries = /* @__PURE__ */ new Map();
          for (const [_, v] of m) this.set(_, v);
        }
        set(m, _) {
          const v = this._entries.get(m);
          return this._entries.set(m, _), v;
        }
        forEach(m) {
          for (const [_, v] of this._entries.entries()) m(_, v);
        }
        has(m) {
          return this._entries.has(m);
        }
        get(m) {
          return this._entries.get(m);
        }
      }
      a.ServiceCollection = h, a.InstantiationService = class {
        constructor() {
          this._services = new h(), this._services.set(c.IInstantiationService, this);
        }
        setService(f, m) {
          this._services.set(f, m);
        }
        getService(f) {
          return this._services.get(f);
        }
        createInstance(f, ...m) {
          const _ = (0, u.getServiceDependencies)(f).sort((p, g) => p.index - g.index), v = [];
          for (const p of _) {
            const g = this._services.get(p.id);
            if (!g) throw new Error(`[createInstance] ${f.name} depends on UNKNOWN service ${p.id}.`);
            v.push(g);
          }
          const d = _.length > 0 ? _[0].index : m.length;
          if (m.length !== d) throw new Error(`[createInstance] First service dependency of ${f.name} at position ${d + 1} conflicts with ${m.length} static arguments`);
          return new f(...m, ...v);
        }
      };
    }, 7866: function(o, a, l) {
      var c = this && this.__decorate || function(d, p, g, b) {
        var y, w = arguments.length, k = w < 3 ? p : b === null ? b = Object.getOwnPropertyDescriptor(p, g) : b;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") k = Reflect.decorate(d, p, g, b);
        else for (var C = d.length - 1; C >= 0; C--) (y = d[C]) && (k = (w < 3 ? y(k) : w > 3 ? y(p, g, k) : y(p, g)) || k);
        return w > 3 && k && Object.defineProperty(p, g, k), k;
      }, u = this && this.__param || function(d, p) {
        return function(g, b) {
          p(g, b, d);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.traceCall = a.setTraceLogger = a.LogService = void 0;
      const h = l(844), f = l(2585), m = { trace: f.LogLevelEnum.TRACE, debug: f.LogLevelEnum.DEBUG, info: f.LogLevelEnum.INFO, warn: f.LogLevelEnum.WARN, error: f.LogLevelEnum.ERROR, off: f.LogLevelEnum.OFF };
      let _, v = a.LogService = class extends h.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(d) {
          super(), this._optionsService = d, this._logLevel = f.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), _ = this;
        }
        _updateLogLevel() {
          this._logLevel = m[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(d) {
          for (let p = 0; p < d.length; p++) typeof d[p] == "function" && (d[p] = d[p]());
        }
        _log(d, p, g) {
          this._evalLazyOptionalParams(g), d.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + p, ...g);
        }
        trace(d, ...p) {
          var g, b;
          this._logLevel <= f.LogLevelEnum.TRACE && this._log((b = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.trace.bind(this._optionsService.options.logger)) !== null && b !== void 0 ? b : console.log, d, p);
        }
        debug(d, ...p) {
          var g, b;
          this._logLevel <= f.LogLevelEnum.DEBUG && this._log((b = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.debug.bind(this._optionsService.options.logger)) !== null && b !== void 0 ? b : console.log, d, p);
        }
        info(d, ...p) {
          var g, b;
          this._logLevel <= f.LogLevelEnum.INFO && this._log((b = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.info.bind(this._optionsService.options.logger)) !== null && b !== void 0 ? b : console.info, d, p);
        }
        warn(d, ...p) {
          var g, b;
          this._logLevel <= f.LogLevelEnum.WARN && this._log((b = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.warn.bind(this._optionsService.options.logger)) !== null && b !== void 0 ? b : console.warn, d, p);
        }
        error(d, ...p) {
          var g, b;
          this._logLevel <= f.LogLevelEnum.ERROR && this._log((b = (g = this._optionsService.options.logger) === null || g === void 0 ? void 0 : g.error.bind(this._optionsService.options.logger)) !== null && b !== void 0 ? b : console.error, d, p);
        }
      };
      a.LogService = v = c([u(0, f.IOptionsService)], v), a.setTraceLogger = function(d) {
        _ = d;
      }, a.traceCall = function(d, p, g) {
        if (typeof g.value != "function") throw new Error("not supported");
        const b = g.value;
        g.value = function(...y) {
          if (_.logLevel !== f.LogLevelEnum.TRACE) return b.apply(this, y);
          _.trace(`GlyphRenderer#${b.name}(${y.map((k) => JSON.stringify(k)).join(", ")})`);
          const w = b.apply(this, y);
          return _.trace(`GlyphRenderer#${b.name} return`, w), w;
        };
      };
    }, 7302: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OptionsService = a.DEFAULT_OPTIONS = void 0;
      const c = l(8460), u = l(844), h = l(6114);
      a.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: !0, drawBoldTextInBrightColors: !0, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: !1, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rightClickSelectsWord: h.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 };
      const f = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
      class m extends u.Disposable {
        constructor(v) {
          super(), this._onOptionChange = this.register(new c.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
          const d = Object.assign({}, a.DEFAULT_OPTIONS);
          for (const p in v) if (p in d) try {
            const g = v[p];
            d[p] = this._sanitizeAndValidateOption(p, g);
          } catch (g) {
            console.error(g);
          }
          this.rawOptions = d, this.options = Object.assign({}, d), this._setupOptions();
        }
        onSpecificOptionChange(v, d) {
          return this.onOptionChange((p) => {
            p === v && d(this.rawOptions[v]);
          });
        }
        onMultipleOptionChange(v, d) {
          return this.onOptionChange((p) => {
            v.indexOf(p) !== -1 && d();
          });
        }
        _setupOptions() {
          const v = (p) => {
            if (!(p in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${p}"`);
            return this.rawOptions[p];
          }, d = (p, g) => {
            if (!(p in a.DEFAULT_OPTIONS)) throw new Error(`No option with key "${p}"`);
            g = this._sanitizeAndValidateOption(p, g), this.rawOptions[p] !== g && (this.rawOptions[p] = g, this._onOptionChange.fire(p));
          };
          for (const p in this.rawOptions) {
            const g = { get: v.bind(this, p), set: d.bind(this, p) };
            Object.defineProperty(this.options, p, g);
          }
        }
        _sanitizeAndValidateOption(v, d) {
          switch (v) {
            case "cursorStyle":
              if (d || (d = a.DEFAULT_OPTIONS[v]), !/* @__PURE__ */ function(p) {
                return p === "block" || p === "underline" || p === "bar";
              }(d)) throw new Error(`"${d}" is not a valid value for ${v}`);
              break;
            case "wordSeparator":
              d || (d = a.DEFAULT_OPTIONS[v]);
              break;
            case "fontWeight":
            case "fontWeightBold":
              if (typeof d == "number" && 1 <= d && d <= 1e3) break;
              d = f.includes(d) ? d : a.DEFAULT_OPTIONS[v];
              break;
            case "cursorWidth":
              d = Math.floor(d);
            case "lineHeight":
            case "tabStopWidth":
              if (d < 1) throw new Error(`${v} cannot be less than 1, value: ${d}`);
              break;
            case "minimumContrastRatio":
              d = Math.max(1, Math.min(21, Math.round(10 * d) / 10));
              break;
            case "scrollback":
              if ((d = Math.min(d, 4294967295)) < 0) throw new Error(`${v} cannot be less than 0, value: ${d}`);
              break;
            case "fastScrollSensitivity":
            case "scrollSensitivity":
              if (d <= 0) throw new Error(`${v} cannot be less than or equal to 0, value: ${d}`);
              break;
            case "rows":
            case "cols":
              if (!d && d !== 0) throw new Error(`${v} must be numeric, value: ${d}`);
              break;
            case "windowsPty":
              d = d ?? {};
          }
          return d;
        }
      }
      a.OptionsService = m;
    }, 2660: function(o, a, l) {
      var c = this && this.__decorate || function(m, _, v, d) {
        var p, g = arguments.length, b = g < 3 ? _ : d === null ? d = Object.getOwnPropertyDescriptor(_, v) : d;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") b = Reflect.decorate(m, _, v, d);
        else for (var y = m.length - 1; y >= 0; y--) (p = m[y]) && (b = (g < 3 ? p(b) : g > 3 ? p(_, v, b) : p(_, v)) || b);
        return g > 3 && b && Object.defineProperty(_, v, b), b;
      }, u = this && this.__param || function(m, _) {
        return function(v, d) {
          _(v, d, m);
        };
      };
      Object.defineProperty(a, "__esModule", { value: !0 }), a.OscLinkService = void 0;
      const h = l(2585);
      let f = a.OscLinkService = class {
        constructor(m) {
          this._bufferService = m, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
        }
        registerLink(m) {
          const _ = this._bufferService.buffer;
          if (m.id === void 0) {
            const y = _.addMarker(_.ybase + _.y), w = { data: m, id: this._nextId++, lines: [y] };
            return y.onDispose(() => this._removeMarkerFromLink(w, y)), this._dataByLinkId.set(w.id, w), w.id;
          }
          const v = m, d = this._getEntryIdKey(v), p = this._entriesWithId.get(d);
          if (p) return this.addLineToLink(p.id, _.ybase + _.y), p.id;
          const g = _.addMarker(_.ybase + _.y), b = { id: this._nextId++, key: this._getEntryIdKey(v), data: v, lines: [g] };
          return g.onDispose(() => this._removeMarkerFromLink(b, g)), this._entriesWithId.set(b.key, b), this._dataByLinkId.set(b.id, b), b.id;
        }
        addLineToLink(m, _) {
          const v = this._dataByLinkId.get(m);
          if (v && v.lines.every((d) => d.line !== _)) {
            const d = this._bufferService.buffer.addMarker(_);
            v.lines.push(d), d.onDispose(() => this._removeMarkerFromLink(v, d));
          }
        }
        getLinkData(m) {
          var _;
          return (_ = this._dataByLinkId.get(m)) === null || _ === void 0 ? void 0 : _.data;
        }
        _getEntryIdKey(m) {
          return `${m.id};;${m.uri}`;
        }
        _removeMarkerFromLink(m, _) {
          const v = m.lines.indexOf(_);
          v !== -1 && (m.lines.splice(v, 1), m.lines.length === 0 && (m.data.id !== void 0 && this._entriesWithId.delete(m.key), this._dataByLinkId.delete(m.id)));
        }
      };
      a.OscLinkService = f = c([u(0, h.IBufferService)], f);
    }, 8343: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.createDecorator = a.getServiceDependencies = a.serviceRegistry = void 0;
      const l = "di$target", c = "di$dependencies";
      a.serviceRegistry = /* @__PURE__ */ new Map(), a.getServiceDependencies = function(u) {
        return u[c] || [];
      }, a.createDecorator = function(u) {
        if (a.serviceRegistry.has(u)) return a.serviceRegistry.get(u);
        const h = function(f, m, _) {
          if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          (function(v, d, p) {
            d[l] === d ? d[c].push({ id: v, index: p }) : (d[c] = [{ id: v, index: p }], d[l] = d);
          })(h, f, _);
        };
        return h.toString = () => u, a.serviceRegistry.set(u, h), h;
      };
    }, 2585: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.IDecorationService = a.IUnicodeService = a.IOscLinkService = a.IOptionsService = a.ILogService = a.LogLevelEnum = a.IInstantiationService = a.ICharsetService = a.ICoreService = a.ICoreMouseService = a.IBufferService = void 0;
      const c = l(8343);
      var u;
      a.IBufferService = (0, c.createDecorator)("BufferService"), a.ICoreMouseService = (0, c.createDecorator)("CoreMouseService"), a.ICoreService = (0, c.createDecorator)("CoreService"), a.ICharsetService = (0, c.createDecorator)("CharsetService"), a.IInstantiationService = (0, c.createDecorator)("InstantiationService"), function(h) {
        h[h.TRACE = 0] = "TRACE", h[h.DEBUG = 1] = "DEBUG", h[h.INFO = 2] = "INFO", h[h.WARN = 3] = "WARN", h[h.ERROR = 4] = "ERROR", h[h.OFF = 5] = "OFF";
      }(u || (a.LogLevelEnum = u = {})), a.ILogService = (0, c.createDecorator)("LogService"), a.IOptionsService = (0, c.createDecorator)("OptionsService"), a.IOscLinkService = (0, c.createDecorator)("OscLinkService"), a.IUnicodeService = (0, c.createDecorator)("UnicodeService"), a.IDecorationService = (0, c.createDecorator)("DecorationService");
    }, 1480: (o, a, l) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.UnicodeService = void 0;
      const c = l(8460), u = l(225);
      a.UnicodeService = class {
        constructor() {
          this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new c.EventEmitter(), this.onChange = this._onChange.event;
          const h = new u.UnicodeV6();
          this.register(h), this._active = h.version, this._activeProvider = h;
        }
        dispose() {
          this._onChange.dispose();
        }
        get versions() {
          return Object.keys(this._providers);
        }
        get activeVersion() {
          return this._active;
        }
        set activeVersion(h) {
          if (!this._providers[h]) throw new Error(`unknown Unicode version "${h}"`);
          this._active = h, this._activeProvider = this._providers[h], this._onChange.fire(h);
        }
        register(h) {
          this._providers[h.version] = h;
        }
        wcwidth(h) {
          return this._activeProvider.wcwidth(h);
        }
        getStringCellWidth(h) {
          let f = 0;
          const m = h.length;
          for (let _ = 0; _ < m; ++_) {
            let v = h.charCodeAt(_);
            if (55296 <= v && v <= 56319) {
              if (++_ >= m) return f + this.wcwidth(v);
              const d = h.charCodeAt(_);
              56320 <= d && d <= 57343 ? v = 1024 * (v - 55296) + d - 56320 + 65536 : f += this.wcwidth(d);
            }
            f += this.wcwidth(v);
          }
          return f;
        }
      };
    } }, i = {};
    function r(o) {
      var a = i[o];
      if (a !== void 0) return a.exports;
      var l = i[o] = { exports: {} };
      return t[o].call(l.exports, l, l.exports, r), l.exports;
    }
    var n = {};
    return (() => {
      var o = n;
      Object.defineProperty(o, "__esModule", { value: !0 }), o.Terminal = void 0;
      const a = r(9042), l = r(3236), c = r(844), u = r(5741), h = r(8285), f = r(7975), m = r(7090), _ = ["cols", "rows"];
      class v extends c.Disposable {
        constructor(p) {
          super(), this._core = this.register(new l.Terminal(p)), this._addonManager = this.register(new u.AddonManager()), this._publicOptions = Object.assign({}, this._core.options);
          const g = (y) => this._core.options[y], b = (y, w) => {
            this._checkReadonlyOptions(y), this._core.options[y] = w;
          };
          for (const y in this._core.options) {
            const w = { get: g.bind(this, y), set: b.bind(this, y) };
            Object.defineProperty(this._publicOptions, y, w);
          }
        }
        _checkReadonlyOptions(p) {
          if (_.includes(p)) throw new Error(`Option "${p}" can only be set in the constructor`);
        }
        _checkProposedApi() {
          if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
        }
        get onBell() {
          return this._core.onBell;
        }
        get onBinary() {
          return this._core.onBinary;
        }
        get onCursorMove() {
          return this._core.onCursorMove;
        }
        get onData() {
          return this._core.onData;
        }
        get onKey() {
          return this._core.onKey;
        }
        get onLineFeed() {
          return this._core.onLineFeed;
        }
        get onRender() {
          return this._core.onRender;
        }
        get onResize() {
          return this._core.onResize;
        }
        get onScroll() {
          return this._core.onScroll;
        }
        get onSelectionChange() {
          return this._core.onSelectionChange;
        }
        get onTitleChange() {
          return this._core.onTitleChange;
        }
        get onWriteParsed() {
          return this._core.onWriteParsed;
        }
        get element() {
          return this._core.element;
        }
        get parser() {
          return this._parser || (this._parser = new f.ParserApi(this._core)), this._parser;
        }
        get unicode() {
          return this._checkProposedApi(), new m.UnicodeApi(this._core);
        }
        get textarea() {
          return this._core.textarea;
        }
        get rows() {
          return this._core.rows;
        }
        get cols() {
          return this._core.cols;
        }
        get buffer() {
          return this._buffer || (this._buffer = this.register(new h.BufferNamespaceApi(this._core))), this._buffer;
        }
        get markers() {
          return this._checkProposedApi(), this._core.markers;
        }
        get modes() {
          const p = this._core.coreService.decPrivateModes;
          let g = "none";
          switch (this._core.coreMouseService.activeProtocol) {
            case "X10":
              g = "x10";
              break;
            case "VT200":
              g = "vt200";
              break;
            case "DRAG":
              g = "drag";
              break;
            case "ANY":
              g = "any";
          }
          return { applicationCursorKeysMode: p.applicationCursorKeys, applicationKeypadMode: p.applicationKeypad, bracketedPasteMode: p.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: g, originMode: p.origin, reverseWraparoundMode: p.reverseWraparound, sendFocusMode: p.sendFocus, wraparoundMode: p.wraparound };
        }
        get options() {
          return this._publicOptions;
        }
        set options(p) {
          for (const g in p) this._publicOptions[g] = p[g];
        }
        blur() {
          this._core.blur();
        }
        focus() {
          this._core.focus();
        }
        resize(p, g) {
          this._verifyIntegers(p, g), this._core.resize(p, g);
        }
        open(p) {
          this._core.open(p);
        }
        attachCustomKeyEventHandler(p) {
          this._core.attachCustomKeyEventHandler(p);
        }
        registerLinkProvider(p) {
          return this._core.registerLinkProvider(p);
        }
        registerCharacterJoiner(p) {
          return this._checkProposedApi(), this._core.registerCharacterJoiner(p);
        }
        deregisterCharacterJoiner(p) {
          this._checkProposedApi(), this._core.deregisterCharacterJoiner(p);
        }
        registerMarker(p = 0) {
          return this._verifyIntegers(p), this._core.registerMarker(p);
        }
        registerDecoration(p) {
          var g, b, y;
          return this._checkProposedApi(), this._verifyPositiveIntegers((g = p.x) !== null && g !== void 0 ? g : 0, (b = p.width) !== null && b !== void 0 ? b : 0, (y = p.height) !== null && y !== void 0 ? y : 0), this._core.registerDecoration(p);
        }
        hasSelection() {
          return this._core.hasSelection();
        }
        select(p, g, b) {
          this._verifyIntegers(p, g, b), this._core.select(p, g, b);
        }
        getSelection() {
          return this._core.getSelection();
        }
        getSelectionPosition() {
          return this._core.getSelectionPosition();
        }
        clearSelection() {
          this._core.clearSelection();
        }
        selectAll() {
          this._core.selectAll();
        }
        selectLines(p, g) {
          this._verifyIntegers(p, g), this._core.selectLines(p, g);
        }
        dispose() {
          super.dispose();
        }
        scrollLines(p) {
          this._verifyIntegers(p), this._core.scrollLines(p);
        }
        scrollPages(p) {
          this._verifyIntegers(p), this._core.scrollPages(p);
        }
        scrollToTop() {
          this._core.scrollToTop();
        }
        scrollToBottom() {
          this._core.scrollToBottom();
        }
        scrollToLine(p) {
          this._verifyIntegers(p), this._core.scrollToLine(p);
        }
        clear() {
          this._core.clear();
        }
        write(p, g) {
          this._core.write(p, g);
        }
        writeln(p, g) {
          this._core.write(p), this._core.write(`\r
`, g);
        }
        paste(p) {
          this._core.paste(p);
        }
        refresh(p, g) {
          this._verifyIntegers(p, g), this._core.refresh(p, g);
        }
        reset() {
          this._core.reset();
        }
        clearTextureAtlas() {
          this._core.clearTextureAtlas();
        }
        loadAddon(p) {
          this._addonManager.loadAddon(this, p);
        }
        static get strings() {
          return a;
        }
        _verifyIntegers(...p) {
          for (const g of p) if (g === 1 / 0 || isNaN(g) || g % 1 != 0) throw new Error("This API only accepts integers");
        }
        _verifyPositiveIntegers(...p) {
          for (const g of p) if (g && (g === 1 / 0 || isNaN(g) || g % 1 != 0 || g < 0)) throw new Error("This API only accepts positive integers");
        }
      }
      o.Terminal = v;
    })(), n;
  })());
})(Uh);
var Rb = Uh.exports, Vh = { exports: {} };
(function(s, e) {
  (function(t, i) {
    s.exports = i();
  })(self, () => (() => {
    var t = {};
    return (() => {
      var i = t;
      Object.defineProperty(i, "__esModule", { value: !0 }), i.FitAddon = void 0, i.FitAddon = class {
        activate(r) {
          this._terminal = r;
        }
        dispose() {
        }
        fit() {
          const r = this.proposeDimensions();
          if (!r || !this._terminal || isNaN(r.cols) || isNaN(r.rows)) return;
          const n = this._terminal._core;
          this._terminal.rows === r.rows && this._terminal.cols === r.cols || (n._renderService.clear(), this._terminal.resize(r.cols, r.rows));
        }
        proposeDimensions() {
          if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement) return;
          const r = this._terminal._core, n = r._renderService.dimensions;
          if (n.css.cell.width === 0 || n.css.cell.height === 0) return;
          const o = this._terminal.options.scrollback === 0 ? 0 : r.viewport.scrollBarWidth, a = window.getComputedStyle(this._terminal.element.parentElement), l = parseInt(a.getPropertyValue("height")), c = Math.max(0, parseInt(a.getPropertyValue("width"))), u = window.getComputedStyle(this._terminal.element), h = l - (parseInt(u.getPropertyValue("padding-top")) + parseInt(u.getPropertyValue("padding-bottom"))), f = c - (parseInt(u.getPropertyValue("padding-right")) + parseInt(u.getPropertyValue("padding-left"))) - o;
          return { cols: Math.max(2, Math.floor(f / n.css.cell.width)), rows: Math.max(1, Math.floor(h / n.css.cell.height)) };
        }
      };
    })(), t;
  })());
})(Vh);
var Ob = Vh.exports, qh = { exports: {} };
(function(s, e) {
  (function(t, i) {
    s.exports = i();
  })(self, () => (() => {
    var t = { 6: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.LinkComputer = a.WebLinkProvider = void 0, a.WebLinkProvider = class {
        constructor(c, u, h, f = {}) {
          this._terminal = c, this._regex = u, this._handler = h, this._options = f;
        }
        provideLinks(c, u) {
          const h = l.computeLink(c, this._regex, this._terminal, this._handler);
          u(this._addCallbacks(h));
        }
        _addCallbacks(c) {
          return c.map((u) => (u.leave = this._options.leave, u.hover = (h, f) => {
            if (this._options.hover) {
              const { range: m } = u;
              this._options.hover(h, f, m);
            }
          }, u));
        }
      };
      class l {
        static computeLink(u, h, f, m) {
          const _ = new RegExp(h.source, (h.flags || "") + "g"), [v, d] = l._getWindowedLineStrings(u - 1, f), p = v.join("");
          let g;
          const b = [];
          for (; g = _.exec(p); ) {
            const y = g[0];
            try {
              const T = new URL(y), M = decodeURI(T.toString());
              if (y !== M && y + "/" !== M) continue;
            } catch {
              continue;
            }
            const [w, k] = l._mapStrIdx(f, d, 0, g.index), [C, x] = l._mapStrIdx(f, w, k, y.length);
            if (w === -1 || k === -1 || C === -1 || x === -1) continue;
            const S = { start: { x: k + 1, y: w + 1 }, end: { x, y: C + 1 } };
            b.push({ range: S, text: y, activate: m });
          }
          return b;
        }
        static _getWindowedLineStrings(u, h) {
          let f, m = u, _ = u, v = 0, d = "";
          const p = [];
          if (f = h.buffer.active.getLine(u)) {
            const g = f.translateToString(!0);
            if (f.isWrapped && g[0] !== " ") {
              for (v = 0; (f = h.buffer.active.getLine(--m)) && v < 2048 && (d = f.translateToString(!0), v += d.length, p.push(d), f.isWrapped && d.indexOf(" ") === -1); ) ;
              p.reverse();
            }
            for (p.push(g), v = 0; (f = h.buffer.active.getLine(++_)) && f.isWrapped && v < 2048 && (d = f.translateToString(!0), v += d.length, p.push(d), d.indexOf(" ") === -1); ) ;
          }
          return [p, m];
        }
        static _mapStrIdx(u, h, f, m) {
          const _ = u.buffer.active, v = _.getNullCell();
          let d = f;
          for (; m; ) {
            const p = _.getLine(h);
            if (!p) return [-1, -1];
            for (let g = d; g < p.length; ++g) {
              p.getCell(g, v);
              const b = v.getChars();
              if (v.getWidth() && (m -= b.length || 1, g === p.length - 1 && b === "")) {
                const y = _.getLine(h + 1);
                y && y.isWrapped && (y.getCell(0, v), v.getWidth() === 2 && (m += 1));
              }
              if (m < 0) return [h, g];
            }
            h++, d = 0;
          }
          return [h, d];
        }
      }
      a.LinkComputer = l;
    } }, i = {};
    function r(o) {
      var a = i[o];
      if (a !== void 0) return a.exports;
      var l = i[o] = { exports: {} };
      return t[o](l, l.exports, r), l.exports;
    }
    var n = {};
    return (() => {
      var o = n;
      Object.defineProperty(o, "__esModule", { value: !0 }), o.WebLinksAddon = void 0;
      const a = r(6), l = /https?:[/]{2}[^\s"'!*(){}|\\\^<>`]*[^\s"':,.!?{}|\\\^~\[\]`()<>]/;
      function c(u, h) {
        const f = window.open();
        if (f) {
          try {
            f.opener = null;
          } catch {
          }
          f.location.href = h;
        } else console.warn("Opening link blocked as opener could not be cleared");
      }
      o.WebLinksAddon = class {
        constructor(u = c, h = {}) {
          this._handler = u, this._options = h;
        }
        activate(u) {
          this._terminal = u;
          const h = this._options, f = h.urlRegex || l;
          this._linkProvider = this._terminal.registerLinkProvider(new a.WebLinkProvider(this._terminal, f, this._handler, h));
        }
        dispose() {
          var u;
          (u = this._linkProvider) === null || u === void 0 || u.dispose();
        }
      };
    })(), n;
  })());
})(qh);
var Pb = qh.exports, Kh = { exports: {} };
(function(s, e) {
  (function(t, i) {
    s.exports = i();
  })(self, () => (() => {
    var t = { 345: (o, a) => {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.forwardEvent = a.EventEmitter = void 0, a.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = !1;
        }
        get event() {
          return this._event || (this._event = (l) => (this._listeners.push(l), { dispose: () => {
            if (!this._disposed) {
              for (let c = 0; c < this._listeners.length; c++) if (this._listeners[c] === l) return void this._listeners.splice(c, 1);
            }
          } })), this._event;
        }
        fire(l, c) {
          const u = [];
          for (let h = 0; h < this._listeners.length; h++) u.push(this._listeners[h]);
          for (let h = 0; h < u.length; h++) u[h].call(void 0, l, c);
        }
        dispose() {
          this.clearListeners(), this._disposed = !0;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, a.forwardEvent = function(l, c) {
        return l((u) => c.fire(u));
      };
    }, 859: (o, a) => {
      function l(c) {
        for (const u of c) u.dispose();
        c.length = 0;
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), a.getDisposeArrayDisposable = a.disposeArray = a.toDisposable = a.MutableDisposable = a.Disposable = void 0, a.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = !1;
        }
        dispose() {
          this._isDisposed = !0;
          for (const c of this._disposables) c.dispose();
          this._disposables.length = 0;
        }
        register(c) {
          return this._disposables.push(c), c;
        }
        unregister(c) {
          const u = this._disposables.indexOf(c);
          u !== -1 && this._disposables.splice(u, 1);
        }
      }, a.MutableDisposable = class {
        constructor() {
          this._isDisposed = !1;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(c) {
          var u;
          this._isDisposed || c === this._value || ((u = this._value) === null || u === void 0 || u.dispose(), this._value = c);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          var c;
          this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0;
        }
      }, a.toDisposable = function(c) {
        return { dispose: c };
      }, a.disposeArray = l, a.getDisposeArrayDisposable = function(c) {
        return { dispose: () => l(c) };
      };
    } }, i = {};
    function r(o) {
      var a = i[o];
      if (a !== void 0) return a.exports;
      var l = i[o] = { exports: {} };
      return t[o](l, l.exports, r), l.exports;
    }
    var n = {};
    return (() => {
      var o = n;
      Object.defineProperty(o, "__esModule", { value: !0 }), o.SearchAddon = void 0;
      const a = r(345), l = r(859), c = " ~!@#$%^&*()+`-=[]{}|\\;:\"',./<>?";
      class u extends l.Disposable {
        constructor(f) {
          var m;
          super(), this._highlightedLines = /* @__PURE__ */ new Set(), this._highlightDecorations = [], this._selectedDecoration = this.register(new l.MutableDisposable()), this._linesCacheTimeoutId = 0, this._onDidChangeResults = this.register(new a.EventEmitter()), this.onDidChangeResults = this._onDidChangeResults.event, this._highlightLimit = (m = f == null ? void 0 : f.highlightLimit) !== null && m !== void 0 ? m : 1e3;
        }
        activate(f) {
          this._terminal = f, this.register(this._terminal.onWriteParsed(() => this._updateMatches())), this.register(this._terminal.onResize(() => this._updateMatches())), this.register((0, l.toDisposable)(() => this.clearDecorations()));
        }
        _updateMatches() {
          var f;
          this._highlightTimeout && window.clearTimeout(this._highlightTimeout), this._cachedSearchTerm && (!((f = this._lastSearchOptions) === null || f === void 0) && f.decorations) && (this._highlightTimeout = setTimeout(() => {
            const m = this._cachedSearchTerm;
            this._cachedSearchTerm = void 0, this.findPrevious(m, Object.assign(Object.assign({}, this._lastSearchOptions), { incremental: !0, noScroll: !0 }));
          }, 200));
        }
        clearDecorations(f) {
          this._selectedDecoration.clear(), (0, l.disposeArray)(this._highlightDecorations), this._highlightDecorations = [], this._highlightedLines.clear(), f || (this._cachedSearchTerm = void 0);
        }
        findNext(f, m) {
          if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
          this._lastSearchOptions = m, m != null && m.decorations && (this._cachedSearchTerm !== void 0 && f === this._cachedSearchTerm || this._highlightAllMatches(f, m));
          const _ = this._findNextAndSelect(f, m);
          return this._fireResults(m), this._cachedSearchTerm = f, _;
        }
        _highlightAllMatches(f, m) {
          if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
          if (!f || f.length === 0) return void this.clearDecorations();
          m = m || {}, this.clearDecorations(!0);
          const _ = [];
          let v, d = this._find(f, 0, 0, m);
          for (; d && ((v == null ? void 0 : v.row) !== d.row || (v == null ? void 0 : v.col) !== d.col) && !(_.length >= this._highlightLimit); ) v = d, _.push(v), d = this._find(f, v.col + v.term.length >= this._terminal.cols ? v.row + 1 : v.row, v.col + v.term.length >= this._terminal.cols ? 0 : v.col + 1, m);
          for (const p of _) {
            const g = this._createResultDecoration(p, m.decorations);
            g && (this._highlightedLines.add(g.marker.line), this._highlightDecorations.push({ decoration: g, match: p, dispose() {
              g.dispose();
            } }));
          }
        }
        _find(f, m, _, v) {
          var d;
          if (!this._terminal || !f || f.length === 0) return (d = this._terminal) === null || d === void 0 || d.clearSelection(), void this.clearDecorations();
          if (_ > this._terminal.cols) throw new Error(`Invalid col: ${_} to search in terminal of ${this._terminal.cols} cols`);
          let p;
          this._initLinesCache();
          const g = { startRow: m, startCol: _ };
          if (p = this._findInLine(f, g, v), !p) for (let b = m + 1; b < this._terminal.buffer.active.baseY + this._terminal.rows && (g.startRow = b, g.startCol = 0, p = this._findInLine(f, g, v), !p); b++) ;
          return p;
        }
        _findNextAndSelect(f, m) {
          var _;
          if (!this._terminal || !f || f.length === 0) return (_ = this._terminal) === null || _ === void 0 || _.clearSelection(), this.clearDecorations(), !1;
          const v = this._terminal.getSelectionPosition();
          this._terminal.clearSelection();
          let d = 0, p = 0;
          v && (this._cachedSearchTerm === f ? (d = v.end.x, p = v.end.y) : (d = v.start.x, p = v.start.y)), this._initLinesCache();
          const g = { startRow: p, startCol: d };
          let b = this._findInLine(f, g, m);
          if (!b) for (let y = p + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows && (g.startRow = y, g.startCol = 0, b = this._findInLine(f, g, m), !b); y++) ;
          if (!b && p !== 0) for (let y = 0; y < p && (g.startRow = y, g.startCol = 0, b = this._findInLine(f, g, m), !b); y++) ;
          return !b && v && (g.startRow = v.start.y, g.startCol = 0, b = this._findInLine(f, g, m)), this._selectResult(b, m == null ? void 0 : m.decorations, m == null ? void 0 : m.noScroll);
        }
        findPrevious(f, m) {
          if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
          this._lastSearchOptions = m, m != null && m.decorations && (this._cachedSearchTerm !== void 0 && f === this._cachedSearchTerm || this._highlightAllMatches(f, m));
          const _ = this._findPreviousAndSelect(f, m);
          return this._fireResults(m), this._cachedSearchTerm = f, _;
        }
        _fireResults(f) {
          if (f != null && f.decorations) {
            let m = -1;
            if (this._selectedDecoration.value) {
              const _ = this._selectedDecoration.value.match;
              for (let v = 0; v < this._highlightDecorations.length; v++) {
                const d = this._highlightDecorations[v].match;
                if (d.row === _.row && d.col === _.col && d.size === _.size) {
                  m = v;
                  break;
                }
              }
            }
            this._onDidChangeResults.fire({ resultIndex: m, resultCount: this._highlightDecorations.length });
          }
        }
        _findPreviousAndSelect(f, m) {
          var _;
          if (!this._terminal) throw new Error("Cannot use addon until it has been loaded");
          if (!this._terminal || !f || f.length === 0) return (_ = this._terminal) === null || _ === void 0 || _.clearSelection(), this.clearDecorations(), !1;
          const v = this._terminal.getSelectionPosition();
          this._terminal.clearSelection();
          let d = this._terminal.buffer.active.baseY + this._terminal.rows - 1, p = this._terminal.cols;
          const g = !0;
          this._initLinesCache();
          const b = { startRow: d, startCol: p };
          let y;
          if (v && (b.startRow = d = v.start.y, b.startCol = p = v.start.x, this._cachedSearchTerm !== f && (y = this._findInLine(f, b, m, !1), y || (b.startRow = d = v.end.y, b.startCol = p = v.end.x))), y || (y = this._findInLine(f, b, m, g)), !y) {
            b.startCol = Math.max(b.startCol, this._terminal.cols);
            for (let w = d - 1; w >= 0 && (b.startRow = w, y = this._findInLine(f, b, m, g), !y); w--) ;
          }
          if (!y && d !== this._terminal.buffer.active.baseY + this._terminal.rows - 1) for (let w = this._terminal.buffer.active.baseY + this._terminal.rows - 1; w >= d && (b.startRow = w, y = this._findInLine(f, b, m, g), !y); w--) ;
          return this._selectResult(y, m == null ? void 0 : m.decorations, m == null ? void 0 : m.noScroll);
        }
        _initLinesCache() {
          const f = this._terminal;
          this._linesCache || (this._linesCache = new Array(f.buffer.active.length), this._cursorMoveListener = f.onCursorMove(() => this._destroyLinesCache()), this._resizeListener = f.onResize(() => this._destroyLinesCache())), window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), 15e3);
        }
        _destroyLinesCache() {
          this._linesCache = void 0, this._cursorMoveListener && (this._cursorMoveListener.dispose(), this._cursorMoveListener = void 0), this._resizeListener && (this._resizeListener.dispose(), this._resizeListener = void 0), this._linesCacheTimeoutId && (window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = 0);
        }
        _isWholeWord(f, m, _) {
          return (f === 0 || c.includes(m[f - 1])) && (f + _.length === m.length || c.includes(m[f + _.length]));
        }
        _findInLine(f, m, _ = {}, v = !1) {
          var d;
          const p = this._terminal, g = m.startRow, b = m.startCol, y = p.buffer.active.getLine(g);
          if (y != null && y.isWrapped) return v ? void (m.startCol += p.cols) : (m.startRow--, m.startCol += p.cols, this._findInLine(f, m, _));
          let w = (d = this._linesCache) === null || d === void 0 ? void 0 : d[g];
          w || (w = this._translateBufferLineToStringWithWrap(g, !0), this._linesCache && (this._linesCache[g] = w));
          const [k, C] = w, x = this._bufferColsToStringOffset(g, b), S = _.caseSensitive ? f : f.toLowerCase(), T = _.caseSensitive ? k : k.toLowerCase();
          let M = -1;
          if (_.regex) {
            const E = RegExp(S, "g");
            let R;
            if (v) for (; R = E.exec(T.slice(0, x)); ) M = E.lastIndex - R[0].length, f = R[0], E.lastIndex -= f.length - 1;
            else R = E.exec(T.slice(x)), R && R[0].length > 0 && (M = x + (E.lastIndex - R[0].length), f = R[0]);
          } else v ? x - S.length >= 0 && (M = T.lastIndexOf(S, x - S.length)) : M = T.indexOf(S, x);
          if (M >= 0) {
            if (_.wholeWord && !this._isWholeWord(M, T, f)) return;
            let E = 0;
            for (; E < C.length - 1 && M >= C[E + 1]; ) E++;
            let R = E;
            for (; R < C.length - 1 && M + f.length >= C[R + 1]; ) R++;
            const z = M - C[E], F = M + f.length - C[R], j = this._stringLengthToBufferSize(g + E, z);
            return { term: f, col: j, row: g + E, size: this._stringLengthToBufferSize(g + R, F) - j + p.cols * (R - E) };
          }
        }
        _stringLengthToBufferSize(f, m) {
          const _ = this._terminal.buffer.active.getLine(f);
          if (!_) return 0;
          for (let v = 0; v < m; v++) {
            const d = _.getCell(v);
            if (!d) break;
            const p = d.getChars();
            p.length > 1 && (m -= p.length - 1);
            const g = _.getCell(v + 1);
            g && g.getWidth() === 0 && m++;
          }
          return m;
        }
        _bufferColsToStringOffset(f, m) {
          const _ = this._terminal;
          let v = f, d = 0, p = _.buffer.active.getLine(v);
          for (; m > 0 && p; ) {
            for (let g = 0; g < m && g < _.cols; g++) {
              const b = p.getCell(g);
              if (!b) break;
              b.getWidth() && (d += b.getCode() === 0 ? 1 : b.getChars().length);
            }
            if (v++, p = _.buffer.active.getLine(v), p && !p.isWrapped) break;
            m -= _.cols;
          }
          return d;
        }
        _translateBufferLineToStringWithWrap(f, m) {
          var _;
          const v = this._terminal, d = [], p = [0];
          let g = v.buffer.active.getLine(f);
          for (; g; ) {
            const b = v.buffer.active.getLine(f + 1), y = !!b && b.isWrapped;
            let w = g.translateToString(!y && m);
            if (y && b) {
              const k = g.getCell(g.length - 1);
              k && k.getCode() === 0 && k.getWidth() === 1 && ((_ = b.getCell(0)) === null || _ === void 0 ? void 0 : _.getWidth()) === 2 && (w = w.slice(0, -1));
            }
            if (d.push(w), !y) break;
            p.push(p[p.length - 1] + w.length), f++, g = b;
          }
          return [d.join(""), p];
        }
        _selectResult(f, m, _) {
          const v = this._terminal;
          if (this._selectedDecoration.clear(), !f) return v.clearSelection(), !1;
          if (v.select(f.col, f.row, f.size), m) {
            const d = v.registerMarker(-v.buffer.active.baseY - v.buffer.active.cursorY + f.row);
            if (d) {
              const p = v.registerDecoration({ marker: d, x: f.col, width: f.size, backgroundColor: m.activeMatchBackground, layer: "top", overviewRulerOptions: { color: m.activeMatchColorOverviewRuler } });
              if (p) {
                const g = [];
                g.push(d), g.push(p.onRender((b) => this._applyStyles(b, m.activeMatchBorder, !0))), g.push(p.onDispose(() => (0, l.disposeArray)(g))), this._selectedDecoration.value = { decoration: p, match: f, dispose() {
                  p.dispose();
                } };
              }
            }
          }
          if (!_ && (f.row >= v.buffer.active.viewportY + v.rows || f.row < v.buffer.active.viewportY)) {
            let d = f.row - v.buffer.active.viewportY;
            d -= Math.floor(v.rows / 2), v.scrollLines(d);
          }
          return !0;
        }
        _applyStyles(f, m, _) {
          f.classList.contains("xterm-find-result-decoration") || (f.classList.add("xterm-find-result-decoration"), m && (f.style.outline = `1px solid ${m}`)), _ && f.classList.add("xterm-find-active-result-decoration");
        }
        _createResultDecoration(f, m) {
          const _ = this._terminal, v = _.registerMarker(-_.buffer.active.baseY - _.buffer.active.cursorY + f.row);
          if (!v) return;
          const d = _.registerDecoration({ marker: v, x: f.col, width: f.size, backgroundColor: m.matchBackground, overviewRulerOptions: this._highlightedLines.has(v.line) ? void 0 : { color: m.matchOverviewRuler, position: "center" } });
          if (d) {
            const p = [];
            p.push(v), p.push(d.onRender((g) => this._applyStyles(g, m.matchBorder, !1))), p.push(d.onDispose(() => (0, l.disposeArray)(p)));
          }
          return d;
        }
      }
      o.SearchAddon = u;
    })(), n;
  })());
})(Kh);
var Bb = Kh.exports;
const Nb = `/**
 * Copyright (c) 2014 The xterm.js authors. All rights reserved.
 * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)
 * https://github.com/chjj/term.js
 * @license MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Originally forked from (with the author's permission):
 *   Fabrice Bellard's javascript vt100 for jslinux:
 *   http://bellard.org/jslinux/
 *   Copyright (c) 2011 Fabrice Bellard
 *   The original design remains. The terminal itself
 *   has been extended to include xterm CSI codes, among
 *   other features.
 */.xterm{cursor:text;position:relative;-moz-user-select:none;user-select:none;-ms-user-select:none;-webkit-user-select:none}.xterm.focus,.xterm:focus{outline:none}.xterm .xterm-helpers{position:absolute;top:0;z-index:5}.xterm .xterm-helper-textarea{padding:0;border:0;margin:0;position:absolute;opacity:0;left:-9999em;top:0;width:0;height:0;z-index:-5;white-space:nowrap;overflow:hidden;resize:none}.xterm .composition-view{background:#000;color:#fff;display:none;position:absolute;white-space:nowrap;z-index:1}.xterm .composition-view.active{display:block}.xterm .xterm-viewport{background-color:#000;overflow-y:scroll;cursor:default;position:absolute;right:0;left:0;top:0;bottom:0}.xterm .xterm-screen{position:relative}.xterm .xterm-screen canvas{position:absolute;left:0;top:0}.xterm .xterm-scroll-area{visibility:hidden}.xterm-char-measure-element{display:inline-block;visibility:hidden;position:absolute;top:0;left:-9999em;line-height:normal}.xterm.enable-mouse-events{cursor:default}.xterm.xterm-cursor-pointer,.xterm .xterm-cursor-pointer{cursor:pointer}.xterm.column-select.focus{cursor:crosshair}.xterm .xterm-accessibility,.xterm .xterm-message{position:absolute;left:0;top:0;bottom:0;right:0;z-index:10;color:transparent;pointer-events:none}.xterm .live-region{position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden}.xterm-dim{opacity:1!important}.xterm-underline-1{text-decoration:underline}.xterm-underline-2{-webkit-text-decoration:double underline;text-decoration:double underline}.xterm-underline-3{-webkit-text-decoration:wavy underline;text-decoration:wavy underline}.xterm-underline-4{-webkit-text-decoration:dotted underline;text-decoration:dotted underline}.xterm-underline-5{-webkit-text-decoration:dashed underline;text-decoration:dashed underline}.xterm-overline{text-decoration:overline}.xterm-overline.xterm-underline-1{text-decoration:overline underline}.xterm-overline.xterm-underline-2{-webkit-text-decoration:overline double underline;text-decoration:overline double underline}.xterm-overline.xterm-underline-3{-webkit-text-decoration:overline wavy underline;text-decoration:overline wavy underline}.xterm-overline.xterm-underline-4{-webkit-text-decoration:overline dotted underline;text-decoration:overline dotted underline}.xterm-overline.xterm-underline-5{-webkit-text-decoration:overline dashed underline;text-decoration:overline dashed underline}.xterm-strikethrough{text-decoration:line-through}.xterm-screen .xterm-decoration-container .xterm-decoration{z-index:6;position:absolute}.xterm-screen .xterm-decoration-container .xterm-decoration.xterm-decoration-top-layer{z-index:7}.xterm-decoration-overview-ruler{z-index:8;position:absolute;top:0;right:0;pointer-events:none}.xterm-decoration-top{z-index:2;position:relative}`, Ua = class Ua extends le {
  constructor() {
    super(...arguments), this.terminal = null, this.fitAddon = null, this.searchAddon = null, this.webLinksAddon = null, this.wsManager = null, this.terminalConnected = !1, this.connectionStatus = "disconnected", this.resizeObserver = null, this.handleWindowResize = () => {
      this.fitAddon && this.fitAddon.fit();
    }, this.handleFullscreenChange = () => {
      const e = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      console.log("Fullscreen change detected:", e), this.requestUpdate(), this.updateComplete.then(() => {
        setTimeout(() => {
          var a;
          if (!this.terminal || !this.fitAddon) return;
          const t = (a = this.shadowRoot) == null ? void 0 : a.querySelector(".terminal-wrapper");
          if (!t) return;
          const i = this.terminal.buffer.active, r = [];
          for (let l = 0; l < i.length; l++) {
            const c = i.getLine(l);
            c && r.push(c.translateToString());
          }
          const n = i.cursorY, o = i.cursorX;
          if (e) {
            t.innerHTML = "", t.style.width = "100%", t.style.height = "100%", t.style.display = "block", t.style.backgroundColor = "#1e1e1e", this.terminal.open(t);
            for (const l of r)
              l.trim() && this.terminal.writeln(l);
            this.terminal.write(`\x1B[${n + 1};${o + 1}H`);
          }
          this.fitAddon.fit(), this.terminal.focus(), this.terminal.refresh(0, this.terminal.rows - 1), t.focus(), this.terminal.focus(), this.terminal.resize(this.terminal.cols, this.terminal.rows), this.terminal.refresh(0, this.terminal.rows - 1);
        }, 500);
      });
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.updateComplete.then(() => {
      this.initializeTerminal();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.cleanup();
  }
  initializeTerminal() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(".terminal-wrapper");
    e && (this.terminal = new Rb.Terminal({
      cursorBlink: !0,
      fontSize: 14,
      fontFamily: 'Consolas, "Courier New", monospace',
      scrollback: 1e4,
      // Allow 10000 lines of scrollback
      convertEol: !0,
      screenReaderMode: !1,
      theme: {
        background: "#1e1e1e",
        foreground: "#cccccc",
        cursor: "#ffffff",
        black: "#000000",
        red: "#cd3131",
        green: "#0dbc79",
        yellow: "#e5e510",
        blue: "#2472c8",
        magenta: "#bc3fbc",
        cyan: "#11a8cd",
        white: "#e5e5e5",
        brightBlack: "#666666",
        brightRed: "#f14c4c",
        brightGreen: "#23d18b",
        brightYellow: "#f5f543",
        brightBlue: "#3b8eea",
        brightMagenta: "#d670d6",
        brightCyan: "#29b8db",
        brightWhite: "#e5e5e5"
      }
    }), this.fitAddon = new Ob.FitAddon(), this.searchAddon = new Bb.SearchAddon(), this.webLinksAddon = new Pb.WebLinksAddon(), this.terminal.loadAddon(this.fitAddon), this.terminal.loadAddon(this.searchAddon), this.terminal.loadAddon(this.webLinksAddon), this.terminal.open(e), this.setupResizeObserver(e), setTimeout(() => {
      var i;
      (i = this.fitAddon) == null || i.fit();
    }, 100), this.hideCharMeasureElement(), this.terminal.onData((i) => {
      if (this.wsManager && this.terminalConnected) {
        const r = {
          type: "input",
          data: i
        };
        this.wsManager.send(r);
      }
    }), this.setupScrollingShortcuts(), this.terminal.onResize((i) => {
      if (this.wsManager && this.terminalConnected) {
        const r = {
          type: "resize",
          payload: {
            cols: i.cols,
            rows: i.rows
          }
        };
        this.wsManager.send(r);
      }
    }), window.addEventListener("resize", this.handleWindowResize), document.addEventListener("fullscreenchange", this.handleFullscreenChange), document.addEventListener("webkitfullscreenchange", this.handleFullscreenChange), document.addEventListener("mozfullscreenchange", this.handleFullscreenChange), document.addEventListener("MSFullscreenChange", this.handleFullscreenChange), this.connect());
  }
  setupResizeObserver(e) {
    this.resizeObserver && this.resizeObserver.disconnect(), this.resizeObserver = new ResizeObserver(() => {
      this.fitAddon && this.terminal && requestAnimationFrame(() => {
        var t;
        (t = this.fitAddon) == null || t.fit();
      });
    }), this.resizeObserver.observe(e);
  }
  setupScrollingShortcuts() {
    var t;
    if (!this.terminal) return;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(".terminal-wrapper");
    e && e.addEventListener("keydown", (i) => {
      if (!this.terminal) return;
      const r = i;
      if (r.key === "PageUp")
        r.preventDefault(), this.terminal.scrollPages(-1);
      else if (r.key === "PageDown")
        r.preventDefault(), this.terminal.scrollPages(1);
      else if (r.ctrlKey && r.key === "Home")
        r.preventDefault(), this.terminal.scrollToTop();
      else if (r.ctrlKey && r.key === "End")
        r.preventDefault(), this.terminal.scrollToBottom();
      else if (r.shiftKey && r.key === "PageUp") {
        r.preventDefault();
        const n = this.terminal.rows;
        this.terminal.scrollLines(-Math.floor(n / 2));
      } else if (r.shiftKey && r.key === "PageDown") {
        r.preventDefault();
        const n = this.terminal.rows;
        this.terminal.scrollLines(Math.floor(n / 2));
      }
    }), this.terminal.onScroll((i) => {
    });
  }
  hideCharMeasureElement() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(".terminal-container");
    if (e) {
      setTimeout(() => {
        const r = e.querySelector(".xterm-char-measure-element");
        r && (r.style.position = "absolute", r.style.top = "0", r.style.left = "0", r.style.visibility = "hidden");
        const n = e.querySelector(".xterm-helper-textarea");
        n && (n.style.position = "absolute", n.style.left = "-9999px", n.style.top = "0", n.style.width = "0", n.style.height = "0", n.style.opacity = "0");
      }, 100);
      const i = document.createElement("style");
      i.textContent = `
        .xterm-char-measure-element {
          position: absolute !important;
          top: 0 !important;
          left: 0 !important;
          visibility: hidden !important;
        }
        
        .xterm-helper-textarea {
          position: absolute !important;
          left: -9999px !important;
          top: 0 !important;
          width: 0 !important;
          height: 0 !important;
          z-index: -10 !important;
          opacity: 0 !important;
          overflow: hidden !important;
          resize: none !important;
          pointer-events: none !important;
        }
        
        /* Fix xterm terminal height and scrolling */
        .xterm {
          height: 100%;
          width: 100%;
        }
        
        .xterm-viewport {
          height: 100% !important;
          width: 100% !important;
          overflow-y: scroll !important;
        }
        
        .xterm-scroll-area {
          height: auto !important;
          min-height: 100% !important;
        }
        
        .xterm-screen {
          position: relative;
          height: 100%;
        }
        
        /* Ensure terminal is visible in fullscreen */
        :host(:fullscreen) .xterm,
        :host(:-webkit-full-screen) .xterm,
        :host(:-moz-full-screen) .xterm,
        :host(:-ms-fullscreen) .xterm {
          z-index: 1000;
          opacity: 1 !important;
          visibility: visible !important;
        }
        
        :host(:fullscreen) .terminal-wrapper,
        :host(:-webkit-full-screen) .terminal-wrapper,
        :host(:-moz-full-screen) .terminal-wrapper,
        :host(:-ms-fullscreen) .terminal-wrapper {
          z-index: 999;
          opacity: 1 !important;
          visibility: visible !important;
          background-color: #1e1e1e;
        }
      `, e.appendChild(i);
    }
  }
  async connect() {
    var e, t;
    this.wsManager && this.wsManager.disconnect(), this.connectionStatus = "connecting", this.requestUpdate();
    try {
      this.wsManager = new ea("/ws/terminal"), this.wsManager.on("output", (r) => {
        var n;
        this.terminal && ((n = r.payload) != null && n.data) && this.terminal.write(r.payload.data);
      }), this.wsManager.on("error", (r) => {
        console.error("Terminal error:", r.error), this.terminalConnected = !1, this.connectionStatus = "disconnected", this.requestUpdate();
      }), await this.wsManager.connect();
      const i = {
        type: "subscribe",
        payload: {
          cols: ((e = this.terminal) == null ? void 0 : e.cols) || 80,
          rows: ((t = this.terminal) == null ? void 0 : t.rows) || 24,
          shell: "/bin/bash"
        }
      };
      this.wsManager.send(i), this.terminalConnected = !0, this.connectionStatus = "connected", this.requestUpdate();
    } catch (i) {
      console.error("Failed to connect to terminal:", i), this.connectionStatus = "disconnected", this.requestUpdate();
    }
  }
  disconnect() {
    this.wsManager && (this.wsManager.disconnect(), this.wsManager = null), this.terminalConnected = !1, this.connectionStatus = "disconnected", this.requestUpdate();
  }
  clearTerminal() {
    this.terminal && this.terminal.clear();
  }
  scrollToTop() {
    this.terminal && this.terminal.scrollToTop();
  }
  scrollToBottom() {
    this.terminal && this.terminal.scrollToBottom();
  }
  async copySelection() {
    if (this.terminal && this.terminal.hasSelection()) {
      const e = this.terminal.getSelection();
      try {
        await navigator.clipboard.writeText(e);
      } catch (t) {
        console.error("Failed to copy to clipboard:", t);
      }
    }
  }
  async pasteFromClipboard() {
    try {
      const e = await navigator.clipboard.readText();
      if (e && this.wsManager && this.terminalConnected) {
        const t = {
          type: "input",
          data: e
        };
        this.wsManager.send(t);
      }
    } catch (e) {
      console.error("Failed to paste from clipboard:", e);
    }
  }
  toggleFullscreen() {
    if (document.fullscreenElement)
      document.exitFullscreen().then(() => {
        this.requestUpdate(), setTimeout(() => {
          var e, t;
          (e = this.fitAddon) == null || e.fit(), (t = this.terminal) == null || t.focus();
        }, 300);
      }).catch((e) => {
        console.error("Failed to exit fullscreen:", e);
      });
    else {
      const e = this, t = e.requestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen || e.msRequestFullscreen;
      t && t.call(e).then(() => {
        this.requestUpdate(), setTimeout(() => {
          var r, n, o;
          (r = this.fitAddon) == null || r.fit(), (n = this.terminal) == null || n.focus();
          const i = (o = this.shadowRoot) == null ? void 0 : o.querySelector(".terminal-wrapper");
          i && (i.style.opacity = "1", i.style.visibility = "visible");
        }, 300);
      }).catch((i) => {
        console.error("Failed to enter fullscreen:", i);
      });
    }
  }
  cleanup() {
    window.removeEventListener("resize", this.handleWindowResize), document.removeEventListener("fullscreenchange", this.handleFullscreenChange), document.removeEventListener("webkitfullscreenchange", this.handleFullscreenChange), document.removeEventListener("mozfullscreenchange", this.handleFullscreenChange), document.removeEventListener("MSFullscreenChange", this.handleFullscreenChange), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.wsManager && (this.wsManager.disconnect(), this.wsManager = null), this.terminal && (this.terminal.dispose(), this.terminal = null), this.fitAddon = null, this.searchAddon = null, this.webLinksAddon = null;
  }
  render() {
    let e = "status-bar", t = "";
    switch (this.connectionStatus) {
      case "connecting":
        e += " status-connecting", t = L("terminal.connecting");
        break;
      case "connected":
        e += " status-connected", t = L("terminal.connected");
        break;
      case "disconnected":
        e += " status-disconnected", t = L("terminal.disconnected");
        break;
    }
    return D`
      <div class="terminal-header">
        <h3>${L("terminal.title")}</h3>
        <div class="terminal-actions">
          <button class="terminal-action" @click=${this.clearTerminal} title="${L("terminal.clear")}">
            ${L("terminal.clear")}
          </button>
          <button class="terminal-action" @click=${this.copySelection} title="${L("terminal.copy")}">
            ${L("terminal.copy")}
          </button>
          <button class="terminal-action" @click=${this.pasteFromClipboard} title="${L("terminal.paste")}">
            ${L("terminal.paste")}
          </button>
          <button class="terminal-action" @click=${this.toggleFullscreen} title="${L("terminal.fullscreen")}">
            ${L("terminal.fullscreen")}
          </button>
          <button class="terminal-action" @click=${this.scrollToTop} title="Scroll to Top">
             Top
          </button>
          <button class="terminal-action" @click=${this.scrollToBottom} title="Scroll to Bottom">
             Bottom
          </button>
          ${this.connectionStatus === "disconnected" ? D`<button class="terminal-action" @click=${this.connect}>Connect</button>` : this.connectionStatus === "connected" ? D`<button class="terminal-action" @click=${this.disconnect}>Disconnect</button>` : ""}
        </div>
      </div>
      <div class="terminal-container">
        <div class="terminal-wrapper"></div>
      </div>
      <div class="${e}">${t}</div>
    `;
  }
};
Ua.styles = [
  zc(Nb),
  re`
    :host {
      display: flex;
      flex-direction: column;
      height: 100%;
      background-color: var(--vscode-bg);
      border: 1px solid var(--vscode-border);
      box-sizing: border-box;
    }

    .terminal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      background-color: var(--vscode-bg-lighter);
      border-bottom: 1px solid var(--vscode-border);
    }

    .terminal-header h3 {
      margin: 0;
      font-size: 14px;
      font-weight: normal;
      color: var(--vscode-text);
    }

    .terminal-actions {
      display: flex;
      gap: 8px;
    }

    .terminal-action {
      padding: 4px 8px;
      border: none;
      background-color: transparent;
      color: var(--vscode-text-dim);
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .terminal-action:hover {
      background-color: var(--vscode-bg-light);
      color: var(--vscode-text);
    }

    .terminal-container {
      flex: 1;
      overflow: hidden;
      padding: 8px;
      display: flex;
      flex-direction: column;
    }

    /* Ensure xterm terminal fills the container */
    .terminal-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .status-bar {
      display: flex;
      align-items: center;
      padding: 4px 16px;
      background-color: var(--vscode-bg-lighter);
      border-top: 1px solid var(--vscode-border);
      color: var(--vscode-text);
      font-size: 12px;
    }

    .status-connected {
      background-color: var(--vscode-success);
    }

    .status-disconnected {
      background-color: var(--vscode-error);
    }

    .status-connecting {
      background-color: var(--vscode-warning);
    }

    /* Terminal container should position elements correctly */
    .terminal-container {
      position: relative;
    }

    /* Fullscreen styles */
    :host(:fullscreen),
    :host(:-webkit-full-screen),
    :host(:-moz-full-screen),
    :host(:-ms-fullscreen) {
      width: 100vw !important;
      height: 100vh !important;
      background-color: var(--vscode-bg);
      display: flex !important;
      flex-direction: column !important;
      margin: 0 !important;
      padding: 0 !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      z-index: 9999 !important;
    }

    :host(:fullscreen) .terminal-header,
    :host(:-webkit-full-screen) .terminal-header,
    :host(:-moz-full-screen) .terminal-header,
    :host(:-ms-fullscreen) .terminal-header {
      background-color: rgba(37, 37, 38, 0.95);
      z-index: 10000 !important;
    }

    :host(:fullscreen) .terminal-container,
    :host(:-webkit-full-screen) .terminal-container,
    :host(:-moz-full-screen) .terminal-container,
    :host(:-ms-fullscreen) .terminal-container {
      flex: 1 !important;
      height: auto !important;
      padding: 16px;
      background-color: #1e1e1e !important;
      display: flex !important;
      flex-direction: column !important;
      opacity: 1 !important;
      visibility: visible !important;
      z-index: 10001 !important;
    }

    :host(:fullscreen) .terminal-wrapper,
    :host(:-webkit-full-screen) .terminal-wrapper,
    :host(:-moz-full-screen) .terminal-wrapper,
    :host(:-ms-fullscreen) .terminal-wrapper {
      flex: 1 !important;
      background-color: #1e1e1e !important;
      opacity: 1 !important;
      visibility: visible !important;
      position: relative !important;
      overflow: hidden !important;
      z-index: 10002 !important;
    }

    /* Force xterm to be visible in fullscreen */
    :host(:fullscreen) .terminal-wrapper .xterm,
    :host(:-webkit-full-screen) .terminal-wrapper .xterm,
    :host(:-moz-full-screen) .terminal-wrapper .xterm,
    :host(:-ms-fullscreen) .terminal-wrapper .xterm {
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
      width: 100% !important;
      height: 100% !important;
      z-index: 10003 !important;
    }

    :host(:fullscreen) .status-bar,
    :host(:-webkit-full-screen) .status-bar,
    :host(:-moz-full-screen) .status-bar,
    :host(:-ms-fullscreen) .status-bar {
      z-index: 10004 !important;
    }
  `
];
let Uo = Ua;
customElements.define("terminal-tab", Uo);
var Fb = Object.defineProperty, xt = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Fb(e, t, r), r;
};
const Wa = class Wa extends le {
  constructor() {
    super(...arguments), this.users = [], this.showCreateForm = !1, this.showEditForm = !1, this.showResetPasswordForm = !1, this.newUser = { username: "", password: "", groups: "" }, this.editingUser = null, this.userToDelete = null, this.resetPasswordUsername = null, this.newPassword = "", this.confirmPassword = "", this.searchQuery = "", this.handleDocumentClick = (e) => {
      var t;
      (t = this.shadowRoot) != null && t.contains(e.target) || this.closeAllMenus();
    }, this.handleKeyDown = (e) => {
      e.key === "Escape" && (this.closeAllMenus(), this.showCreateForm && this.closeCreateDrawer(), this.showEditForm && this.closeEditDrawer(), this.showResetPasswordForm && this.closeResetPasswordDrawer());
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchUsers(), this.addEventListener("click", (e) => {
      e.target.closest(".action-menu") || this.closeAllMenus();
    }), document.addEventListener("click", this.handleDocumentClick), document.addEventListener("keydown", this.handleKeyDown);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("click", this.handleDocumentClick), document.removeEventListener("keydown", this.handleKeyDown);
  }
  async fetchUsers() {
    try {
      const e = await J.get("/users");
      this.users = e.users;
    } catch (e) {
      console.error("Error fetching users:", e);
    }
  }
  async createUser() {
    try {
      await J.post("/users", this.newUser), this.showCreateForm = !1, this.newUser = { username: "", password: "", groups: "" }, this.fetchUsers();
    } catch (e) {
      console.error("Error creating user:", e);
    }
  }
  async deleteUser() {
    if (this.userToDelete)
      try {
        await J.delete(`/users/${this.userToDelete}`), this.userToDelete = null, this.fetchUsers(), this.closeDeleteModal();
      } catch (e) {
        console.error("Error deleting user:", e);
      }
  }
  openDeleteModal(e) {
    var i;
    this.userToDelete = e;
    const t = (i = this.shadowRoot) == null ? void 0 : i.querySelector("#deleteModal");
    t && (t.open = !0);
  }
  closeDeleteModal() {
    var t;
    this.userToDelete = null;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("#deleteModal");
    e && (e.open = !1);
  }
  openResetPasswordDrawer(e) {
    this.resetPasswordUsername = e, this.newPassword = "", this.confirmPassword = "", this.showResetPasswordForm = !0;
  }
  closeResetPasswordDrawer() {
    this.showResetPasswordForm = !1, this.resetPasswordUsername = null, this.newPassword = "", this.confirmPassword = "";
  }
  async resetPassword() {
    if (this.resetPasswordUsername) {
      if (this.newPassword !== this.confirmPassword) {
        alert(L("users.passwordMismatch"));
        return;
      }
      if (!this.newPassword) {
        alert(L("users.passwordRequired", { default: "Password is required" }));
        return;
      }
      try {
        await J.put(`/users/${this.resetPasswordUsername}/password`, {
          password: this.newPassword
        }), this.closeResetPasswordDrawer(), alert(L("users.resetPasswordSuccess", { username: this.resetPasswordUsername }));
      } catch (e) {
        console.error("Error resetting password:", e), alert(L("users.resetPasswordError", { default: "Failed to reset password" }));
      }
    }
  }
  openEditDrawer(e) {
    const t = this.users.find((i) => i.username === e);
    t && (this.editingUser = { ...t }, this.showEditForm = !0);
  }
  closeEditDrawer() {
    this.showEditForm = !1, this.editingUser = null;
  }
  async updateUser() {
    if (this.editingUser)
      try {
        await J.put(`/users/${this.editingUser.username}`, {
          groups: this.editingUser.groups.join(",")
        }), this.showEditForm = !1, this.editingUser = null, this.fetchUsers();
      } catch (e) {
        console.error("Error updating user:", e);
      }
  }
  updateEditingUser(e, t) {
    this.editingUser && (e === "groups" ? this.editingUser = {
      ...this.editingUser,
      groups: t.split(",").map((i) => i.trim()).filter(Boolean)
    } : this.editingUser = { ...this.editingUser, [e]: t });
  }
  toggleActionMenu(e, t) {
    var r;
    e.stopPropagation();
    const i = (r = this.shadowRoot) == null ? void 0 : r.getElementById(t);
    if (i) {
      const n = i.classList.contains("show");
      if (this.closeAllMenus(), !n) {
        i.classList.add("show");
        const o = i.querySelector("button");
        o && setTimeout(() => o.focus(), 10);
      }
    }
  }
  closeAllMenus() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelectorAll(".action-dropdown");
    e == null || e.forEach((i) => i.classList.remove("show"));
  }
  updateNewUser(e, t) {
    this.newUser = { ...this.newUser, [e]: t };
  }
  closeCreateDrawer() {
    this.showCreateForm = !1, this.newUser = { username: "", password: "", groups: "" };
  }
  handleSearch(e) {
    this.searchQuery = e.target.value;
  }
  clearSearch() {
    this.searchQuery = "";
  }
  get filteredUsers() {
    if (!this.searchQuery.trim())
      return this.users;
    const e = this.searchQuery.toLowerCase();
    return this.users.filter(
      (t) => t.username.toLowerCase().includes(e) || t.uid.toString().includes(e) || t.gid.toString().includes(e) || t.home.toLowerCase().includes(e) || t.shell.toLowerCase().includes(e) || t.groups && Array.isArray(t.groups) && t.groups.some((i) => i.toLowerCase().includes(e))
    );
  }
  render() {
    var t, i, r;
    const e = this.filteredUsers;
    return D`
      <div class="header">
        <h1>${L("users.title")}</h1>
        <div class="actions">
          <div class="search-box">
            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
            <input 
              type="text" 
              placeholder="${L("users.searchUsers")}"
              .value=${this.searchQuery}
              @input=${this.handleSearch}
            />
            ${this.searchQuery ? D`
              <button class="clear-search" @click=${this.clearSearch}>
                
              </button>
            ` : ""}
          </div>
          <button class="btn-primary" @click=${() => this.showCreateForm = !0}>
            ${L("users.createUser")}
          </button>
        </div>
      </div>
      
      <table class="users-table">
          <thead>
            <tr>
              <th>${L("users.username")}</th>
              <th>${L("users.uid")}</th>
              <th>${L("users.gid")}</th>
              <th>${L("users.home")}</th>
              <th>${L("users.shell")}</th>
              <th>${L("common.actions")}</th>
            </tr>
          </thead>
          <tbody>
            ${e.map((n, o) => D`
              <tr>
                <td>${n.username}</td>
                <td>${n.uid}</td>
                <td>${n.gid}</td>
                <td>${n.home}</td>
                <td>${n.shell}</td>
                <td>
                  <div class="action-menu">
                    <button class="action-dots" @click=${(a) => this.toggleActionMenu(a, `user-${o}`)}></button>
                    <div class="action-dropdown" id="user-${o}">
                      <button @click=${() => {
      this.closeAllMenus(), this.openResetPasswordDrawer(n.username);
    }}>
                        ${L("users.resetPassword")}
                      </button>
                      <button @click=${() => {
      this.closeAllMenus(), this.openEditDrawer(n.username);
    }}>
                        ${L("common.edit")}
                      </button>
                      <button class="danger" @click=${() => {
      this.closeAllMenus(), this.openDeleteModal(n.username);
    }}>
                        ${L("common.delete")}
                      </button>
                    </div>
                  </div>
                </td>
              </tr>
            `)}
          </tbody>
        </table>

      <modal-dialog 
        id="deleteModal" 
        title="${L("users.confirmDelete", { default: "Delete User" })}" 
        size="small"
        @modal-close=${this.closeDeleteModal}
      >
        <p>
          ${this.userToDelete ? L("users.confirmDeleteMessage", {
      username: this.userToDelete,
      default: `Are you sure you want to delete user "${this.userToDelete}"? This action cannot be undone.`
    }) : ""}
        </p>
        <div slot="footer">
          <button class="btn-secondary" @click=${this.closeDeleteModal}>
            ${L("common.cancel")}
          </button>
          <button class="btn-danger" @click=${this.deleteUser}>
            ${L("common.delete")}
          </button>
        </div>
      </modal-dialog>

      ${this.showCreateForm ? D`
        <div class="drawer">
          <button class="close-btn" @click=${this.closeCreateDrawer}></button>
          <h2>${L("users.createUser")}</h2>
          <div class="drawer-form">
            <div class="form-group">
              <label for="username">${L("users.username")}</label>
              <input
                id="username"
                type="text"
                .value=${this.newUser.username}
                @input=${(n) => this.updateNewUser("username", n.target.value)}
                placeholder="${L("users.username")}"
              />
            </div>
            <div class="form-group">
              <label for="password">${L("users.password")}</label>
              <input
                id="password"
                type="password"
                .value=${this.newUser.password}
                @input=${(n) => this.updateNewUser("password", n.target.value)}
                placeholder="${L("users.password")}"
              />
            </div>
            <div class="form-group">
              <label for="groups">${L("users.groups")}</label>
              <input
                id="groups"
                type="text"
                .value=${this.newUser.groups}
                @input=${(n) => this.updateNewUser("groups", n.target.value)}
                placeholder="wheel,users"
              />
            </div>
            <div class="form-actions">
              <button class="btn-secondary" @click=${this.closeCreateDrawer}>
                ${L("common.cancel")}
              </button>
              <button class="btn-primary" @click=${this.createUser}>
                ${L("common.create")}
              </button>
            </div>
          </div>
        </div>
      ` : ""}

      ${this.showEditForm ? D`
        <div class="drawer">
          <button class="close-btn" @click=${this.closeEditDrawer}></button>
          <h2>${L("users.editUser")}</h2>
          <div class="drawer-form">
            <div class="form-group">
              <label for="username">${L("users.username")}</label>
              <input
                id="username"
                type="text"
                .value=${(t = this.editingUser) == null ? void 0 : t.username}
                @input=${(n) => this.updateEditingUser("username", n.target.value)}
                placeholder="${L("users.username")}"
                disabled
              />
            </div>
            <div class="form-group">
              <label for="groups">${L("users.groups")}</label>
              <input
                id="groups"
                type="text"
                .value=${((r = (i = this.editingUser) == null ? void 0 : i.groups) == null ? void 0 : r.join(",")) || ""}
                @input=${(n) => this.updateEditingUser("groups", n.target.value)}
                placeholder="wheel,users"
              />
            </div>
            <div class="form-actions">
              <button class="btn-secondary" @click=${this.closeEditDrawer}>
                ${L("common.cancel")}
              </button>
              <button class="btn-primary" @click=${this.updateUser}>
                ${L("common.save")}
              </button>
            </div>
          </div>
        </div>
      ` : ""}

      ${this.showResetPasswordForm ? D`
        <div class="drawer">
          <button class="close-btn" @click=${this.closeResetPasswordDrawer}></button>
          <h2>${L("users.resetPassword")} - ${this.resetPasswordUsername}</h2>
          <div class="drawer-form">
            <div class="form-group">
              <label for="new-password">${L("users.newPassword", { default: "New Password" })}</label>
              <input
                id="new-password"
                type="password"
                .value=${this.newPassword}
                @input=${(n) => this.newPassword = n.target.value}
                placeholder="${L("users.newPassword", { default: "New Password" })}"
              />
            </div>
            <div class="form-group">
              <label for="confirm-password">${L("users.confirmPassword")}</label>
              <input
                id="confirm-password"
                type="password"
                .value=${this.confirmPassword}
                @input=${(n) => this.confirmPassword = n.target.value}
                placeholder="${L("users.confirmPassword")}"
              />
            </div>
            <div class="form-actions">
              <button class="btn-secondary" @click=${this.closeResetPasswordDrawer}>
                ${L("common.cancel")}
              </button>
              <button class="btn-primary" @click=${this.resetPassword}>
                ${L("users.resetPassword")}
              </button>
            </div>
          </div>
        </div>
      ` : ""}
    `;
  }
};
Wa.styles = re`
    :host {
      display: block;
      padding: 16px;
    }

    .header {
      margin-bottom: 20px;
    }

    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .search-box {
      position: relative;
      flex: 1;
      max-width: 250px;
    }

    .search-box input {
      width: 100%;
      padding: 8px 36px 8px 36px;
      border: 1px solid var(--vscode-border);
      border-radius: 4px;
      background: var(--vscode-bg-light);
      color: var(--vscode-text);
      font-size: 14px;
      transition: border-color 0.2s;
    }

    .search-box input:focus {
      outline: none;
      border-color: var(--vscode-accent);
    }

    .search-box input::placeholder {
      color: var(--vscode-text-dim);
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--vscode-text-dim);
      pointer-events: none;
      width: 16px;
      height: 16px;
    }

    .clear-search {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--vscode-text-dim);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    .clear-search:hover {
      background-color: var(--vscode-toolbar-hoverBackground, rgba(90, 93, 94, 0.1));
    }

    h1 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 300;
    }

    .users-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--vscode-bg-light);
      border-radius: 1px;
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .users-table thead {
      background: var(--vscode-bg-lighter);
    }

    .users-table th {
      padding: 12px;
      text-align: left;
      font-weight: 500;
      font-size: 13px;
      border-bottom: 1px solid var(--vscode-border);
    }

    .users-table td {
      padding: 12px;
      font-size: 14px;
      border-bottom: 1px solid var(--vscode-border);
    }

    .users-table tbody tr:last-child td {
      border-bottom: none;
    }

    .users-table tbody tr:hover {
      background: var(--vscode-bg-lighter);
    }

    .users-table td:last-child {
      text-align: right;
    }

    .action-menu {
      position: relative;
      display: inline-block;
    }

    .action-dots {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      color: var(--vscode-text-dim);
      font-size: 18px;
      line-height: 1;
      transition: background-color 0.2s;
      border-radius: 4px;
    }

    .action-dots:hover {
      background-color: var(--vscode-toolbar-hoverBackground, rgba(90, 93, 94, 0.1));
    }

    .action-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--vscode-dropdown-background, var(--vscode-bg-light));
      border: 1px solid var(--vscode-dropdown-border, var(--vscode-border));
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 160px;
      z-index: 1000;
      display: none;
    }

    .action-dropdown.show {
      display: block;
    }

    .action-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 16px;
      border: none;
      background: none;
      color: var(--vscode-text);
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .action-dropdown button:hover {
      background-color: var(--vscode-list-hoverBackground, rgba(255, 255, 255, 0.08));
    }

    .action-dropdown button.danger {
      color: var(--vscode-error);
    }

    .action-dropdown button.danger:hover {
      background-color: rgba(244, 67, 54, 0.1);
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--vscode-accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--vscode-accent-hover);
    }

    .btn-danger {
      background: var(--vscode-error);
      color: white;
    }

    .btn-danger:hover {
      opacity: 0.9;
    }

    .btn-secondary {
      background: var(--vscode-bg-lighter);
      color: var(--vscode-text);
      border: 1px solid var(--vscode-border);
    }

    .btn-secondary:hover {
      background: var(--vscode-border);
    }

    .create-form {
      background: var(--vscode-bg-light);
      padding: 20px;
      border-radius: 6px;
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      font-size: 13px;
    }

    input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--vscode-border);
      background: var(--vscode-bg);
      color: var(--vscode-text);
      border-radius: 4px;
      font-size: 14px;
    }

    input:focus {
      outline: none;
      border-color: var(--vscode-accent);
    }

    .form-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 20px;
    }

    .icon {
      width: 16px;
      height: 16px;
      display: inline-block;
      margin-right: 4px;
    }

    .drawer {
      position: fixed;
      top: 0;
      right: 0;
      width: 400px;
      height: 100%;
      background: var(--vscode-bg-light);
      border-left: 1px solid var(--vscode-border);
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      overflow-y: auto;
      padding: 24px;
      animation: slideIn 0.3s ease-out;
    }

    @media (max-width: 768px) {
      .drawer {
        width: 100%;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
      }
      to {
        transform: translateX(0);
      }
    }

    .drawer h2 {
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 20px;
      font-weight: 500;
    }

    .drawer .close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 8px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: var(--vscode-text-dim);
      transition: color 0.2s;
    }

    .drawer .close-btn:hover {
      color: var(--vscode-text);
    }

    .drawer-form {
      margin-top: 40px;
    }
  `;
let at = Wa;
xt([
  H({ type: Array })
], at.prototype, "users");
xt([
  H({ type: Boolean })
], at.prototype, "showCreateForm");
xt([
  H({ type: Boolean })
], at.prototype, "showEditForm");
xt([
  H({ type: Boolean })
], at.prototype, "showResetPasswordForm");
xt([
  H({ type: Object })
], at.prototype, "newUser");
xt([
  H({ type: Object })
], at.prototype, "editingUser");
xt([
  H({ type: String })
], at.prototype, "userToDelete");
xt([
  H({ type: String })
], at.prototype, "resetPasswordUsername");
xt([
  H({ type: String })
], at.prototype, "newPassword");
xt([
  H({ type: String })
], at.prototype, "confirmPassword");
xt([
  H({ type: String })
], at.prototype, "searchQuery");
customElements.define("users-tab", at);
var zb = Object.defineProperty, we = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && zb(e, t, r), r;
};
const Va = class Va extends le {
  constructor() {
    super(...arguments), this.activeTab = "processes", this.containers = [], this.images = [], this.volumes = [], this.networks = [], this.searchTerm = "", this.error = null, this.showConfirmModal = !1, this.confirmAction = null, this.selectedContainer = null, this.selectedImage = null, this.showDrawer = !1, this.detailError = null, this.confirmTitle = "", this.confirmMessage = "", this.showLogsDrawer = !1, this.containerLogs = "", this.logsError = null, this.logsSearchTerm = "", this.showImageActionsDropdown = !1, this.showPullImageModal = !1, this.imageName = "", this.showUploadDrawer = !1, this.uploadQueue = [], this.isUploading = !1, this.handleDocumentClick = (e) => {
      e.target.closest(".action-menu") || this.closeAllMenus();
    }, this.handleKeyDown = (e) => {
      e.key === "Escape" && (this.showConfirmModal ? this.handleCancel() : this.closeAllMenus());
    }, this.handleLocationChange = () => {
      const e = window.location.pathname;
      e.endsWith("/images") ? this.activeTab = "images" : e.endsWith("/volumes") ? this.activeTab = "volumes" : e.endsWith("/networks") ? this.activeTab = "networks" : this.activeTab = "processes", this.fetchData();
    }, this.handleFileSelect = (e) => {
      const t = e.target;
      if (t.files && t.files.length > 0) {
        const i = t.files[0];
        i && this.addToUploadQueue(i);
      }
    }, this.handleDragOver = (e) => {
      e.preventDefault(), e.currentTarget.classList.add("dragover");
    }, this.handleDragLeave = (e) => {
      e.preventDefault(), e.currentTarget.classList.remove("dragover");
    }, this.handleDrop = (e) => {
      var i;
      if (e.preventDefault(), e.currentTarget.classList.remove("dragover"), (i = e.dataTransfer) != null && i.files && e.dataTransfer.files.length > 0) {
        const r = e.dataTransfer.files[0];
        r && this.addToUploadQueue(r);
      }
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.handleLocationChange(), window.addEventListener("popstate", this.handleLocationChange), document.addEventListener("click", this.handleDocumentClick), document.addEventListener("keydown", this.handleKeyDown);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("popstate", this.handleLocationChange), document.removeEventListener("click", this.handleDocumentClick), document.removeEventListener("keydown", this.handleKeyDown);
  }
  async fetchData() {
    switch (this.activeTab) {
      case "processes":
        await this.fetchContainers();
        break;
      case "images":
        await this.fetchImages();
        break;
      case "volumes":
        await this.fetchVolumes();
        break;
      case "networks":
        await this.fetchNetworks();
        break;
    }
  }
  async fetchContainers() {
    try {
      const e = await J.get("/docker/ps");
      this.containers = e.containers || [], this.error = null;
    } catch (e) {
      console.error("Error fetching containers:", e), this.error = e instanceof De ? e.message : "Failed to fetch containers";
    }
  }
  async fetchImages() {
    try {
      const e = await J.get("/docker/images");
      this.images = e.images || [], this.error = null;
    } catch (e) {
      console.error("Error fetching images:", e), this.error = e instanceof De ? e.message : "Failed to fetch images";
    }
  }
  async fetchVolumes() {
    try {
      const e = await J.get("/docker/volumes");
      this.volumes = e.volumes || [], this.error = null;
    } catch (e) {
      console.error("Error fetching volumes:", e), this.error = e instanceof De ? e.message : "Failed to fetch volumes";
    }
  }
  async fetchNetworks() {
    try {
      const e = await J.get("/docker/networks");
      this.networks = e.networks || [], this.error = null;
    } catch (e) {
      console.error("Error fetching networks:", e), this.error = e instanceof De ? e.message : "Failed to fetch networks";
    }
  }
  handleTabClick(e, t) {
    e.preventDefault(), this.activeTab = t;
    let i;
    switch (t) {
      case "images":
        i = "/docker/images";
        break;
      case "volumes":
        i = "/docker/volumes";
        break;
      case "networks":
        i = "/docker/networks";
        break;
      default:
        i = "/docker/processes";
        break;
    }
    window.history.pushState({}, "", i), this.fetchData();
  }
  renderTabs() {
    return D`
      <div class="tab-header">
        <a 
          href="/docker/processes"
          class="tab-button ${this.activeTab === "processes" ? "active" : ""}" 
          @click="${(e) => this.handleTabClick(e, "processes")}"
        >
          Processes
        </a>
        <a 
          href="/docker/images"
          class="tab-button ${this.activeTab === "images" ? "active" : ""}" 
          @click="${(e) => this.handleTabClick(e, "images")}"
        >
          Images
        </a>
        <a 
          href="/docker/volumes"
          class="tab-button ${this.activeTab === "volumes" ? "active" : ""}" 
          @click="${(e) => this.handleTabClick(e, "volumes")}"
        >
          Volumes
        </a>
        <a 
          href="/docker/networks"
          class="tab-button ${this.activeTab === "networks" ? "active" : ""}" 
          @click="${(e) => this.handleTabClick(e, "networks")}"
        >
          Networks
        </a>
      </div>
    `;
  }
  render() {
    return D`
      <div class="tab-container">
        <h1>${L("Docker")}</h1>
        ${this.renderTabs()}
        <div class="tab-content">
          ${this.error ? D`
            <div class="error-state">
              <h3>${this.error.includes("No container runtime found") ? "Container Runtime Not Available" : "Error"}</h3>
              <p>${this.error.includes("No container runtime found") ? "Container management features are not available. Please install Docker or a CRI-compatible container runtime (containerd, CRI-O) to use this feature." : this.error}</p>
            </div>` : ""}
          ${this.activeTab === "processes" && !this.error ? D`
            ${this.containers.length > 0 ? this.renderContainersTable() : D`
                <div class="empty-state">No containers found.</div>`}
          ` : ""}
          ${this.activeTab === "images" && !this.error ? D`
            ${this.images.length > 0 ? this.renderImagesTable() : D`
                <div class="empty-state">No images found.</div>`}
          ` : ""}
          ${this.activeTab === "volumes" && !this.error ? D`
            ${this.volumes.length > 0 ? this.renderVolumesTable() : D`
                <div class="empty-state">No volumes found.</div>`}
          ` : ""}
          ${this.activeTab === "networks" && !this.error ? D`
            ${this.networks.length > 0 ? this.renderNetworksTable() : D`
                <div class="empty-state">No networks found.</div>`}
          ` : ""}
        </div>
      </div>

      <modal-dialog
        ?open=${this.showConfirmModal}
        .title=${this.confirmTitle}
        size="small"
        @modal-close=${this.handleCancel}
      >
        <p>${this.confirmMessage}</p>
        <div slot="footer" style="display: flex; gap: 8px; justify-content: flex-end;">
          <button class="btn btn-secondary" @click=${this.handleCancel}>
            ${L("common.cancel")}
          </button>
          <button class="btn btn-primary" @click=${this.handleConfirm}>
            ${L("common.confirm")}
          </button>
        </div>
      </modal-dialog>

      ${this.showDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click=${() => {
      this.showDrawer = !1, this.detailError = null;
    }}></button>
          ${this.detailError ? this.renderError() : this.selectedContainer ? this.renderContainerDetails() : this.selectedImage ? this.renderImageDetails() : ""}
        </div>` : ""}

      ${this.showLogsDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click=${() => {
      this.showLogsDrawer = !1, this.logsError = null, this.containerLogs = "", this.logsSearchTerm = "";
    }}></button>
          <div class="drawer-content">
            <div class="logs-header">
              <h2 class="logs-title">Container Logs</h2>
              <div class="search-wrapper">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input
                  class="search-input"
                  type="text"
                  placeholder="${L("containers.searchLogs")}"
                  .value=${this.logsSearchTerm}
                  @input=${(e) => this.logsSearchTerm = e.target.value}
                />
              </div>
            </div>
            ${this.logsError ? D`
              <div class="error-container">
                <div class="error-icon"></div>
                <p class="error-message">${this.logsError}</p>
              </div>` : D`
              <div class="logs-container">${jh(this.highlightSearchTerm(this.containerLogs, this.logsSearchTerm))}</div>`}
          </div>
        </div>` : ""}

      ${this.showUploadDrawer ? D`
        <div class="drawer">
          <button class="close-btn" @click=${() => {
      this.showUploadDrawer = !1, this.uploadQueue = [], this.isUploading = !1;
    }}></button>
          <div class="drawer-content">
            <div class="upload-header">
              <h2 class="upload-title">Upload Docker Image</h2>
            </div>
            
            <div class="upload-zone" 
                  @click=${() => {
      var e, t;
      return (t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("#file-input")) == null ? void 0 : t.click();
    }}
                 @dragover=${this.handleDragOver}
                 @dragleave=${this.handleDragLeave}
                 @drop=${this.handleDrop}>
              <div class="upload-icon"></div>
              <div class="upload-text">Drop image files here or click to browse</div>
              <div class="upload-hint">Supports .tar, .tar.gz, .tgz files</div>
            </div>
            
            <input 
              type="file" 
              id="file-input" 
              class="hidden-file-input"
              accept=".tar,.tar.gz,.tgz"
              @change=${this.handleFileSelect}
            />
            
            ${this.uploadQueue.length > 0 ? D`
              <div class="upload-queue">
                <h3>Upload Queue</h3>
                ${this.uploadQueue.map((e) => D`
                  <div class="upload-item">
                    <div class="upload-item-header">
                      <span class="upload-item-name">${e.file.name}</span>
                      <span class="upload-item-size">${this.formatFileSize(e.file.size)}</span>
                      <span class="upload-item-status ${e.status}">${e.status}</span>
                    </div>
                    
                    ${e.status === "uploading" || e.status === "completed" ? D`
                      <div class="progress-bar">
                        <div class="progress-fill ${e.status}" style="width: ${e.progress}%"></div>
                      </div>
                      <div class="progress-text">
                        <span>${e.progress}%</span>
                        <span>${e.status === "completed" ? "Complete" : "Uploading..."}</span>
                      </div>
                    ` : ""}
                    
                    ${e.error ? D`
                      <div class="upload-error">${e.error}</div>
                    ` : ""}
                    
                    ${e.status === "pending" || e.status === "error" ? D`
                      <button class="btn btn-secondary" style="margin-top: 8px; font-size: 12px;" 
                              @click=${() => this.removeFromUploadQueue(e.id)}>Remove</button>
                    ` : ""}
                  </div>
                `)}
              </div>
              
              <div class="upload-actions">
                <button class="btn btn-primary" 
                        ?disabled=${this.isUploading || this.uploadQueue.filter((e) => e.status === "pending").length === 0}
                        @click=${this.startUpload}>
                  ${this.isUploading ? "Uploading..." : "Start Upload"}
                </button>
                <button class="btn btn-secondary" @click=${this.clearCompletedUploads}>Clear Completed</button>
              </div>
            ` : ""}
          </div>
        </div>` : ""}

      <modal-dialog
        ?open=${this.showPullImageModal}
        .title="Pull Docker Image"
        size="medium"
        @modal-close=${() => this.showPullImageModal = !1}
      >
        <div style="margin-bottom: 16px;">
          <label for="image-name" style="display: block; margin-bottom: 8px; font-weight: 500;">Image Name:</label>
          <input 
            id="image-name"
            type="text" 
            class="search-input"
            style="width: 100%; max-width: none;"
            placeholder="e.g., nginx:latest or ubuntu:20.04"
            .value=${this.imageName}
            @input=${(e) => this.imageName = e.target.value}
          />
          <div style="font-size: 12px; color: var(--vscode-descriptionForeground, #999); margin-top: 4px;">
            Enter the full image name including tag (if needed)
          </div>
        </div>
        <div slot="footer" style="display: flex; gap: 8px; justify-content: flex-end;">
          <button class="btn btn-secondary" @click=${() => {
      this.showPullImageModal = !1, this.imageName = "";
    }}>
            Cancel
          </button>
          <button class="btn btn-primary" 
                  ?disabled=${!this.imageName.trim()}
                  @click=${this.handlePullImage}>
            Pull Image
          </button>
        </div>
      </modal-dialog>
    `;
  }
  // Placeholder methods - these will need to be implemented based on containers-tab pattern
  handleCancel() {
    this.showConfirmModal = !1, this.confirmAction = null, this.selectedContainer = null, this.selectedImage = null;
  }
  handleConfirm() {
    this.confirmAction && this.confirmAction();
  }
  renderContainersTable() {
    const e = this.containers.filter(
      (t) => t.names.some((i) => i.toLowerCase().includes(this.searchTerm.toLowerCase()))
    );
    return D`
    <div class="search-container">
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${L("containers.searchContainers")}"
          .value=${this.searchTerm}
          @input=${(t) => this.searchTerm = t.target.value}
        />
      </div>
    </div>
      <table class="table">
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Status</th>
            <th>Image</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${e.map((t, i) => {
      var l;
      const r = t.state.toLowerCase().includes("running"), n = t.state.toLowerCase().includes("paused"), o = ((l = t.id) == null ? void 0 : l.substring(0, 12)) || "Unknown", a = t.names.join(", ");
      return D`
            <tr>
              <td>${o}</td>
              <td>
                <button class="link-button" @click=${() => this.fetchContainerDetails(t.id)}>
                  ${a}
                </button>
              </td>
              <td>
                <div class="status-indicator">
                  <span class="status-icon ${this.getStatusClass(t.state)}" data-tooltip="${t.status}"></span>
                  ${t.status}
                </div>
              </td>
              <td>
                <span class="truncate" title="${t.image}">${this.truncateText(t.image, 30)}</span>
              </td>
              <td>
                <div class="action-menu">
                  <button class="action-dots" @click=${(c) => this.toggleActionMenu(c, `docker-container-${i}`)}></button>
                  <div class="action-dropdown" id="docker-container-${i}">
                    <button @click=${() => {
        this.closeAllMenus(), this.showContainerLogs(t);
      }}>View Logs</button>
                    ${r ? "" : D`
                      <button @click=${() => {
        this.closeAllMenus(), this.confirmStartContainer(t);
      }}>${L("containers.start")}</button>
                    `}
                    ${r && !n ? D`
                      <button @click=${() => {
        this.closeAllMenus(), this.confirmStopContainer(t);
      }}>${L("containers.stop")}</button>
                    ` : ""}
                    ${n ? D`
                      <button @click=${() => {
        this.closeAllMenus(), this.confirmUnpauseContainer(t);
      }}>Unpause</button>
                    ` : ""}
                    ${r && !n ? D`
                      <button @click=${() => {
        this.closeAllMenus(), this.confirmPauseContainer(t);
      }}>Pause</button>
                    ` : ""}
                    <button @click=${() => {
        this.closeAllMenus(), this.confirmRestartContainer(t);
      }}>Restart</button>
                    <button class="danger" @click=${() => {
        this.closeAllMenus(), this.confirmDeleteContainer(t);
      }}>${L("common.delete")}</button>
                  </div>
                </div>
              </td>
            </tr>
            `;
    })}
        </tbody>
      </table>
    `;
  }
  renderImagesTable() {
    const e = this.images.filter(
      (t) => {
        var i;
        return (i = t.repoTags) == null ? void 0 : i.some((r) => r.toLowerCase().includes(this.searchTerm.toLowerCase()));
      }
    );
    return D`
    <div class="search-container">
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${L("containers.searchImages")}"
          .value=${this.searchTerm}
          @input=${(t) => this.searchTerm = t.target.value}
        />
      </div>
      <div class="action-menu">
        <button class="btn btn-primary" @click=${(t) => this.toggleImageActionsMenu(t)}>+ Add Image</button>
        <div class="action-dropdown ${this.showImageActionsDropdown ? "show" : ""}">
          <button @click=${() => {
      this.closeAllMenus(), this.showPullImageModal = !0;
    }}>Pull Image</button>
          <button @click=${() => {
      this.closeAllMenus(), this.showUploadImageDialog();
    }}>Upload Image</button>
        </div>
      </div>
    </div>
    <table class="table">
        <thead>
          <tr>
            <th>ID</th>
            <th>Tags</th>
            <th>Created</th>
            <th>Size</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${e.map((t, i) => {
      var a;
      const r = ((a = t.id) == null ? void 0 : a.substring(0, 12)) || "Unknown", n = t.repoTags && t.repoTags.length > 0 ? t.repoTags.join(", ") : "No tags", o = typeof t.size == "number" ? this.formatBytes(t.size) : "Unknown";
      return D`
            <tr>
              <td>${r}</td>
              <td>${n}</td>
              <td>-</td>
              <td>${o}</td>
              <td>
                <div class="action-menu">
                  <button class="action-dots" @click=${(l) => this.toggleActionMenu(l, `docker-image-${i}`)}></button>
                  <div class="action-dropdown" id="docker-image-${i}">
                    <button @click=${() => {
        this.closeAllMenus(), this.fetchImageDetails(t.id);
      }}>View Details</button>
                    <button class="danger" @click=${() => {
        this.closeAllMenus(), this.confirmDeleteImage(t);
      }}>${L("common.delete")}</button>
                  </div>
                </div>
              </td>
            </tr>
            `;
    })}
        </tbody>
      </table>
    `;
  }
  confirmDeleteContainer(e) {
    this.selectedContainer = e, this.confirmTitle = "Confirm Delete", this.confirmMessage = `Are you sure you want to delete container ${e.names.join(", ")}?`, this.confirmAction = this.deleteSelectedContainer.bind(this), this.showConfirmModal = !0;
  }
  confirmDeleteImage(e) {
    this.selectedImage = e, this.confirmTitle = "Confirm Delete";
    const t = e.repoTags && e.repoTags.length > 0 ? e.repoTags.join(", ") : "Untagged image";
    this.confirmMessage = `Are you sure you want to delete image ${t}?`, this.confirmAction = this.deleteSelectedImage.bind(this), this.showConfirmModal = !0;
  }
  async deleteSelectedContainer() {
    if (this.selectedContainer)
      try {
        await J.delete(`/docker/containers/${this.selectedContainer.id}`), this.showConfirmModal = !1, this.fetchContainers(), this.selectedContainer = null;
      } catch (e) {
        console.error("Error deleting container:", e);
      }
  }
  async deleteSelectedImage() {
    if (this.selectedImage)
      try {
        await J.delete(`/docker/images/${this.selectedImage.id}`), this.showConfirmModal = !1, this.fetchImages(), this.selectedImage = null;
      } catch (e) {
        console.error("Error deleting image:", e);
      }
  }
  renderVolumesTable() {
    const e = this.volumes.filter(
      (t) => t.name.toLowerCase().includes(this.searchTerm.toLowerCase())
    );
    return D`
    <div class="search-container">
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${L("containers.searchVolumes")}"
          .value=${this.searchTerm}
          @input=${(t) => this.searchTerm = t.target.value}
        />
      </div>
    </div>
      <table class="table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Driver</th>
            <th>Mount Point</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${e.map((t, i) => D`
            <tr>
              <td>${t.name}</td>
              <td>${t.driver}</td>
              <td>${t.mountpoint}</td>
              <td>
                <div class="action-menu">
                  <button class="action-dots" @click=${(r) => this.toggleActionMenu(r, `docker-volume-${i}`)}></button>
                  <div class="action-dropdown" id="docker-volume-${i}">
                    <button class="danger" @click=${() => {
      this.closeAllMenus(), this.confirmDeleteVolume(t);
    }}>${L("common.delete")}</button>
                  </div>
                </div>
              </td>
            </tr>
          `)}
        </tbody>
      </table>
    `;
  }
  renderNetworksTable() {
    const e = this.networks.filter(
      (t) => t.name.toLowerCase().includes(this.searchTerm.toLowerCase())
    );
    return D`
    <div class="search-container">
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${L("containers.searchNetworks")}"
          .value=${this.searchTerm}
          @input=${(t) => this.searchTerm = t.target.value}
        />
      </div>
    </div>
      <table class="table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Driver</th>
            <th>Scope</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${e.map((t, i) => D`
            <tr>
              <td>${t.name}</td>
              <td>${t.driver}</td>
              <td>${t.scope}</td>
              <td>
                <div class="action-menu">
                  <button class="action-dots" @click=${(r) => this.toggleActionMenu(r, `docker-network-${i}`)}></button>
                  <div class="action-dropdown" id="docker-network-${i}">
                    <button class="danger" @click=${() => {
      this.closeAllMenus(), this.confirmDeleteNetwork(t);
    }}>${L("common.delete")}</button>
                  </div>
                </div>
              </td>
            </tr>
          `)}
        </tbody>
      </table>
    `;
  }
  confirmDeleteVolume(e) {
    this.confirmTitle = "Confirm Delete", this.confirmMessage = `Are you sure you want to delete volume ${e.name}?`, this.confirmAction = async () => {
      try {
        await J.delete(`/docker/volumes/${e.name}`), this.showConfirmModal = !1, this.fetchVolumes();
      } catch (t) {
        console.error("Error deleting volume:", t);
      }
    }, this.showConfirmModal = !0;
  }
  confirmDeleteNetwork(e) {
    this.confirmTitle = "Confirm Delete", this.confirmMessage = `Are you sure you want to delete network ${e.name}?`, this.confirmAction = async () => {
      try {
        await J.delete(`/docker/networks/${e.id}`), this.showConfirmModal = !1, this.fetchNetworks();
      } catch (t) {
        console.error("Error deleting network:", t);
      }
    }, this.showConfirmModal = !0;
  }
  formatBytes(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, i = ["Bytes", "KB", "MB", "GB", "TB"], r = Math.floor(Math.log(e) / Math.log(t));
    return parseFloat((e / Math.pow(t, r)).toFixed(2)) + " " + i[r];
  }
  toggleActionMenu(e, t) {
    var r;
    e.stopPropagation();
    const i = (r = this.shadowRoot) == null ? void 0 : r.getElementById(t);
    if (i) {
      const n = i.classList.contains("show");
      if (this.closeAllMenus(), !n) {
        i.classList.add("show");
        const o = i.querySelector("button");
        o && setTimeout(() => o.focus(), 10);
      }
    }
  }
  closeAllMenus() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelectorAll(".action-dropdown");
    e == null || e.forEach((i) => i.classList.remove("show"));
  }
  // Container action methods
  confirmStartContainer(e) {
    this.selectedContainer = e, this.confirmTitle = "Start Container", this.confirmMessage = `Are you sure you want to start container "${e.names.join(", ")}"?`, this.confirmAction = this.startSelectedContainer.bind(this), this.showConfirmModal = !0;
  }
  confirmStopContainer(e) {
    this.selectedContainer = e, this.confirmTitle = "Stop Container", this.confirmMessage = `Are you sure you want to stop container "${e.names.join(", ")}"?`, this.confirmAction = this.stopSelectedContainer.bind(this), this.showConfirmModal = !0;
  }
  confirmRestartContainer(e) {
    this.selectedContainer = e, this.confirmTitle = "Restart Container", this.confirmMessage = `Are you sure you want to restart container "${e.names.join(", ")}"?`, this.confirmAction = this.restartSelectedContainer.bind(this), this.showConfirmModal = !0;
  }
  confirmPauseContainer(e) {
    this.selectedContainer = e, this.confirmTitle = "Pause Container", this.confirmMessage = `Are you sure you want to pause container "${e.names.join(", ")}"?`, this.confirmAction = this.pauseSelectedContainer.bind(this), this.showConfirmModal = !0;
  }
  confirmUnpauseContainer(e) {
    this.selectedContainer = e, this.confirmTitle = "Unpause Container", this.confirmMessage = `Are you sure you want to unpause container "${e.names.join(", ")}"?`, this.confirmAction = this.unpauseSelectedContainer.bind(this), this.showConfirmModal = !0;
  }
  async startSelectedContainer() {
    if (this.selectedContainer)
      try {
        await J.post(`/docker/containers/${this.selectedContainer.id}/start`), this.showConfirmModal = !1, this.fetchContainers(), this.selectedContainer = null;
      } catch (e) {
        console.error("Error starting container:", e);
      }
  }
  async stopSelectedContainer() {
    if (this.selectedContainer)
      try {
        await J.post(`/docker/containers/${this.selectedContainer.id}/stop`), this.showConfirmModal = !1, this.fetchContainers(), this.selectedContainer = null;
      } catch (e) {
        console.error("Error stopping container:", e);
      }
  }
  async restartSelectedContainer() {
    if (this.selectedContainer)
      try {
        await J.post(`/docker/containers/${this.selectedContainer.id}/restart`), this.showConfirmModal = !1, this.fetchContainers(), this.selectedContainer = null;
      } catch (e) {
        console.error("Error restarting container:", e);
      }
  }
  async pauseSelectedContainer() {
    if (this.selectedContainer)
      try {
        await J.post(`/docker/containers/${this.selectedContainer.id}/pause`), this.showConfirmModal = !1, this.fetchContainers(), this.selectedContainer = null;
      } catch (e) {
        console.error("Error pausing container:", e);
      }
  }
  async unpauseSelectedContainer() {
    if (this.selectedContainer)
      try {
        await J.post(`/docker/containers/${this.selectedContainer.id}/unpause`), this.showConfirmModal = !1, this.fetchContainers(), this.selectedContainer = null;
      } catch (e) {
        console.error("Error unpausing container:", e);
      }
  }
  async showContainerLogs(e) {
    try {
      this.logsError = null, this.containerLogs = "Loading logs...", this.showLogsDrawer = !0;
      const t = await J.get(`/docker/containers/${e.id}/logs`);
      this.containerLogs = t.logs || "No logs available";
    } catch (t) {
      console.error("Error fetching container logs:", t), this.logsError = t instanceof De ? t.message : "Failed to fetch logs";
    }
  }
  async fetchContainerDetails(e) {
    try {
      this.detailError = null;
      const t = await J.get(`/docker/containers/${e}`);
      this.selectedContainer = t.container || t, this.selectedImage = null, this.showDrawer = !0;
    } catch (t) {
      console.error("Error fetching container details:", t), this.detailError = t instanceof De ? t.message : "Failed to fetch container details", this.selectedContainer = null, this.selectedImage = null, this.showDrawer = !0;
    }
  }
  // Helper methods
  getStatusClass(e) {
    switch (e.toLowerCase()) {
      case "running":
        return "running";
      case "stopped":
      case "exited":
        return "stopped";
      case "paused":
        return "paused";
      case "created":
        return "stopped";
      default:
        return "stopped";
    }
  }
  truncateText(e, t) {
    return e.length <= t ? e : e.substring(0, t) + "...";
  }
  renderContainerDetails() {
    if (!this.selectedContainer) return D``;
    const e = this.selectedContainer;
    return D`
      <div class="drawer-content">
        <div class="detail-section">
          <h3>Container Details</h3>
          <div class="detail-item">
            <span class="detail-label">Name</span>
            <span class="detail-value">${e.names.join(", ") || "Unnamed"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">ID</span>
            <span class="detail-value monospace">${e.id || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Image</span>
            <span class="detail-value">${e.image || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">State</span>
            <span class="detail-value">
              <span class="status-badge ${this.getStatusClass(e.state)}">${e.state}</span>
            </span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Status</span>
            <span class="detail-value">${e.status || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Command</span>
            <span class="detail-value monospace">${e.command || "Unknown"}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Created</span>
            <span class="detail-value">${e.created ? new Date(e.created).toLocaleString() : "Unknown"}</span>
          </div>
        </div>

        ${e.labels && Object.keys(e.labels).length > 0 ? D`
          <div class="detail-section">
            <h3>Labels</h3>
            <div class="tag-list">
              ${Object.entries(e.labels).map(([t, i]) => D`<div class="tag">${t}: ${i}</div>`)}
            </div>
          </div>
        ` : ""}

        ${e.ports && e.ports.length > 0 ? D`
          <div class="detail-section">
            <h3>Ports</h3>
            ${e.ports.map((t) => D`
              <div class="detail-item">
                <span class="detail-value">${t.privatePort}${t.publicPort ? `  ${t.publicPort}` : ""} (${t.type})</span>
              </div>
            `)}
          </div>
        ` : ""}
      </div>
    `;
  }
  renderImageDetails() {
    return D``;
  }
  highlightSearchTerm(e, t) {
    if (!t || !e) return e;
    const i = new RegExp(`(${t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    return e.replace(i, '<mark style="background-color: #ffeb3b; color: #000; padding: 0 2px;">$1</mark>');
  }
  renderError() {
    return D`
      <div class="error-container">
        <div class="error-icon"></div>
        <p class="error-message">${this.detailError}</p>
      </div>
    `;
  }
  // Image action methods
  toggleImageActionsMenu(e) {
    e.stopPropagation(), this.showImageActionsDropdown = !this.showImageActionsDropdown;
  }
  showUploadImageDialog() {
    this.showUploadDrawer = !0;
  }
  async fetchImageDetails(e) {
    try {
      this.detailError = null;
      const t = await J.get(`/docker/images/${e}`);
      this.selectedImage = t.image || t, this.selectedContainer = null, this.showDrawer = !0;
    } catch (t) {
      console.error("Error fetching image details:", t), this.detailError = t instanceof De ? t.message : "Failed to fetch image details", this.selectedContainer = null, this.selectedImage = null, this.showDrawer = !0;
    }
  }
  addToUploadQueue(e) {
    const t = {
      id: crypto.randomUUID(),
      file: e,
      progress: 0,
      status: "pending"
    };
    this.uploadQueue = [...this.uploadQueue, t];
  }
  removeFromUploadQueue(e) {
    this.uploadQueue = this.uploadQueue.filter((t) => t.id !== e);
  }
  async startUpload() {
    const e = this.uploadQueue.filter((t) => t.status === "pending");
    if (e.length !== 0) {
      this.isUploading = !0;
      for (const t of e)
        await this.uploadFile(t);
      this.isUploading = !1;
    }
  }
  async uploadFile(e) {
    try {
      this.updateUploadItem(e.id, { status: "uploading", progress: 0 });
      const t = new FormData();
      t.append("file", e.file);
      const i = setInterval(() => {
        const r = this.uploadQueue.find((n) => n.id === e.id);
        r && r.progress < 90 && this.updateUploadItem(e.id, { progress: r.progress + 10 });
      }, 200);
      await J.post("/docker/images/upload", t), clearInterval(i), this.updateUploadItem(e.id, { status: "completed", progress: 100 }), this.fetchImages();
    } catch (t) {
      console.error("Error uploading file:", t), this.updateUploadItem(e.id, {
        status: "error",
        error: t instanceof De ? t.message : "Upload failed"
      });
    }
  }
  updateUploadItem(e, t) {
    this.uploadQueue = this.uploadQueue.map(
      (i) => i.id === e ? { ...i, ...t } : i
    );
  }
  clearCompletedUploads() {
    this.uploadQueue = this.uploadQueue.filter(
      (e) => e.status !== "completed" && e.status !== "error"
    );
  }
  formatFileSize(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, i = ["Bytes", "KB", "MB", "GB"], r = Math.floor(Math.log(e) / Math.log(t));
    return parseFloat((e / Math.pow(t, r)).toFixed(2)) + " " + i[r];
  }
  // Pull image method
  async handlePullImage() {
    if (this.imageName.trim())
      try {
        await J.post("/docker/images/pull", {
          image: this.imageName.trim()
        }), this.showPullImageModal = !1, this.imageName = "", this.fetchImages();
      } catch (e) {
        console.error("Error pulling image:", e);
      }
  }
};
Va.styles = re`
    :host {
      display: block;
      padding: 16px;
      margin: 0;
    }

    .tab-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .tab-header {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.2s;
    }

    .tab-button:hover {
      color: var(--text-primary);
    }

    .tab-button.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .tab-content {
      flex: 1;
      overflow-y: auto;
    }

    .container {
      background: var(--vscode-bg-light);
      color: var(--vscode-text);
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .container-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .container-info {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }

    .container-actions {
      display: flex;
      gap: 8px;
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--vscode-accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--vscode-accent-hover);
    }

    .btn-danger {
      background: var(--vscode-error);
      color: white;
    }

    .btn-danger:hover {
      opacity: 0.9;
    }

    .size-info {
      font-size: 12px;
      color: var(--vscode-text-dim);
    }

    h1 {
      margin: 0 0 24px 0;
      padding: 0;
      font-size: 24px;
      font-weight: 300;
    }

    h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: var(--text-primary);
    }

    .image {
      background: var(--vscode-bg-light);
      color: var(--vscode-text);
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }

    .image-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .image-info {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }

    .image-actions {
      display: flex;
      gap: 8px;
    }

    .search-container {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .search-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }

    .section-header h2 {
      margin: 0;
    }

    .search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      max-width: 400px;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      color: var(--vscode-input-placeholderForeground, #999);
      pointer-events: none;
      width: 16px;
      height: 16px;
    }

    .search-input {
      padding: 6px 12px 6px 32px;
      border: 1px solid var(--vscode-widget-border, var(--vscode-input-border, var(--vscode-panel-border, #454545)));
      border-radius: 4px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      font-size: 0.875rem;
      width: 250px;
      transition: all 0.2s;
      outline: none;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
    }

    .search-input:hover {
      border-color: var(--vscode-inputOption-hoverBorder, var(--vscode-widget-border, #858585));
    }

    .search-input:focus {
      border-color: var(--vscode-focusBorder, #007acc);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1), 0 0 0 1px var(--vscode-focusBorder, #007acc);
    }

    .search-input::placeholder {
      color: var(--vscode-input-placeholderForeground, #999);
      opacity: 0.7;
    }

    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .error-state {
      text-align: center;
      padding: 3rem;
      color: var(--vscode-error);
      background: var(--vscode-bg-light);
      border-radius: 6px;
      margin: 2rem 0;
    }


    .table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      background: var(--vscode-bg-light);
      border-radius: 1px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .table thead {
      background: var(--vscode-bg-lighter);
    }

    .table th {
      background: var(--vscode-bg-dark);
      color: var(--vscode-text);
      font-weight: 600;
      text-align: left;
      padding: 12px 16px;
      font-size: 0.875rem;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .table td {
      padding: 12px 16px;
      color: var(--vscode-text);
      font-size: 0.875rem;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      position: relative;
    }

    .table td:last-child {
      text-align: right;
    }

    .table tr:last-child td {
      border-bottom: none;
    }

    .table tr:hover td {
      background: rgba(255, 255, 255, 0.02);
    }

    .table td button {
      margin-right: 8px;
    }

    .table td button:last-child {
      margin-right: 0;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .status-icon {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      position: relative;
    }

    .status-icon.running {
      background-color: #4caf50;
      box-shadow: 0 0 4px #4caf50;
    }

    .status-icon.stopped {
      background-color: #9e9e9e;
    }

    .status-icon.paused {
      background-color: #ff9800;
    }

    .status-icon.exited {
      background-color: #f44336;
    }

    .status-icon[data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      padding: 6px 12px;
      background-color: var(--vscode-editorWidget-background, var(--vscode-dropdown-background, #252526));
      color: var(--vscode-editorWidget-foreground, var(--vscode-foreground, #cccccc));
      border: 1px solid var(--vscode-editorWidget-border, var(--vscode-widget-border, #454545));
      border-radius: 4px;
      font-size: 14px;
      white-space: nowrap;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .truncate {
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
      position: relative;
    }

    .truncate[title]:hover::after {
      content: attr(title);
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 4px;
      padding: 6px 12px;
      background-color: var(--vscode-editorWidget-background, var(--vscode-dropdown-background, #252526));
      color: var(--vscode-editorWidget-foreground, var(--vscode-foreground, #cccccc));
      border: 1px solid var(--vscode-editorWidget-border, var(--vscode-widget-border, #454545));
      border-radius: 4px;
      font-size: 14px;
      white-space: nowrap;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      pointer-events: none;
    }

    .action-menu {
      position: relative;
      display: inline-block;
    }

    .action-dots {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      color: var(--text-secondary);
      font-size: 18px;
      line-height: 1;
      transition: background-color 0.2s;
      border-radius: 4px;
    }

    .action-dots:hover {
      background-color: var(--vscode-toolbar-hoverBackground, var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.1)));
    }

    .action-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--vscode-dropdown-background, var(--vscode-menu-background, var(--vscode-bg-light, #252526)));
      border: 1px solid var(--vscode-dropdown-border, var(--vscode-menu-border, var(--border-color, #454545)));
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 160px;
      z-index: 1000;
      display: none;
    }

    .action-dropdown.show {
      display: block;
    }

    .action-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 16px;
      border: none;
      background: none;
      color: var(--vscode-menu-foreground, var(--vscode-foreground, var(--vscode-text, #cccccc)));
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .action-dropdown button:hover {
      background-color: var(--vscode-list-hoverBackground, var(--vscode-toolbar-hoverBackground, rgba(255, 255, 255, 0.08)));
      color: var(--vscode-list-hoverForeground, var(--vscode-foreground));
    }

    .action-dropdown button.danger {
      color: var(--vscode-error);
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--vscode-accent, #007acc);
      color: white;
    }

    .btn-primary:hover {
      background: var(--vscode-accent-hover, #005a9e);
    }

    .btn-secondary {
      background: var(--vscode-button-secondary-bg, #3c3c3c);
      color: var(--vscode-button-secondary-foreground, #cccccc);
      border: 1px solid var(--vscode-button-secondary-border, #5a5a5a);
    }

    .btn-secondary:hover {
      background: var(--vscode-button-secondary-hover-bg, #484848);
    }

    a {
      color: var(--vscode-textLink-foreground, #3794ff);
      text-decoration: none;
      cursor: pointer;
    }

    a:hover {
      text-decoration: underline;
    }

    /* Link-style buttons for clickable items */
    button.link-button,
    td button {
      background: none;
      border: none;
      color: var(--vscode-textLink-foreground, #3794ff);
      cursor: pointer;
      font-size: inherit;
      font-family: inherit;
      text-align: left;
      padding: 0;
      text-decoration: none;
      transition: text-decoration 0.2s;
    }

    button.link-button:hover,
    td button:hover {
      text-decoration: underline;
    }

    td button:focus {
      outline: 1px solid var(--vscode-focusBorder, #007acc);
      outline-offset: 2px;
    }

    .drawer {
      position: fixed;
      top: 0;
      right: 0;
      width: 50%;
      height: 100%;
      background: var(--vscode-bg-light);
      border-left: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      overflow-y: auto;
      padding: 24px;
      animation: slideIn 0.3s ease-out;
    }

    /* Make drawer full width on smaller screens */
    @media (max-width: 1024px) {
      .drawer {
        width: 80%;
      }
    }

    @media (max-width: 768px) {
      .drawer {
        width: 100%;
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
      }
      to {
        transform: translateX(0);
      }
    }

    .drawer h2 {
      margin-top: 0;
    }

    .drawer pre {
      background: var(--vscode-bg-dark);
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      border-radius: 4px;
      padding: 16px;
      overflow-x: auto;
      font-size: 0.875rem;
      color: var(--vscode-text);
    }

    .drawer button.close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      background: var(--vscode-toolbar-hoverBackground, rgba(90, 93, 94, 0.1));
      color: var(--vscode-foreground, var(--vscode-editor-foreground));
      border: 1px solid var(--vscode-widget-border, rgba(0, 0, 0, 0.1));
      transition: all 0.2s;
    }

    .drawer button.close-btn:hover {
      background: var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.2));
      border-color: var(--vscode-widget-border, rgba(0, 0, 0, 0.2));
    }

    .drawer button.close-btn:active {
      background: var(--vscode-list-activeSelectionBackground, rgba(90, 93, 94, 0.3));
    }

    .drawer button.close-btn:focus {
      outline: 1px solid var(--vscode-focusBorder, #007acc);
      outline-offset: 2px;
    }

    .drawer-content {
      margin-top: 40px;
    }

    .detail-section {
      margin-bottom: 24px;
    }

    .detail-section h3 {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-primary);
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      padding-bottom: 8px;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      margin-bottom: 12px;
    }

    .detail-label {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      margin-bottom: 4px;
      font-weight: 500;
    }

    .detail-value {
      font-size: 0.875rem;
      color: var(--vscode-text);
      word-break: break-word;
    }

    .detail-value.monospace {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      background: var(--vscode-textCodeBlock-background, rgba(255, 255, 255, 0.04));
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 0.8125rem;
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tag {
      background: var(--vscode-badge-background);
      color: var(--vscode-badge-foreground);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .status-badge.running {
      background: rgba(76, 175, 80, 0.1);
      color: #4caf50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .status-badge.stopped {
      background: rgba(158, 158, 158, 0.1);
      color: #9e9e9e;
      border: 1px solid rgba(158, 158, 158, 0.3);
    }

    .status-badge.paused {
      background: rgba(255, 152, 0, 0.1);
      color: #ff9800;
      border: 1px solid rgba(255, 152, 0, 0.3);
    }

    .status-badge.exited {
      background: rgba(244, 67, 54, 0.1);
      color: #f44336;
      border: 1px solid rgba(244, 67, 54, 0.3);
    }

    .error-container {
      padding: 40px 20px;
      text-align: center;
    }

    .error-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.7;
    }

    .error-message {
      color: var(--vscode-errorForeground, #f48771);
      font-size: 14px;
      line-height: 1.5;
      margin: 0;
    }

    .logs-container {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.5;
      background: var(--vscode-editor-background, #1e1e1e);
      color: var(--vscode-editor-foreground, #d4d4d4);
      padding: 16px;
      border-radius: 4px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .logs-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    /* Upload drawer styles */
    .upload-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .upload-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .upload-zone {
      border: 2px dashed var(--vscode-widget-border, #454545);
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 24px;
      transition: all 0.2s;
      cursor: pointer;
    }

    .upload-zone:hover {
      border-color: var(--vscode-focusBorder, #007acc);
      background: rgba(0, 122, 204, 0.05);
    }

    .upload-zone.dragover {
      border-color: var(--vscode-focusBorder, #007acc);
      background: rgba(0, 122, 204, 0.1);
    }

    .upload-icon {
      font-size: 48px;
      margin-bottom: 16px;
      color: var(--vscode-descriptionForeground, #999);
    }

    .upload-text {
      font-size: 16px;
      margin-bottom: 8px;
      color: var(--vscode-foreground);
    }

    .upload-hint {
      font-size: 14px;
      color: var(--vscode-descriptionForeground, #999);
    }

    .upload-queue {
      margin-top: 24px;
    }

    .upload-item {
      background: var(--vscode-bg-dark);
      border: 1px solid var(--vscode-widget-border, #454545);
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 12px;
    }

    .upload-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .upload-item-name {
      font-weight: 500;
      color: var(--vscode-foreground);
      flex: 1;
      margin-right: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .upload-item-size {
      font-size: 12px;
      color: var(--vscode-descriptionForeground, #999);
      margin-right: 12px;
    }

    .upload-item-status {
      font-size: 12px;
      font-weight: 500;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .upload-item-status.pending {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
    }

    .upload-item-status.uploading {
      background: rgba(0, 122, 204, 0.2);
      color: #007acc;
    }

    .upload-item-status.completed {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
    }

    .upload-item-status.error {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--vscode-widget-border, #454545);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: var(--vscode-focusBorder, #007acc);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .progress-fill.completed {
      background: #4caf50;
    }

    .progress-fill.error {
      background: #f44336;
    }

    .progress-text {
      font-size: 12px;
      color: var(--vscode-descriptionForeground, #999);
      display: flex;
      justify-content: space-between;
    }

    .upload-error {
      color: var(--vscode-errorForeground, #f48771);
      font-size: 12px;
      margin-top: 4px;
    }

    .upload-actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--vscode-widget-border, #454545);
    }

    .hidden-file-input {
      display: none;
    }
  `;
let pe = Va;
we([
  B()
], pe.prototype, "activeTab");
we([
  B()
], pe.prototype, "containers");
we([
  B()
], pe.prototype, "images");
we([
  B()
], pe.prototype, "volumes");
we([
  B()
], pe.prototype, "networks");
we([
  B()
], pe.prototype, "searchTerm");
we([
  B()
], pe.prototype, "error");
we([
  B()
], pe.prototype, "showConfirmModal");
we([
  B()
], pe.prototype, "confirmAction");
we([
  B()
], pe.prototype, "selectedContainer");
we([
  B()
], pe.prototype, "selectedImage");
we([
  B()
], pe.prototype, "showDrawer");
we([
  B()
], pe.prototype, "detailError");
we([
  B()
], pe.prototype, "confirmTitle");
we([
  B()
], pe.prototype, "confirmMessage");
we([
  B()
], pe.prototype, "showLogsDrawer");
we([
  B()
], pe.prototype, "containerLogs");
we([
  B()
], pe.prototype, "logsError");
we([
  B()
], pe.prototype, "logsSearchTerm");
we([
  B()
], pe.prototype, "showImageActionsDropdown");
we([
  B()
], pe.prototype, "showPullImageModal");
we([
  B()
], pe.prototype, "imageName");
we([
  B()
], pe.prototype, "showUploadDrawer");
we([
  B()
], pe.prototype, "uploadQueue");
we([
  B()
], pe.prototype, "isUploading");
customElements.define("docker-tab", pe);
class se {
  // Namespaces
  static async getNamespaces() {
    return (await Z.get("/kubernetes/namespaces")).namespaces || [];
  }
  // Workloads
  static async getPods(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/pods", t)).pods || [];
  }
  static async getDeployments(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/deployments", t)).deployments || [];
  }
  static async getStatefulSets(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/statefulsets", t)).statefulsets || [];
  }
  static async getDaemonSets(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/daemonsets", t)).daemonsets || [];
  }
  static async getJobs(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/jobs", t)).jobs || [];
  }
  static async getCronJobs(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/cronjobs", t)).cronjobs || [];
  }
  // Networks
  static async getServices(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/services", t)).services || [];
  }
  static async getIngresses(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/ingresses", t)).ingresses || [];
  }
  static async getIngressClasses() {
    return (await Z.get("/kubernetes/ingressclasses")).ingressClasses || [];
  }
  static async getNetworkPolicies(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/networkpolicies", t)).networkPolicies || [];
  }
  // CRDs
  static async getCRDs() {
    return (await Z.get("/kubernetes/customresourcedefinitions")).crds || [];
  }
  // Storage
  static async getPersistentVolumes() {
    return (await Z.get("/kubernetes/persistentvolumes")).pvs || [];
  }
  static async getPersistentVolumeClaims(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/persistentvolumeclaims", t)).pvcs || [];
  }
  // Configurations
  static async getConfigMaps(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/configmaps", t)).configmaps || [];
  }
  static async getSecrets(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/secrets", t)).secrets || [];
  }
  // Nodes
  static async getNodes() {
    return (await Z.get("/kubernetes/nodes")).nodes || [];
  }
  static async getNodeDetails(e) {
    return Z.get(`/kubernetes/nodes/${e}`);
  }
  // Custom Resources
  static async getCustomResources(e, t, i) {
    const r = { apiVersion: e, kind: t };
    return i && i !== "all" && (r.namespace = i), (await Z.get("/kubernetes/customresources", r)).items || [];
  }
  // Helm
  static async getHelmReleases(e) {
    const t = e && e !== "all" ? { namespace: e } : {};
    return (await Z.get("/kubernetes/helm/releases", t)).items || [];
  }
  // Resource Details
  static async getResourceDetails(e, t, i) {
    switch (e.toLowerCase()) {
      case "pod":
        return this.getPodDetails(i, t);
      case "deployment":
        return this.getDeploymentDetails(i, t);
      case "statefulset":
        return this.getStatefulSetDetails(i, t);
      case "daemonset":
        return this.getDaemonSetDetails(i, t);
      case "job":
        return this.getJobDetails(i, t);
      case "cronjob":
        return this.getCronJobDetails(i, t);
      case "service":
        return this.getServiceDetails(i, t);
      case "ingress":
        return this.getIngressDetails(i, t);
      case "ingressclass":
        return this.getIngressClassDetails(t);
      case "networkpolicy":
        return this.getNetworkPolicyDetails(i, t);
      case "crd":
      case "customresourcedefinition":
        return this.getCRDDetails(t);
      case "persistentvolumeclaim":
      case "pvc":
        return this.getPVCDetails(i, t);
      case "persistentvolume":
      case "pv":
        return this.getPVDetails(t);
      case "configmap":
        return this.getConfigMapDetails(i, t);
      case "secret":
        return this.getSecretDetails(i, t);
      default:
        throw new Error(`Unsupported resource kind: ${e}`);
    }
  }
  // Specific detail methods
  static async getPodDetails(e, t) {
    const i = await Z.get(`/kubernetes/pods/${e}/${t}`);
    return i.pod_detail || i;
  }
  static async getDeploymentDetails(e, t) {
    const i = await Z.get(`/kubernetes/deployments/${e}/${t}`);
    return i.deployment_detail || i;
  }
  static async getServiceDetails(e, t) {
    const i = await Z.get(`/kubernetes/services/${e}/${t}`);
    return i.service_detail || i;
  }
  static async getStatefulSetDetails(e, t) {
    const i = await Z.get(`/kubernetes/statefulsets/${e}/${t}`);
    return i.statefulset_detail || i;
  }
  static async getDaemonSetDetails(e, t) {
    const i = await Z.get(`/kubernetes/daemonsets/${e}/${t}`);
    return i.daemonset_detail || i;
  }
  static async getJobDetails(e, t) {
    const i = await Z.get(`/kubernetes/jobs/${e}/${t}`);
    return i.job_detail || i;
  }
  static async getCronJobDetails(e, t) {
    const i = await Z.get(`/kubernetes/cronjobs/${e}/${t}`);
    return i.cronjob_detail || i;
  }
  static async getIngressDetails(e, t) {
    const i = await Z.get(`/kubernetes/ingresses/${e}/${t}`);
    return i.ingress_detail || i;
  }
  static async getIngressClassDetails(e) {
    const t = await Z.get(`/kubernetes/ingressclasses/${e}`);
    return t.ingressclass_detail || t;
  }
  static async getNetworkPolicyDetails(e, t) {
    const i = await Z.get(`/kubernetes/networkpolicies/${e}/${t}`);
    return i.networkpolicy_detail || i;
  }
  static async getCRDDetails(e) {
    const t = await Z.get(`/kubernetes/customresourcedefinitions/${e}`);
    return t.crd || t;
  }
  static async getPVCDetails(e, t) {
    const i = await Z.get(`/kubernetes/pvcs/${e}/${t}`);
    return i.pvc_detail || i;
  }
  static async getPVDetails(e) {
    const t = await Z.get(`/kubernetes/pvs/${e}`);
    return t.pv_detail || t;
  }
  static async getConfigMapDetails(e, t) {
    const i = await Z.get(`/kubernetes/configmaps/${e}/${t}`);
    return i.configmap_detail || i;
  }
  static async getSecretDetails(e, t) {
    const i = await Z.get(`/kubernetes/secrets/${e}/${t}`);
    return i.secret_detail || i;
  }
  // Resource Operations
  static async deleteResource(e, t, i) {
    let r;
    switch (e.toLowerCase()) {
      case "pod":
        r = `/kubernetes/pods/${i}/${t}`;
        break;
      case "deployment":
        r = `/kubernetes/deployments/${i}/${t}`;
        break;
      case "statefulset":
        r = `/kubernetes/statefulsets/${i}/${t}`;
        break;
      case "daemonset":
        r = `/kubernetes/daemonsets/${i}/${t}`;
        break;
      case "job":
        r = `/kubernetes/jobs/${i}/${t}`;
        break;
      case "cronjob":
        r = `/kubernetes/cronjobs/${i}/${t}`;
        break;
      case "service":
        r = `/kubernetes/services/${i}/${t}`;
        break;
      case "ingress":
        r = `/kubernetes/ingresses/${i}/${t}`;
        break;
      case "ingressclass":
        r = `/kubernetes/ingressclasses/${t}`;
        break;
      case "networkpolicy":
        r = `/kubernetes/networkpolicies/${i}/${t}`;
        break;
      case "crd":
      case "customresourcedefinition":
        r = `/kubernetes/customresourcedefinitions/${t}`;
        break;
      case "persistentvolumeclaim":
      case "pvc":
        r = `/kubernetes/pvcs/${i}/${t}`;
        break;
      case "persistentvolume":
      case "pv":
        r = `/kubernetes/pvs/${t}`;
        break;
      case "configmap":
        r = `/kubernetes/configmaps/${i}/${t}`;
        break;
      case "secret":
        r = `/kubernetes/secrets/${i}/${t}`;
        break;
      default:
        throw new Error(`Unsupported resource kind for deletion: ${e}`);
    }
    await Z.delete(r);
  }
  static async createResource(e, t = "yaml") {
    const i = t === "json" ? "application/json" : "application/yaml";
    return Z.postResource("/kubernetes/resource", e, i);
  }
  static async updateResource(e, t, i, r, n = "yaml") {
    const o = n === "json" ? "application/json" : "application/yaml", a = i ? `/kubernetes/resource/${e}/${i}/${t}` : `/kubernetes/resource/${e}/${t}`;
    return Z.postResource(a, r, o);
  }
  // Pod Logs
  static async getPodLogs(e, t, i, r = !1, n = 100) {
    const o = { follow: r, lines: n };
    return i && (o.container = i), (await Z.get(`/kubernetes/pods/${t}/${e}/logs`, o)).logs || "";
  }
  // Exec into Pod
  static async execPod(e, t, i, r) {
    return Z.post(`/kubernetes/pods/${t}/${e}/exec`, { container: i, command: r });
  }
  // CRD Instances
  static async getCRDInstances(e) {
    const t = await Z.get(`/kubernetes/customresourcedefinitions/${e}/instances`);
    if (Array.isArray(t))
      return t;
    if (t && typeof t == "object") {
      if (Array.isArray(t.instances))
        return t.instances;
      if (Array.isArray(t.items))
        return t.items;
      if (Array.isArray(t.resources))
        return t.resources;
    }
    return [];
  }
  static async getCRDInstanceDetails(e, t, i) {
    const r = i ? `/kubernetes/customresourcedefinitions/${e}/instances/${i}/${t}` : `/kubernetes/customresourcedefinitions/${e}/instances/-/${t}`, n = await Z.get(r);
    return n.instance || n;
  }
  static async deleteCRDInstance(e, t, i) {
    const r = i ? `/kubernetes/customresourcedefinitions/${e}/instances/${i}/${t}` : `/kubernetes/customresourcedefinitions/${e}/instances/-/${t}`;
    await Z.delete(r);
  }
}
var Hb = Object.defineProperty, jb = Object.getOwnPropertyDescriptor, mr = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? jb(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Hb(e, t, r), r;
};
let Is = class extends le {
  constructor() {
    super(...arguments), this.value = "", this.placeholder = "Search...", this.width = 250, this.disabled = !1;
  }
  handleInput(s) {
    const e = s.target;
    this.value = e.value, this.dispatchEvent(new CustomEvent("search-change", {
      detail: { value: this.value },
      bubbles: !0,
      composed: !0
    }));
  }
  render() {
    return D`
      <div class="search-wrapper">
        <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>
        <input 
          class="search-input"
          type="text" 
          placeholder="${this.placeholder}"
          .value="${this.value}"
          ?disabled="${this.disabled}"
          @input="${this.handleInput}"
          style="width: ${this.width}px"
        />
      </div>
    `;
  }
};
Is.styles = re`
    .search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      max-width: 400px;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      color: var(--vscode-input-placeholderForeground, #999);
      pointer-events: none;
      width: 16px;
      height: 16px;
    }

    .search-input {
      padding: 6px 12px 6px 32px;
      border: 1px solid var(--vscode-widget-border, var(--vscode-input-border, var(--vscode-panel-border, #454545)));
      border-radius: 4px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      font-size: 0.875rem;
      transition: all 0.2s;
      outline: none;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
    }

    .search-input:hover:not(:disabled) {
      border-color: var(--vscode-inputOption-hoverBorder, var(--vscode-widget-border, #858585));
    }

    .search-input:focus {
      border-color: var(--vscode-focusBorder, #007acc);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1), 0 0 0 1px var(--vscode-focusBorder, #007acc);
    }

    .search-input::placeholder {
      color: var(--vscode-input-placeholderForeground, #999);
      opacity: 0.7;
    }

    .search-input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  `;
mr([
  H({ type: String })
], Is.prototype, "value", 2);
mr([
  H({ type: String })
], Is.prototype, "placeholder", 2);
mr([
  H({ type: Number })
], Is.prototype, "width", 2);
mr([
  H({ type: Boolean })
], Is.prototype, "disabled", 2);
Is = mr([
  me("search-input")
], Is);
var Ub = Object.defineProperty, Wb = Object.getOwnPropertyDescriptor, Tn = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? Wb(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Ub(e, t, r), r;
};
let ci = class extends le {
  constructor() {
    super(...arguments), this.message = "No data available", this.icon = "", this.actionLabel = "";
  }
  handleAction() {
    this.dispatchEvent(new CustomEvent("action-click", {
      bubbles: !0,
      composed: !0
    }));
  }
  render() {
    return D`
      <div class="empty-state">
        <div class="icon">${this.icon}</div>
        <div class="message">${this.message}</div>
        ${this.actionLabel ? D`
          <div class="action">
            <button @click="${this.handleAction}">${this.actionLabel}</button>
          </div>
        ` : ""}
      </div>
    `;
  }
};
ci.styles = re`
    :host {
      display: block;
    }

    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    .message {
      font-size: 1rem;
      margin-bottom: 1rem;
    }

    .action {
      margin-top: 1rem;
    }

    .action button {
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .action button:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }
  `;
Tn([
  H({ type: String })
], ci.prototype, "message", 2);
Tn([
  H({ type: String })
], ci.prototype, "icon", 2);
Tn([
  H({ type: String })
], ci.prototype, "actionLabel", 2);
ci = Tn([
  me("empty-state")
], ci);
var Vb = Object.defineProperty, qb = Object.getOwnPropertyDescriptor, Qh = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? qb(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Vb(e, t, r), r;
};
let gn = class extends le {
  constructor() {
    super(...arguments), this.message = "Loading...";
  }
  render() {
    return D`
      <div class="loading-state">
        <div class="spinner"></div>
        <div>${this.message}</div>
      </div>
    `;
  }
};
gn.styles = re`
    .loading-state {
      text-align: center;
      padding: 20px;
      color: var(--vscode-text);
      font-style: italic;
    }

    .spinner {
      display: inline-block;
      width: 24px;
      height: 24px;
      margin-bottom: 12px;
    }

    .spinner::after {
      content: ' ';
      display: block;
      width: 20px;
      height: 20px;
      margin: 2px;
      border-radius: 50%;
      border: 2px solid var(--vscode-focusBorder, #007acc);
      border-color: var(--vscode-focusBorder, #007acc) transparent var(--vscode-focusBorder, #007acc) transparent;
      animation: spinner 1.2s linear infinite;
    }

    @keyframes spinner {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
  `;
Qh([
  H({ type: String })
], gn.prototype, "message", 2);
gn = Qh([
  me("loading-state")
], gn);
var Kb = Object.defineProperty, Qb = Object.getOwnPropertyDescriptor, Vt = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? Qb(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Kb(e, t, r), r;
};
let yt = class extends le {
  constructor() {
    super(...arguments), this.namespaces = [], this.selectedNamespace = "All Namespaces", this.loading = !1, this.placeholder = "Select namespace", this.showCounts = !1, this.includeAllOption = !0, this.isOpen = !1, this.searchQuery = "", this.handleClickOutside = (s) => {
      this.contains(s.target) || this.closeDropdown();
    };
  }
  render() {
    const s = this.getFilteredNamespaces();
    return D`
      <div class="dropdown" part="dropdown">
        <button
          class="dropdown-toggle ${this.isOpen ? "open" : ""}"
          part="toggle"
          @click=${this.toggleDropdown}
          aria-expanded=${this.isOpen}
          aria-haspopup="listbox"
        >
          <span class="dropdown-label">${this.selectedNamespace}</span>
          <svg class="dropdown-icon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
            <path d="M4 6l4 4 4-4z"/>
          </svg>
        </button>

        ${this.isOpen ? D`
          <div class="dropdown-menu" part="menu" @click=${(e) => e.stopPropagation()}>
            <div class="search-container">
              <input
                type="text"
                class="search-input"
                part="search"
                placeholder="Search namespaces..."
                .value=${this.searchQuery}
                @input=${this.handleSearch}
                @keydown=${this.handleKeydown}
              />
            </div>

            <div class="options-container">
              ${this.loading ? D`
                <div class="loading">Loading namespaces...</div>
              ` : s.length === 0 ? D`
                <div class="no-results">No namespaces found</div>
              ` : D`
                ${this.includeAllOption ? D`
                  <div
                    class="namespace-option ${this.selectedNamespace === "All Namespaces" ? "selected" : ""}"
                    part="option ${this.selectedNamespace === "All Namespaces" ? "option-selected" : ""}"
                    @click=${() => this.selectNamespace("All Namespaces")}
                    role="option"
                    aria-selected=${this.selectedNamespace === "All Namespaces"}
                  >
                    <svg class="namespace-icon" viewBox="0 0 16 16" fill="currentColor">
                      <path d="M8 1a7 7 0 100 14A7 7 0 008 1zM3 8a5 5 0 119.9.3H9v-1h3.8A5 5 0 0111 4.2V8h-1V4.2A5 5 0 018 3a5 5 0 00-5 5z"/>
                    </svg>
                    <span>All Namespaces</span>
                  </div>
                ` : ""}
                ${s.map((e) => D`
                  <div
                    class="namespace-option ${this.selectedNamespace === e.name ? "selected" : ""}"
                    part="option ${this.selectedNamespace === e.name ? "option-selected" : ""}"
                    @click=${() => this.selectNamespace(e.name)}
                    role="option"
                    aria-selected=${this.selectedNamespace === e.name}
                  >
                    <svg class="namespace-icon" viewBox="0 0 16 16" fill="currentColor">
                      <path d="M2 2h12v12H2z" opacity="0.3"/>
                      <path d="M4 4h8v8H4z"/>
                    </svg>
                    <span>${e.name}</span>
                    ${this.showCounts && e.count !== void 0 ? D`
                      <span class="namespace-count">${e.count}</span>
                    ` : ""}
                  </div>
                `)}
              `}
            </div>
          </div>
        ` : ""}
      </div>
    `;
  }
  getFilteredNamespaces() {
    if (!this.searchQuery)
      return this.namespaces;
    const s = this.searchQuery.toLowerCase();
    return this.namespaces.filter(
      (e) => e.name.toLowerCase().includes(s)
    );
  }
  toggleDropdown(s) {
    s.stopPropagation(), this.isOpen = !this.isOpen, this.isOpen ? setTimeout(() => {
      document.addEventListener("click", this.handleClickOutside);
    }, 0) : document.removeEventListener("click", this.handleClickOutside);
  }
  closeDropdown() {
    this.isOpen = !1, this.searchQuery = "", document.removeEventListener("click", this.handleClickOutside);
  }
  handleSearch(s) {
    const e = s.target;
    this.searchQuery = e.value;
  }
  handleKeydown(s) {
    s.key === "Escape" && this.closeDropdown();
  }
  selectNamespace(s) {
    this.selectedNamespace !== s && (this.selectedNamespace = s, this.dispatchEvent(new CustomEvent("namespace-change", {
      detail: { namespace: s },
      bubbles: !0,
      composed: !0
    }))), this.closeDropdown();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("click", this.handleClickOutside);
  }
};
yt.styles = re`
    :host {
      display: inline-block;
      position: relative;
    }

    .dropdown {
      position: relative;
    }

    .dropdown-toggle {
      background: var(--dropdown-bg, #2c2f3a);
      color: var(--dropdown-color, #e0e0e0);
      border: 1px solid var(--dropdown-border, #3a3d4a);
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 200px;
      font-size: 14px;
      transition: all 0.2s;
    }

    .dropdown-toggle:hover {
      background: var(--dropdown-hover-bg, #3a3d4a);
      border-color: var(--dropdown-hover-border, #4a4d5a);
    }

    .dropdown-toggle.open {
      background: var(--dropdown-active-bg, #3a3d4a);
      border-color: var(--dropdown-active-border, var(--vscode-focusBorder, #007acc));
    }

    .dropdown-label {
      flex: 1;
      text-align: left;
    }

    .dropdown-icon {
      transition: transform 0.2s;
    }

    .dropdown-toggle.open .dropdown-icon {
      transform: rotate(180deg);
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      background: var(--menu-bg, #2c2f3a);
      border: 1px solid var(--menu-border, #3a3d4a);
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      max-height: 400px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .search-container {
      padding: 12px;
      border-bottom: 1px solid var(--menu-border, #3a3d4a);
    }

    .search-input {
      width: 100%;
      padding: 8px 12px;
      background: var(--input-bg, #1a1d23);
      color: var(--input-color, #e0e0e0);
      border: 1px solid var(--input-border, #3a3d4a);
      border-radius: 4px;
      font-size: 14px;
      outline: none;
    }

    .search-input:focus {
      border-color: var(--input-focus-border, var(--vscode-focusBorder, #007acc));
    }

    .search-input::placeholder {
      color: var(--input-placeholder, #999);
    }

    .options-container {
      overflow-y: auto;
      max-height: 300px;
    }

    .namespace-option {
      padding: 10px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.2s;
      font-size: 14px;
    }

    .namespace-option:hover {
      background: var(--option-hover-bg, #3a3d4a);
    }

    .namespace-option.selected {
      background: var(--option-selected-bg, var(--vscode-list-activeSelectionBackground, #094771));
      color: var(--option-selected-color, var(--vscode-list-activeSelectionForeground, #fff));
    }

    .namespace-icon {
      width: 16px;
      height: 16px;
      opacity: 0.8;
    }

    .namespace-count {
      margin-left: auto;
      font-size: 12px;
      opacity: 0.7;
      background: var(--count-bg, rgba(255, 255, 255, 0.1));
      padding: 2px 8px;
      border-radius: 12px;
    }

    .no-results {
      padding: 20px;
      text-align: center;
      color: var(--no-results-color, #999);
      font-size: 14px;
    }

    .loading {
      padding: 20px;
      text-align: center;
      color: var(--loading-color, #999);
    }

    /* Scrollbar styling */
    .options-container::-webkit-scrollbar {
      width: 8px;
    }

    .options-container::-webkit-scrollbar-track {
      background: var(--scrollbar-track, #1a1d23);
    }

    .options-container::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb, #4a4d5a);
      border-radius: 4px;
    }

    .options-container::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover, #5a5d6a);
    }
  `;
Vt([
  H({ type: Array })
], yt.prototype, "namespaces", 2);
Vt([
  H({ type: String })
], yt.prototype, "selectedNamespace", 2);
Vt([
  H({ type: Boolean })
], yt.prototype, "loading", 2);
Vt([
  H({ type: String })
], yt.prototype, "placeholder", 2);
Vt([
  H({ type: Boolean })
], yt.prototype, "showCounts", 2);
Vt([
  H({ type: Boolean })
], yt.prototype, "includeAllOption", 2);
Vt([
  B()
], yt.prototype, "isOpen", 2);
Vt([
  B()
], yt.prototype, "searchQuery", 2);
yt = Vt([
  me("namespace-dropdown")
], yt);
var Yb = Object.defineProperty, Gb = Object.getOwnPropertyDescriptor, ba = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? Gb(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Yb(e, t, r), r;
};
let nr = class extends le {
  constructor() {
    super(...arguments), this.tabs = [], this.activeTab = "";
  }
  handleTabClick(s) {
    this.activeTab = s.id, this.dispatchEvent(new CustomEvent("tab-change", {
      detail: { tabId: s.id },
      bubbles: !0,
      composed: !0
    }));
  }
  render() {
    return D`
      <div class="tab-header">
        ${this.tabs.map((s) => D`
          <button 
            class="tab-button ${this.activeTab === s.id ? "active" : ""}"
            @click=${() => this.handleTabClick(s)}
          >
            ${s.icon ? D`<span class="tab-icon">${s.icon}</span>` : ""}
            ${s.label}
          </button>
        `)}
      </div>
    `;
  }
};
nr.styles = re`
    .tab-header {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tab-button:hover {
      color: var(--text-primary);
    }

    .tab-button.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .tab-icon {
      font-size: 1rem;
    }
  `;
ba([
  H({ type: Array })
], nr.prototype, "tabs", 2);
ba([
  H({ type: String })
], nr.prototype, "activeTab", 2);
nr = ba([
  me("tab-group")
], nr);
var Xb = Object.defineProperty, Jb = Object.getOwnPropertyDescriptor, Ln = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? Jb(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Xb(e, t, r), r;
};
let hi = class extends le {
  constructor() {
    super(...arguments), this.actions = [], this.menuId = "", this.isOpen = !1, this.handleOutsideClick = (s) => {
      this.contains(s.target) || (this.isOpen = !1);
    };
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("click", this.handleOutsideClick);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("click", this.handleOutsideClick);
  }
  toggleMenu(s) {
    s.stopPropagation(), this.isOpen = !this.isOpen;
  }
  handleAction(s, e) {
    s.stopPropagation(), !e.disabled && (this.isOpen = !1, this.dispatchEvent(new CustomEvent("action-click", {
      detail: { action: e.action },
      bubbles: !0,
      composed: !0
    })));
  }
  render() {
    return D`
      <button class="action-dots" @click=${this.toggleMenu}></button>
      <div class="action-dropdown ${this.isOpen ? "show" : ""}" id="${this.menuId}">
        ${this.actions.map((s) => D`
          <button 
            class="${s.danger ? "danger" : ""}"
            ?disabled=${s.disabled}
            @click=${(e) => this.handleAction(e, s)}
          >
            ${s.icon ? D`<span class="icon">${s.icon}</span>` : ""}
            ${s.label}
          </button>
        `)}
      </div>
    `;
  }
};
hi.styles = re`
    :host {
      position: relative;
      display: inline-block;
    }

    .action-dots {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      color: var(--text-secondary);
      font-size: 18px;
      line-height: 1;
      transition: background-color 0.2s;
      border-radius: 4px;
    }

    .action-dots:hover {
      background-color: var(--vscode-toolbar-hoverBackground, var(--vscode-list-hoverBackground, rgba(90, 93, 94, 0.1)));
    }

    .action-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--vscode-dropdown-background, var(--vscode-menu-background, var(--vscode-bg-light, #252526)));
      border: 1px solid var(--vscode-dropdown-border, var(--vscode-menu-border, var(--border-color, #454545)));
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 160px;
      z-index: 1000;
      display: none;
    }

    .action-dropdown.show {
      display: block;
    }

    .action-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 16px;
      border: none;
      background: none;
      color: var(--vscode-menu-foreground, var(--vscode-foreground, var(--vscode-text, #cccccc)));
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .action-dropdown button:hover:not(:disabled) {
      background-color: var(--vscode-list-hoverBackground, var(--vscode-toolbar-hoverBackground, rgba(255, 255, 255, 0.08)));
      color: var(--vscode-list-hoverForeground, var(--vscode-foreground));
    }

    .action-dropdown button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .action-dropdown button.danger {
      color: var(--vscode-error);
    }

    .icon {
      margin-right: 8px;
      font-size: 14px;
    }
  `;
Ln([
  H({ type: Array })
], hi.prototype, "actions", 2);
Ln([
  H({ type: String })
], hi.prototype, "menuId", 2);
Ln([
  B()
], hi.prototype, "isOpen", 2);
hi = Ln([
  me("action-dropdown")
], hi);
var Zb = Object.defineProperty, ev = Object.getOwnPropertyDescriptor, va = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? ev(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && Zb(e, t, r), r;
};
let or = class extends le {
  constructor() {
    super(...arguments), this.status = "unknown";
  }
  render() {
    const s = this.text || this.status, e = this.status.toLowerCase();
    return D`
      <span class="status ${e}">${s}</span>
    `;
  }
};
or.styles = re`
    .status {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
      display: inline-block;
    }

    .status.running,
    .status.active,
    .status.deployed,
    .status.bound,
    .status.available,
    .status.ready {
      background-color: rgba(34, 197, 94, 0.1);
      color: rgb(34, 197, 94);
    }

    .status.pending {
      background-color: rgba(251, 191, 36, 0.1);
      color: rgb(251, 191, 36);
    }

    .status.failed,
    .status.error {
      background-color: rgba(239, 68, 68, 0.1);
      color: rgb(239, 68, 68);
    }

    .status.enforced {
      background-color: rgba(59, 130, 246, 0.1);
      color: rgb(59, 130, 246);
    }

    .status.suspended {
      background-color: rgba(156, 163, 175, 0.1);
      color: rgb(156, 163, 175);
    }

    .status.unknown {
      background-color: rgba(107, 114, 128, 0.1);
      color: rgb(107, 114, 128);
    }
  `;
va([
  H({ type: String })
], or.prototype, "status", 2);
va([
  H({ type: String })
], or.prototype, "text", 2);
or = va([
  me("status-badge")
], or);
var tv = Object.defineProperty, sv = Object.getOwnPropertyDescriptor, gi = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? sv(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && tv(e, t, r), r;
};
let as = class extends le {
  constructor() {
    super(...arguments), this.columns = [], this.data = [], this.emptyMessage = "No resources found", this.showActions = !0, this.getActions = null;
  }
  handleCellClick(s, e, t) {
    t.type === "link" && this.dispatchEvent(new CustomEvent("cell-click", {
      detail: { item: e, column: t },
      bubbles: !0,
      composed: !0
    }));
  }
  handleActionClick(s, e) {
    this.dispatchEvent(new CustomEvent("action", {
      detail: { action: s.detail.action, item: e },
      bubbles: !0,
      composed: !0
    }));
  }
  renderCell(s, e) {
    const t = s[e.key];
    switch (e.type) {
      case "status":
        return D`<status-badge status="${(t == null ? void 0 : t.toLowerCase()) || "unknown"}"></status-badge>`;
      case "link":
        return D`
          <span class="link" @click="${(i) => this.handleCellClick(i, s, e)}">
            ${t || "-"}
          </span>
        `;
      case "custom":
        return D`<slot name="cell-${e.key}" .data="${s}"></slot>`;
      default:
        return D`${t || "-"}`;
    }
  }
  render() {
    if (this.data.length === 0)
      return D`<empty-state message="${this.emptyMessage}"></empty-state>`;
    const s = [
      { label: "View Details", action: "view" },
      { label: "Edit", action: "edit" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
    return D`
      <table class="table">
        <thead>
          <tr>
            ${this.columns.map((e) => D`
              <th style="${e.width ? `width: ${e.width}` : ""}">${e.label}</th>
            `)}
            ${this.showActions ? D`<th class="actions-cell">Actions</th>` : ""}
          </tr>
        </thead>
        <tbody>
          ${this.data.map((e, t) => D`
            <tr>
              ${this.columns.map((i) => D`
                <td>${this.renderCell(e, i)}</td>
              `)}
              ${this.showActions ? D`
                <td class="actions-cell">
                  <action-dropdown
                    .actions="${this.getActions ? this.getActions(e) : s}"
                    menuId="menu-${t}"
                    @action-click="${(i) => this.handleActionClick(i, e)}"
                  ></action-dropdown>
                </td>
              ` : ""}
            </tr>
          `)}
        </tbody>
      </table>
    `;
  }
};
as.styles = re`
    .table {
      width: 100%;
      border-collapse: collapse;
      background: var(--vscode-bg-light);
      border-radius: 1px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .table thead {
      background: var(--vscode-bg-lighter);
    }

    .table th {
      background: var(--vscode-bg-dark);
      color: var(--vscode-text);
      font-weight: 600;
      text-align: left;
      padding: 12px 16px;
      font-size: 0.875rem;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    .table td {
      padding: 12px 16px;
      color: var(--vscode-text);
      font-size: 0.875rem;
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      position: relative;
    }

    .table tr:hover td {
      background: rgba(255, 255, 255, 0.02);
    }

    .table tr:last-child td {
      border-bottom: none;
    }

    .table td:last-child {
      text-align: right;
    }

    .link {
      color: var(--vscode-link-foreground, #0096ff);
      cursor: pointer;
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: all 0.2s ease;
    }

    .link:hover {
      color: var(--vscode-link-activeForeground, #0096ff);
      text-decoration: none;
      border-bottom-color: var(--vscode-link-foreground, #0096ff);
    }

    .actions-cell {
      width: 50px;
      text-align: center;
    }
  `;
gi([
  H({ type: Array })
], as.prototype, "columns", 2);
gi([
  H({ type: Array })
], as.prototype, "data", 2);
gi([
  H({ type: String })
], as.prototype, "emptyMessage", 2);
gi([
  H({ type: Boolean })
], as.prototype, "showActions", 2);
gi([
  H({ type: Function })
], as.prototype, "getActions", 2);
as = gi([
  me("resource-table")
], as);
var iv = Object.defineProperty, rv = Object.getOwnPropertyDescriptor, br = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? rv(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && iv(e, t, r), r;
};
let Rs = class extends le {
  constructor() {
    super(...arguments), this.title = "", this.show = !1, this.loading = !1, this.width = 600;
  }
  handleClose() {
    this.dispatchEvent(new CustomEvent("close", {
      bubbles: !0,
      composed: !0
    }));
  }
  render() {
    return this.show ? D`
      <div class="drawer" style="width: ${this.width}px">
        <button class="close-button" @click=${this.handleClose}></button>
        <h2>${this.title}</h2>
        <div class="drawer-content">
          ${this.loading ? D`
            <loading-state message="Loading details..."></loading-state>
          ` : D`
            <slot></slot>
          `}
        </div>
      </div>
    ` : null;
  }
};
Rs.styles = re`
    .drawer {
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      background: var(--vscode-editor-background, var(--vscode-bg-light));
      border-left: 0.5px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      overflow-y: auto;
      padding: 20px;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
      }
      to {
        transform: translateX(0);
      }
    }

    .close-button {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--vscode-text);
      font-size: 18px;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .close-button:hover {
      background-color: var(--hover-bg);
    }

    h2 {
      margin: 0 0 20px 0;
      padding: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--vscode-text);
    }

    .drawer-content {
      font-size: 0.875rem;
    }
  `;
br([
  H({ type: String })
], Rs.prototype, "title", 2);
br([
  H({ type: Boolean })
], Rs.prototype, "show", 2);
br([
  H({ type: Boolean })
], Rs.prototype, "loading", 2);
br([
  H({ type: Number })
], Rs.prototype, "width", 2);
Rs = br([
  me("detail-drawer")
], Rs);
var nv = Object.defineProperty, ov = Object.getOwnPropertyDescriptor, Mn = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? ov(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && nv(e, t, r), r;
};
let di = class extends le {
  constructor() {
    super(...arguments), this.item = null, this.show = !1, this.loading = !1;
  }
  handleOverlayClick(s) {
    s.target === s.currentTarget && !this.loading && this.handleCancel();
  }
  handleConfirm() {
    this.dispatchEvent(new CustomEvent("confirm-delete", {
      detail: { item: this.item },
      bubbles: !0,
      composed: !0
    }));
  }
  handleCancel() {
    this.dispatchEvent(new CustomEvent("cancel-delete", {
      bubbles: !0,
      composed: !0
    }));
  }
  render() {
    return !this.show || !this.item ? "" : D`
      <div class="modal-overlay" @click=${this.handleOverlayClick}>
        <div class="modal">
          <div class="modal-header">
            <span class="modal-icon warning"></span>
            <h3 class="modal-title">Confirm Delete</h3>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to delete this ${this.item.type.toLowerCase()}?</p>
            <div class="modal-resource-info">
              <div><strong>Type:</strong> ${this.item.type}</div>
              <div><strong>Name:</strong> ${this.item.name}</div>
              <div><strong>Namespace:</strong> ${this.item.namespace || "N/A"}</div>
            </div>
            <p><strong>This action cannot be undone.</strong></p>
          </div>
          <div class="modal-footer">
            <button 
              class="modal-button cancel" 
              @click=${this.handleCancel}
              ?disabled=${this.loading}
            >
              Cancel
            </button>
            <button 
              class="modal-button delete" 
              @click=${this.handleConfirm}
              ?disabled=${this.loading}
            >
              ${this.loading ? "Deleting..." : "Delete"}
            </button>
          </div>
        </div>
      </div>
    `;
  }
};
di.styles = re`
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 2000;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 80px;
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .modal {
      background: var(--vscode-editor-background, var(--vscode-bg-light));
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      animation: modalFadeIn 0.3s ease-out;
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal-header {
      display: flex;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-icon {
      font-size: 24px;
      margin-right: 12px;
    }

    .modal-icon.warning {
      color: var(--vscode-notificationsWarningIcon-foreground, #ff9800);
    }

    .modal-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .modal-body {
      margin-bottom: 24px;
      color: var(--vscode-foreground);
      line-height: 1.5;
    }

    .modal-resource-info {
      background: var(--vscode-editor-inactiveSelectionBackground, rgba(255, 255, 255, 0.05));
      border: 1px solid var(--vscode-widget-border, rgba(255, 255, 255, 0.1));
      border-radius: 4px;
      padding: 12px;
      margin: 12px 0;
      font-family: var(--vscode-editor-font-family, monospace);
      font-size: 14px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .modal-button {
      padding: 8px 16px;
      border: 1px solid var(--vscode-button-border, transparent);
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-button.cancel {
      background: var(--vscode-button-secondaryBackground, rgba(255, 255, 255, 0.1));
      color: var(--vscode-button-secondaryForeground, var(--vscode-foreground));
    }

    .modal-button.cancel:hover {
      background: var(--vscode-button-secondaryHoverBackground, rgba(255, 255, 255, 0.15));
    }

    .modal-button.delete {
      background: var(--vscode-notificationsErrorIcon-foreground, #f44336);
      color: white;
      border-color: var(--vscode-notificationsErrorIcon-foreground, #f44336);
    }

    .modal-button.delete:hover {
      background: #d32f2f;
      border-color: #d32f2f;
    }

    .modal-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  `;
Mn([
  H({ type: Object })
], di.prototype, "item", 2);
Mn([
  H({ type: Boolean })
], di.prototype, "show", 2);
Mn([
  H({ type: Boolean })
], di.prototype, "loading", 2);
di = Mn([
  me("delete-modal")
], di);
var av = Object.defineProperty, lv = Object.getOwnPropertyDescriptor, Yh = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? lv(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && av(e, t, r), r;
};
let mn = class extends le {
  constructor() {
    super(...arguments), this.resource = null;
  }
  render() {
    return this.resource ? D`
      ${this.renderMetadata()}
      ${this.renderSpec()}
      ${this.renderStatus()}
      ${this.renderData()}
      ${this.renderAdditionalSections()}
    ` : D`<div class="empty-value">No data available</div>`;
  }
  renderMetadata() {
    const s = this.resource.metadata;
    return s ? D`
      <div class="detail-section">
        <h3 class="section-title">
          <svg class="section-icon" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 1a7 7 0 100 14A7 7 0 008 1zM3 8a5 5 0 1110 0A5 5 0 013 8z"/>
            <path d="M8 4a.5.5 0 01.5.5v3h3a.5.5 0 010 1h-3.5a.5.5 0 01-.5-.5v-3.5A.5.5 0 018 4z"/>
          </svg>
          Metadata
        </h3>
        
        <div class="detail-item">
          <span class="detail-key">Name:</span>
          <span class="detail-value mono">${s.name}</span>
        </div>
        
        ${s.namespace ? D`
          <div class="detail-item">
            <span class="detail-key">Namespace:</span>
            <span class="detail-value mono">${s.namespace}</span>
          </div>
        ` : ""}
        
        ${s.uid ? D`
          <div class="detail-item">
            <span class="detail-key">UID:</span>
            <span class="detail-value mono">${s.uid}</span>
          </div>
        ` : ""}
        
        ${s.resourceVersion ? D`
          <div class="detail-item">
            <span class="detail-key">Resource Version:</span>
            <span class="detail-value mono">${s.resourceVersion}</span>
          </div>
        ` : ""}
        
        ${s.creationTimestamp ? D`
          <div class="detail-item">
            <span class="detail-key">Created:</span>
            <span class="detail-value timestamp">
              ${this.formatTimestamp(s.creationTimestamp)}
            </span>
          </div>
        ` : ""}
        
        ${s.labels && Object.keys(s.labels).length > 0 ? D`
          <div class="detail-item">
            <span class="detail-key">Labels:</span>
            <div class="detail-value">
              <div class="label-container">
                ${Object.entries(s.labels).map(([e, t]) => D`
                  <span class="label-item">
                    <span class="label-key">${e}:</span>
                    ${t}
                  </span>
                `)}
              </div>
            </div>
          </div>
        ` : ""}
        
        ${s.annotations && Object.keys(s.annotations).length > 0 ? D`
          <div class="detail-item">
            <span class="detail-key">Annotations:</span>
            <div class="detail-value">
              <div class="annotation-container">
                ${Object.entries(s.annotations).map(([e, t]) => D`
                  <span class="annotation-item" title="${t}">
                    <span class="annotation-key">${e}:</span>
                    ${this.truncateString(t, 50)}
                  </span>
                `)}
              </div>
            </div>
          </div>
        ` : ""}
      </div>
    ` : null;
  }
  renderSpec() {
    const s = this.resource.spec;
    return !s || Object.keys(s).length === 0 ? null : D`
      <div class="detail-section">
        <h3 class="section-title">
          <svg class="section-icon" viewBox="0 0 16 16" fill="currentColor">
            <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 01-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 01.872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 012.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 012.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 01.872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 01-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 01-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 100-5.86 2.929 2.929 0 000 5.858z"/>
          </svg>
          Specification
        </h3>
        ${this.renderObject(s)}
      </div>
    `;
  }
  renderStatus() {
    const s = this.resource.status;
    return !s || Object.keys(s).length === 0 ? null : D`
      <div class="detail-section">
        <h3 class="section-title">
          <svg class="section-icon" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 16A8 8 0 108 0a8 8 0 000 16zm.93-9.412l-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 110-2 1 1 0 010 2z"/>
          </svg>
          Status
        </h3>
        ${this.renderObject(s, !0)}
      </div>
    `;
  }
  renderData() {
    const s = this.resource.data;
    return !s || Object.keys(s).length === 0 ? null : D`
      <div class="detail-section">
        <h3 class="section-title">
          <svg class="section-icon" viewBox="0 0 16 16" fill="currentColor">
            <path d="M14 4.5V14a2 2 0 01-2 2H4a2 2 0 01-2-2V2a2 2 0 012-2h5.5L14 4.5zm-3 0A1.5 1.5 0 019.5 3V1H4a1 1 0 00-1 1v12a1 1 0 001 1h8a1 1 0 001-1V4.5h-2z"/>
            <path d="M4.5 12.5A.5.5 0 015 12h3a.5.5 0 010 1H5a.5.5 0 01-.5-.5zm0-2A.5.5 0 015 10h6a.5.5 0 010 1H5a.5.5 0 01-.5-.5zm0-2A.5.5 0 015 8h6a.5.5 0 010 1H5a.5.5 0 01-.5-.5zm0-2A.5.5 0 015 6h3a.5.5 0 010 1H5a.5.5 0 01-.5-.5z"/>
          </svg>
          Data
        </h3>
        ${this.renderObject(s)}
      </div>
    `;
  }
  renderAdditionalSections() {
    const s = ["metadata", "spec", "status", "data", "kind", "apiVersion"], e = [];
    return Object.entries(this.resource).forEach(([t, i]) => {
      !s.includes(t) && i && typeof i == "object" && e.push(D`
          <div class="detail-section">
            <h3 class="section-title">${this.formatKey(t)}</h3>
            ${this.renderObject(i)}
          </div>
        `);
    }), e;
  }
  renderObject(s, e = !1) {
    if (!s || typeof s != "object") {
      const i = this.renderValue(s);
      return typeof i == "string" ? D`${i}` : i;
    }
    const t = Object.entries(s);
    return t.length === 0 ? D`<span class="empty-value">Empty</span>` : D`
      ${t.map(([i, r]) => this.renderProperty(i, r, e))}
    `;
  }
  renderProperty(s, e, t = !1) {
    const i = this.formatKey(s);
    return s === "conditions" && Array.isArray(e) ? this.renderConditions(e) : Array.isArray(e) ? D`
        <div class="detail-item">
          <span class="detail-key">${i}:</span>
          <div class="detail-value">
            ${e.length === 0 ? D`
              <span class="empty-value">Empty array</span>
            ` : D`
              <div class="array-container">
                ${e.map((r, n) => D`
                  <div class="array-item">
                    <span class="array-index">[${n}]</span>
                    ${typeof r == "object" ? this.renderObject(r) : this.renderValue(r)}
                  </div>
                `)}
              </div>
            `}
          </div>
        </div>
      ` : e && typeof e == "object" ? D`
        <div class="detail-item">
          <span class="detail-key">${i}:</span>
          <div class="detail-value">
            <div class="nested-object">
              ${this.renderObject(e)}
            </div>
          </div>
        </div>
      ` : t && (s === "phase" || s === "state" || s === "status") ? D`
        <div class="detail-item">
          <span class="detail-key">${i}:</span>
          <span class="detail-value">
            <span class="status-badge ${e.toString().toLowerCase()}">${e}</span>
          </span>
        </div>
      ` : D`
      <div class="detail-item">
        <span class="detail-key">${i}:</span>
        <span class="detail-value ${this.getValueClass(e)}">${this.renderValue(e)}</span>
      </div>
    `;
  }
  renderConditions(s) {
    return D`
      <div class="detail-item">
        <span class="detail-key">Conditions:</span>
        <div class="detail-value">
          <div class="array-container">
            ${s.map((e) => D`
              <div class="array-item">
                <div class="detail-item">
                  <span class="detail-key">Type:</span>
                  <span class="detail-value">${e.type}</span>
                </div>
                <div class="detail-item">
                  <span class="detail-key">Status:</span>
                  <span class="detail-value">
                    <span class="status-badge ${e.status.toLowerCase()}">${e.status}</span>
                  </span>
                </div>
                ${e.reason ? D`
                  <div class="detail-item">
                    <span class="detail-key">Reason:</span>
                    <span class="detail-value">${e.reason}</span>
                  </div>
                ` : ""}
                ${e.message ? D`
                  <div class="detail-item">
                    <span class="detail-key">Message:</span>
                    <span class="detail-value">${e.message}</span>
                  </div>
                ` : ""}
                ${e.lastTransitionTime ? D`
                  <div class="detail-item">
                    <span class="detail-key">Last Transition:</span>
                    <span class="detail-value timestamp">
                      ${this.formatTimestamp(e.lastTransitionTime)}
                    </span>
                  </div>
                ` : ""}
              </div>
            `)}
          </div>
        </div>
      </div>
    `;
  }
  renderValue(s) {
    return s == null ? D`<span class="value-null">null</span>` : typeof s == "boolean" ? D`<span class="value-boolean">${s}</span>` : typeof s == "number" ? D`<span class="value-number">${s}</span>` : typeof s == "string" ? this.isTimestamp(s) ? D`<span class="timestamp">${this.formatTimestamp(s)}</span>` : s.includes(`
`) ? D`<div class="code-block">${s}</div>` : s : JSON.stringify(s);
  }
  getValueClass(s) {
    return s == null ? "value-null" : typeof s == "boolean" ? "value-boolean" : typeof s == "number" ? "value-number" : typeof s == "string" ? "value-string" : "";
  }
  formatKey(s) {
    return s.replace(/([A-Z])/g, " $1").replace(/_/g, " ").replace(/^./, (e) => e.toUpperCase()).trim();
  }
  formatTimestamp(s) {
    const e = new Date(s), i = (/* @__PURE__ */ new Date()).getTime() - e.getTime();
    if (i < 24 * 60 * 60 * 1e3) {
      const r = Math.floor(i / 36e5), n = Math.floor(i % (60 * 60 * 1e3) / (60 * 1e3));
      return r > 0 ? `${r}h ${n}m ago (${e.toLocaleString()})` : n > 0 ? `${n}m ago (${e.toLocaleString()})` : `Just now (${e.toLocaleString()})`;
    }
    return e.toLocaleString();
  }
  isTimestamp(s) {
    return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(s);
  }
  truncateString(s, e) {
    return s.length <= e ? s : s.substring(0, e) + "...";
  }
};
mn.styles = re`
    :host {
      display: block;
      font-family: var(--vscode-font-family, system-ui, -apple-system, sans-serif);
      font-size: 13px;
      color: var(--vscode-foreground, #cccccc);
    }

    .detail-section {
      margin-bottom: 24px;
      border-bottom: 1px solid var(--vscode-widget-border, #303031);
      padding-bottom: 16px;
    }

    .detail-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--vscode-foreground, #cccccc);
      margin-bottom: 12px;
      text-transform: capitalize;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-icon {
      width: 16px;
      height: 16px;
      opacity: 0.8;
    }

    .detail-item {
      margin-bottom: 8px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      line-height: 1.5;
    }

    .detail-key {
      font-weight: 500;
      color: var(--vscode-textLink-foreground, #3794ff);
      min-width: 140px;
      flex-shrink: 0;
    }

    .detail-value {
      flex: 1;
      color: var(--vscode-foreground, #cccccc);
      word-break: break-word;
    }

    .detail-value.mono {
      font-family: var(--vscode-editor-font-family, 'Consolas', 'Monaco', monospace);
      font-size: 12px;
    }

    /* Nested object styles */
    .nested-object {
      margin-top: 8px;
      padding-left: 16px;
      border-left: 2px solid var(--vscode-widget-border, #303031);
    }

    .nested-title {
      font-weight: 500;
      color: var(--vscode-textLink-foreground, #3794ff);
      margin-bottom: 8px;
      font-size: 12px;
      text-transform: capitalize;
    }

    /* Array styles */
    .array-container {
      margin-top: 8px;
    }

    .array-item {
      background: var(--vscode-editor-background, #1e1e1e);
      border: 1px solid var(--vscode-widget-border, #303031);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 8px;
      position: relative;
    }

    .array-item:last-child {
      margin-bottom: 0;
    }

    .array-index {
      position: absolute;
      top: 4px;
      right: 8px;
      font-size: 11px;
      color: var(--vscode-descriptionForeground, #cccccc80);
      background: var(--vscode-badge-background, #007acc);
      padding: 2px 6px;
      border-radius: 10px;
    }

    /* Special value styles */
    .value-null {
      color: var(--vscode-debugTokenExpression-error, #f48771);
      font-style: italic;
    }

    .value-boolean {
      color: var(--vscode-debugTokenExpression-boolean, #4e94ce);
    }

    .value-number {
      color: var(--vscode-debugTokenExpression-number, #b5cea8);
    }

    .value-string {
      color: var(--vscode-debugTokenExpression-string, #ce9178);
    }

    /* Labels and annotations */
    .label-container,
    .annotation-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .label-item,
    .annotation-item {
      background: var(--vscode-badge-background, #007acc);
      color: var(--vscode-badge-foreground, white);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .annotation-item {
      background: var(--vscode-textBlockQuote-background, #7f7f7f1a);
      color: var(--vscode-foreground, #cccccc);
    }

    .label-key,
    .annotation-key {
      opacity: 0.8;
    }

    /* Status badges */
    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
    }

    .status-badge.running,
    .status-badge.active,
    .status-badge.true {
      background: var(--vscode-testing-iconPassed, #73c991);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.pending,
    .status-badge.progressing {
      background: var(--vscode-testing-iconQueued, #cca700);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.failed,
    .status-badge.error,
    .status-badge.false {
      background: var(--vscode-testing-iconFailed, #f14c4c);
      color: white;
    }

    /* Timestamp */
    .timestamp {
      color: var(--vscode-descriptionForeground, #cccccc80);
      font-size: 12px;
    }

    /* Code block */
    .code-block {
      background: var(--vscode-textCodeBlock-background, #0a0a0a);
      border: 1px solid var(--vscode-widget-border, #303031);
      border-radius: 4px;
      padding: 12px;
      margin-top: 8px;
      font-family: var(--vscode-editor-font-family, monospace);
      font-size: 12px;
      overflow-x: auto;
      white-space: pre-wrap;
    }

    /* Collapsible sections */
    .collapsible {
      cursor: pointer;
      user-select: none;
    }

    .collapsible:hover {
      opacity: 0.8;
    }

    .collapse-icon {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 4px;
      transition: transform 0.2s;
    }

    .collapsed .collapse-icon {
      transform: rotate(-90deg);
    }

    .collapsed-content {
      display: none;
    }

    /* Empty state */
    .empty-value {
      color: var(--vscode-descriptionForeground, #cccccc80);
      font-style: italic;
    }
  `;
Yh([
  H({ type: Object })
], mn.prototype, "resource", 2);
mn = Yh([
  me("resource-detail-view")
], mn);
const _a = Symbol.for("yaml.alias"), Wo = Symbol.for("yaml.document"), rs = Symbol.for("yaml.map"), Gh = Symbol.for("yaml.pair"), Mt = Symbol.for("yaml.scalar"), mi = Symbol.for("yaml.seq"), pt = Symbol.for("yaml.node.type"), hs = (s) => !!s && typeof s == "object" && s[pt] === _a, Us = (s) => !!s && typeof s == "object" && s[pt] === Wo, bi = (s) => !!s && typeof s == "object" && s[pt] === rs, Se = (s) => !!s && typeof s == "object" && s[pt] === Gh, ge = (s) => !!s && typeof s == "object" && s[pt] === Mt, vi = (s) => !!s && typeof s == "object" && s[pt] === mi;
function $e(s) {
  if (s && typeof s == "object")
    switch (s[pt]) {
      case rs:
      case mi:
        return !0;
    }
  return !1;
}
function Ae(s) {
  if (s && typeof s == "object")
    switch (s[pt]) {
      case _a:
      case rs:
      case Mt:
      case mi:
        return !0;
    }
  return !1;
}
const Xh = (s) => (ge(s) || $e(s)) && !!s.anchor, nt = Symbol("break visit"), Jh = Symbol("skip children"), Et = Symbol("remove node");
function Ws(s, e) {
  const t = Zh(e);
  Us(s) ? Js(null, s.contents, t, Object.freeze([s])) === Et && (s.contents = null) : Js(null, s, t, Object.freeze([]));
}
Ws.BREAK = nt;
Ws.SKIP = Jh;
Ws.REMOVE = Et;
function Js(s, e, t, i) {
  const r = ed(s, e, t, i);
  if (Ae(r) || Se(r))
    return td(s, i, r), Js(s, r, t, i);
  if (typeof r != "symbol") {
    if ($e(e)) {
      i = Object.freeze(i.concat(e));
      for (let n = 0; n < e.items.length; ++n) {
        const o = Js(n, e.items[n], t, i);
        if (typeof o == "number")
          n = o - 1;
        else {
          if (o === nt)
            return nt;
          o === Et && (e.items.splice(n, 1), n -= 1);
        }
      }
    } else if (Se(e)) {
      i = Object.freeze(i.concat(e));
      const n = Js("key", e.key, t, i);
      if (n === nt)
        return nt;
      n === Et && (e.key = null);
      const o = Js("value", e.value, t, i);
      if (o === nt)
        return nt;
      o === Et && (e.value = null);
    }
  }
  return r;
}
async function In(s, e) {
  const t = Zh(e);
  Us(s) ? await Zs(null, s.contents, t, Object.freeze([s])) === Et && (s.contents = null) : await Zs(null, s, t, Object.freeze([]));
}
In.BREAK = nt;
In.SKIP = Jh;
In.REMOVE = Et;
async function Zs(s, e, t, i) {
  const r = await ed(s, e, t, i);
  if (Ae(r) || Se(r))
    return td(s, i, r), Zs(s, r, t, i);
  if (typeof r != "symbol") {
    if ($e(e)) {
      i = Object.freeze(i.concat(e));
      for (let n = 0; n < e.items.length; ++n) {
        const o = await Zs(n, e.items[n], t, i);
        if (typeof o == "number")
          n = o - 1;
        else {
          if (o === nt)
            return nt;
          o === Et && (e.items.splice(n, 1), n -= 1);
        }
      }
    } else if (Se(e)) {
      i = Object.freeze(i.concat(e));
      const n = await Zs("key", e.key, t, i);
      if (n === nt)
        return nt;
      n === Et && (e.key = null);
      const o = await Zs("value", e.value, t, i);
      if (o === nt)
        return nt;
      o === Et && (e.value = null);
    }
  }
  return r;
}
function Zh(s) {
  return typeof s == "object" && (s.Collection || s.Node || s.Value) ? Object.assign({
    Alias: s.Node,
    Map: s.Node,
    Scalar: s.Node,
    Seq: s.Node
  }, s.Value && {
    Map: s.Value,
    Scalar: s.Value,
    Seq: s.Value
  }, s.Collection && {
    Map: s.Collection,
    Seq: s.Collection
  }, s) : s;
}
function ed(s, e, t, i) {
  var r, n, o, a, l;
  if (typeof t == "function")
    return t(s, e, i);
  if (bi(e))
    return (r = t.Map) == null ? void 0 : r.call(t, s, e, i);
  if (vi(e))
    return (n = t.Seq) == null ? void 0 : n.call(t, s, e, i);
  if (Se(e))
    return (o = t.Pair) == null ? void 0 : o.call(t, s, e, i);
  if (ge(e))
    return (a = t.Scalar) == null ? void 0 : a.call(t, s, e, i);
  if (hs(e))
    return (l = t.Alias) == null ? void 0 : l.call(t, s, e, i);
}
function td(s, e, t) {
  const i = e[e.length - 1];
  if ($e(i))
    i.items[s] = t;
  else if (Se(i))
    s === "key" ? i.key = t : i.value = t;
  else if (Us(i))
    i.contents = t;
  else {
    const r = hs(i) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${r} parent`);
  }
}
const cv = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, hv = (s) => s.replace(/[!,[\]{}]/g, (e) => cv[e]);
class Ze {
  constructor(e, t) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Ze.defaultYaml, e), this.tags = Object.assign({}, Ze.defaultTags, t);
  }
  clone() {
    const e = new Ze(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Ze(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Ze.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Ze.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, t) {
    this.atNextDocument && (this.yaml = { explicit: Ze.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Ze.defaultTags), this.atNextDocument = !1);
    const i = e.trim().split(/[ \t]+/), r = i.shift();
    switch (r) {
      case "%TAG": {
        if (i.length !== 2 && (t(0, "%TAG directive should contain exactly two parts"), i.length < 2))
          return !1;
        const [n, o] = i;
        return this.tags[n] = o, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, i.length !== 1)
          return t(0, "%YAML directive should contain exactly one part"), !1;
        const [n] = i;
        if (n === "1.1" || n === "1.2")
          return this.yaml.version = n, !0;
        {
          const o = /^\d+\.\d+$/.test(n);
          return t(6, `Unsupported YAML version ${n}`, o), !1;
        }
      }
      default:
        return t(0, `Unknown directive ${r}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, t) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return t(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const o = e.slice(2, -1);
      return o === "!" || o === "!!" ? (t(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && t("Verbatim tags must end with a >"), o);
    }
    const [, i, r] = e.match(/^(.*!)([^!]*)$/s);
    r || t(`The ${e} tag has no suffix`);
    const n = this.tags[i];
    if (n)
      try {
        return n + decodeURIComponent(r);
      } catch (o) {
        return t(String(o)), null;
      }
    return i === "!" ? e : (t(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [t, i] of Object.entries(this.tags))
      if (e.startsWith(i))
        return t + hv(e.substring(i.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const t = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], i = Object.entries(this.tags);
    let r;
    if (e && i.length > 0 && Ae(e.contents)) {
      const n = {};
      Ws(e.contents, (o, a) => {
        Ae(a) && a.tag && (n[a.tag] = !0);
      }), r = Object.keys(n);
    } else
      r = [];
    for (const [n, o] of i)
      n === "!!" && o === "tag:yaml.org,2002:" || (!e || r.some((a) => a.startsWith(o))) && t.push(`%TAG ${n} ${o}`);
    return t.join(`
`);
  }
}
Ze.defaultYaml = { explicit: !1, version: "1.2" };
Ze.defaultTags = { "!!": "tag:yaml.org,2002:" };
function sd(s) {
  if (/[\x00-\x19\s,[\]{}]/.test(s)) {
    const t = `Anchor must not contain whitespace or control characters: ${JSON.stringify(s)}`;
    throw new Error(t);
  }
  return !0;
}
function id(s) {
  const e = /* @__PURE__ */ new Set();
  return Ws(s, {
    Value(t, i) {
      i.anchor && e.add(i.anchor);
    }
  }), e;
}
function rd(s, e) {
  for (let t = 1; ; ++t) {
    const i = `${s}${t}`;
    if (!e.has(i))
      return i;
  }
}
function dv(s, e) {
  const t = [], i = /* @__PURE__ */ new Map();
  let r = null;
  return {
    onAnchor: (n) => {
      t.push(n), r ?? (r = id(s));
      const o = rd(e, r);
      return r.add(o), o;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const n of t) {
        const o = i.get(n);
        if (typeof o == "object" && o.anchor && (ge(o.node) || $e(o.node)))
          o.node.anchor = o.anchor;
        else {
          const a = new Error("Failed to resolve repeated object (this should not happen)");
          throw a.source = n, a;
        }
      }
    },
    sourceObjects: i
  };
}
function ei(s, e, t, i) {
  if (i && typeof i == "object")
    if (Array.isArray(i))
      for (let r = 0, n = i.length; r < n; ++r) {
        const o = i[r], a = ei(s, i, String(r), o);
        a === void 0 ? delete i[r] : a !== o && (i[r] = a);
      }
    else if (i instanceof Map)
      for (const r of Array.from(i.keys())) {
        const n = i.get(r), o = ei(s, i, r, n);
        o === void 0 ? i.delete(r) : o !== n && i.set(r, o);
      }
    else if (i instanceof Set)
      for (const r of Array.from(i)) {
        const n = ei(s, i, r, r);
        n === void 0 ? i.delete(r) : n !== r && (i.delete(r), i.add(n));
      }
    else
      for (const [r, n] of Object.entries(i)) {
        const o = ei(s, i, r, n);
        o === void 0 ? delete i[r] : o !== n && (i[r] = o);
      }
  return s.call(e, t, i);
}
function ft(s, e, t) {
  if (Array.isArray(s))
    return s.map((i, r) => ft(i, String(r), t));
  if (s && typeof s.toJSON == "function") {
    if (!t || !Xh(s))
      return s.toJSON(e, t);
    const i = { aliasCount: 0, count: 1, res: void 0 };
    t.anchors.set(s, i), t.onCreate = (n) => {
      i.res = n, delete t.onCreate;
    };
    const r = s.toJSON(e, t);
    return t.onCreate && t.onCreate(r), r;
  }
  return typeof s == "bigint" && !(t != null && t.keep) ? Number(s) : s;
}
class ya {
  constructor(e) {
    Object.defineProperty(this, pt, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: t, maxAliasCount: i, onAnchor: r, reviver: n } = {}) {
    if (!Us(e))
      throw new TypeError("A document argument is required");
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: t === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof i == "number" ? i : 100
    }, a = ft(this, "", o);
    if (typeof r == "function")
      for (const { count: l, res: c } of o.anchors.values())
        r(c, l);
    return typeof n == "function" ? ei(n, { "": a }, "", a) : a;
  }
}
class Rn extends ya {
  constructor(e) {
    super(_a), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e, t) {
    let i;
    t != null && t.aliasResolveCache ? i = t.aliasResolveCache : (i = [], Ws(e, {
      Node: (n, o) => {
        (hs(o) || Xh(o)) && i.push(o);
      }
    }), t && (t.aliasResolveCache = i));
    let r;
    for (const n of i) {
      if (n === this)
        break;
      n.anchor === this.source && (r = n);
    }
    return r;
  }
  toJSON(e, t) {
    if (!t)
      return { source: this.source };
    const { anchors: i, doc: r, maxAliasCount: n } = t, o = this.resolve(r, t);
    if (!o) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = i.get(o);
    if (a || (ft(o, null, t), a = i.get(o)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (n >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = en(r, o, i)), a.count * a.aliasCount > n)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, t, i) {
    const r = `*${this.source}`;
    if (e) {
      if (sd(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const n = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(n);
      }
      if (e.implicitKey)
        return `${r} `;
    }
    return r;
  }
}
function en(s, e, t) {
  if (hs(e)) {
    const i = e.resolve(s), r = t && i && t.get(i);
    return r ? r.count * r.aliasCount : 0;
  } else if ($e(e)) {
    let i = 0;
    for (const r of e.items) {
      const n = en(s, r, t);
      n > i && (i = n);
    }
    return i;
  } else if (Se(e)) {
    const i = en(s, e.key, t), r = en(s, e.value, t);
    return Math.max(i, r);
  }
  return 1;
}
const nd = (s) => !s || typeof s != "function" && typeof s != "object";
class te extends ya {
  constructor(e) {
    super(Mt), this.value = e;
  }
  toJSON(e, t) {
    return t != null && t.keep ? this.value : ft(this.value, e, t);
  }
  toString() {
    return String(this.value);
  }
}
te.BLOCK_FOLDED = "BLOCK_FOLDED";
te.BLOCK_LITERAL = "BLOCK_LITERAL";
te.PLAIN = "PLAIN";
te.QUOTE_DOUBLE = "QUOTE_DOUBLE";
te.QUOTE_SINGLE = "QUOTE_SINGLE";
const uv = "tag:yaml.org,2002:";
function fv(s, e, t) {
  if (e) {
    const i = t.filter((n) => n.tag === e), r = i.find((n) => !n.format) ?? i[0];
    if (!r)
      throw new Error(`Tag ${e} not found`);
    return r;
  }
  return t.find((i) => {
    var r;
    return ((r = i.identify) == null ? void 0 : r.call(i, s)) && !i.format;
  });
}
function ar(s, e, t) {
  var h, f, m;
  if (Us(s) && (s = s.contents), Ae(s))
    return s;
  if (Se(s)) {
    const _ = (f = (h = t.schema[rs]).createNode) == null ? void 0 : f.call(h, t.schema, null, t);
    return _.items.push(s), _;
  }
  (s instanceof String || s instanceof Number || s instanceof Boolean || typeof BigInt < "u" && s instanceof BigInt) && (s = s.valueOf());
  const { aliasDuplicateObjects: i, onAnchor: r, onTagObj: n, schema: o, sourceObjects: a } = t;
  let l;
  if (i && s && typeof s == "object") {
    if (l = a.get(s), l)
      return l.anchor ?? (l.anchor = r(s)), new Rn(l.anchor);
    l = { anchor: null, node: null }, a.set(s, l);
  }
  e != null && e.startsWith("!!") && (e = uv + e.slice(2));
  let c = fv(s, e, o.tags);
  if (!c) {
    if (s && typeof s.toJSON == "function" && (s = s.toJSON()), !s || typeof s != "object") {
      const _ = new te(s);
      return l && (l.node = _), _;
    }
    c = s instanceof Map ? o[rs] : Symbol.iterator in Object(s) ? o[mi] : o[rs];
  }
  n && (n(c), delete t.onTagObj);
  const u = c != null && c.createNode ? c.createNode(t.schema, s, t) : typeof ((m = c == null ? void 0 : c.nodeClass) == null ? void 0 : m.from) == "function" ? c.nodeClass.from(t.schema, s, t) : new te(s);
  return e ? u.tag = e : c.default || (u.tag = c.tag), l && (l.node = u), u;
}
function bn(s, e, t) {
  let i = t;
  for (let r = e.length - 1; r >= 0; --r) {
    const n = e[r];
    if (typeof n == "number" && Number.isInteger(n) && n >= 0) {
      const o = [];
      o[n] = i, i = o;
    } else
      i = /* @__PURE__ */ new Map([[n, i]]);
  }
  return ar(i, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: s,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const Fi = (s) => s == null || typeof s == "object" && !!s[Symbol.iterator]().next().done;
class od extends ya {
  constructor(e, t) {
    super(e), Object.defineProperty(this, "schema", {
      value: t,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (t.schema = e), t.items = t.items.map((i) => Ae(i) || Se(i) ? i.clone(e) : i), this.range && (t.range = this.range.slice()), t;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, t) {
    if (Fi(e))
      this.add(t);
    else {
      const [i, ...r] = e, n = this.get(i, !0);
      if ($e(n))
        n.addIn(r, t);
      else if (n === void 0 && this.schema)
        this.set(i, bn(this.schema, r, t));
      else
        throw new Error(`Expected YAML collection at ${i}. Remaining path: ${r}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [t, ...i] = e;
    if (i.length === 0)
      return this.delete(t);
    const r = this.get(t, !0);
    if ($e(r))
      return r.deleteIn(i);
    throw new Error(`Expected YAML collection at ${t}. Remaining path: ${i}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, t) {
    const [i, ...r] = e, n = this.get(i, !0);
    return r.length === 0 ? !t && ge(n) ? n.value : n : $e(n) ? n.getIn(r, t) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((t) => {
      if (!Se(t))
        return !1;
      const i = t.value;
      return i == null || e && ge(i) && i.value == null && !i.commentBefore && !i.comment && !i.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [t, ...i] = e;
    if (i.length === 0)
      return this.has(t);
    const r = this.get(t, !0);
    return $e(r) ? r.hasIn(i) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, t) {
    const [i, ...r] = e;
    if (r.length === 0)
      this.set(i, t);
    else {
      const n = this.get(i, !0);
      if ($e(n))
        n.setIn(r, t);
      else if (n === void 0 && this.schema)
        this.set(i, bn(this.schema, r, t));
      else
        throw new Error(`Expected YAML collection at ${i}. Remaining path: ${r}`);
    }
  }
}
const pv = (s) => s.replace(/^(?!$)(?: $)?/gm, "#");
function Ut(s, e) {
  return /^\n+$/.test(s) ? s.substring(1) : e ? s.replace(/^(?! *$)/gm, e) : s;
}
const ws = (s, e, t) => s.endsWith(`
`) ? Ut(t, e) : t.includes(`
`) ? `
` + Ut(t, e) : (s.endsWith(" ") ? "" : " ") + t, ad = "flow", Vo = "block", tn = "quoted";
function On(s, e, t = "flow", { indentAtStart: i, lineWidth: r = 80, minContentWidth: n = 20, onFold: o, onOverflow: a } = {}) {
  if (!r || r < 0)
    return s;
  r < n && (n = 0);
  const l = Math.max(1 + n, 1 + r - e.length);
  if (s.length <= l)
    return s;
  const c = [], u = {};
  let h = r - e.length;
  typeof i == "number" && (i > r - Math.max(2, n) ? c.push(0) : h = r - i);
  let f, m, _ = !1, v = -1, d = -1, p = -1;
  t === Vo && (v = Ac(s, v, e.length), v !== -1 && (h = v + l));
  for (let b; b = s[v += 1]; ) {
    if (t === tn && b === "\\") {
      switch (d = v, s[v + 1]) {
        case "x":
          v += 3;
          break;
        case "u":
          v += 5;
          break;
        case "U":
          v += 9;
          break;
        default:
          v += 1;
      }
      p = v;
    }
    if (b === `
`)
      t === Vo && (v = Ac(s, v, e.length)), h = v + e.length + l, f = void 0;
    else {
      if (b === " " && m && m !== " " && m !== `
` && m !== "	") {
        const y = s[v + 1];
        y && y !== " " && y !== `
` && y !== "	" && (f = v);
      }
      if (v >= h)
        if (f)
          c.push(f), h = f + l, f = void 0;
        else if (t === tn) {
          for (; m === " " || m === "	"; )
            m = b, b = s[v += 1], _ = !0;
          const y = v > p + 1 ? v - 2 : d - 1;
          if (u[y])
            return s;
          c.push(y), u[y] = !0, h = y + l, f = void 0;
        } else
          _ = !0;
    }
    m = b;
  }
  if (_ && a && a(), c.length === 0)
    return s;
  o && o();
  let g = s.slice(0, c[0]);
  for (let b = 0; b < c.length; ++b) {
    const y = c[b], w = c[b + 1] || s.length;
    y === 0 ? g = `
${e}${s.slice(0, w)}` : (t === tn && u[y] && (g += `${s[y]}\\`), g += `
${e}${s.slice(y + 1, w)}`);
  }
  return g;
}
function Ac(s, e, t) {
  let i = e, r = e + 1, n = s[r];
  for (; n === " " || n === "	"; )
    if (e < r + t)
      n = s[++e];
    else {
      do
        n = s[++e];
      while (n && n !== `
`);
      i = e, r = e + 1, n = s[r];
    }
  return i;
}
const Pn = (s, e) => ({
  indentAtStart: e ? s.indent.length : s.indentAtStart,
  lineWidth: s.options.lineWidth,
  minContentWidth: s.options.minContentWidth
}), Bn = (s) => /^(%|---|\.\.\.)/m.test(s);
function gv(s, e, t) {
  if (!e || e < 0)
    return !1;
  const i = e - t, r = s.length;
  if (r <= i)
    return !1;
  for (let n = 0, o = 0; n < r; ++n)
    if (s[n] === `
`) {
      if (n - o > i)
        return !0;
      if (o = n + 1, r - o <= i)
        return !1;
    }
  return !0;
}
function Ki(s, e) {
  const t = JSON.stringify(s);
  if (e.options.doubleQuotedAsJSON)
    return t;
  const { implicitKey: i } = e, r = e.options.doubleQuotedMinMultiLineLength, n = e.indent || (Bn(s) ? "  " : "");
  let o = "", a = 0;
  for (let l = 0, c = t[l]; c; c = t[++l])
    if (c === " " && t[l + 1] === "\\" && t[l + 2] === "n" && (o += t.slice(a, l) + "\\ ", l += 1, a = l, c = "\\"), c === "\\")
      switch (t[l + 1]) {
        case "u":
          {
            o += t.slice(a, l);
            const u = t.substr(l + 2, 4);
            switch (u) {
              case "0000":
                o += "\\0";
                break;
              case "0007":
                o += "\\a";
                break;
              case "000b":
                o += "\\v";
                break;
              case "001b":
                o += "\\e";
                break;
              case "0085":
                o += "\\N";
                break;
              case "00a0":
                o += "\\_";
                break;
              case "2028":
                o += "\\L";
                break;
              case "2029":
                o += "\\P";
                break;
              default:
                u.substr(0, 2) === "00" ? o += "\\x" + u.substr(2) : o += t.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (i || t[l + 2] === '"' || t.length < r)
            l += 1;
          else {
            for (o += t.slice(a, l) + `

`; t[l + 2] === "\\" && t[l + 3] === "n" && t[l + 4] !== '"'; )
              o += `
`, l += 2;
            o += n, t[l + 2] === " " && (o += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return o = a ? o + t.slice(a) : t, i ? o : On(o, n, tn, Pn(e, !1));
}
function qo(s, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && s.includes(`
`) || /[ \t]\n|\n[ \t]/.test(s))
    return Ki(s, e);
  const t = e.indent || (Bn(s) ? "  " : ""), i = "'" + s.replace(/'/g, "''").replace(/\n+/g, `$&
${t}`) + "'";
  return e.implicitKey ? i : On(i, t, ad, Pn(e, !1));
}
function ti(s, e) {
  const { singleQuote: t } = e.options;
  let i;
  if (t === !1)
    i = Ki;
  else {
    const r = s.includes('"'), n = s.includes("'");
    r && !n ? i = qo : n && !r ? i = Ki : i = t ? qo : Ki;
  }
  return i(s, e);
}
let Ko;
try {
  Ko = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  Ko = /\n+(?!\n|$)/g;
}
function sn({ comment: s, type: e, value: t }, i, r, n) {
  const { blockQuote: o, commentString: a, lineWidth: l } = i.options;
  if (!o || /\n[\t ]+$/.test(t) || /^\s*$/.test(t))
    return ti(t, i);
  const c = i.indent || (i.forceBlockIndent || Bn(t) ? "  " : ""), u = o === "literal" ? !0 : o === "folded" || e === te.BLOCK_FOLDED ? !1 : e === te.BLOCK_LITERAL ? !0 : !gv(t, l, c.length);
  if (!t)
    return u ? `|
` : `>
`;
  let h, f;
  for (f = t.length; f > 0; --f) {
    const w = t[f - 1];
    if (w !== `
` && w !== "	" && w !== " ")
      break;
  }
  let m = t.substring(f);
  const _ = m.indexOf(`
`);
  _ === -1 ? h = "-" : t === m || _ !== m.length - 1 ? (h = "+", n && n()) : h = "", m && (t = t.slice(0, -m.length), m[m.length - 1] === `
` && (m = m.slice(0, -1)), m = m.replace(Ko, `$&${c}`));
  let v = !1, d, p = -1;
  for (d = 0; d < t.length; ++d) {
    const w = t[d];
    if (w === " ")
      v = !0;
    else if (w === `
`)
      p = d;
    else
      break;
  }
  let g = t.substring(0, p < d ? p + 1 : d);
  g && (t = t.substring(g.length), g = g.replace(/\n+/g, `$&${c}`));
  let y = (v ? c ? "2" : "1" : "") + h;
  if (s && (y += " " + a(s.replace(/ ?[\r\n]+/g, " ")), r && r()), !u) {
    const w = t.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
    let k = !1;
    const C = Pn(i, !0);
    o !== "folded" && e !== te.BLOCK_FOLDED && (C.onOverflow = () => {
      k = !0;
    });
    const x = On(`${g}${w}${m}`, c, Vo, C);
    if (!k)
      return `>${y}
${c}${x}`;
  }
  return t = t.replace(/\n+/g, `$&${c}`), `|${y}
${c}${g}${t}${m}`;
}
function mv(s, e, t, i) {
  const { type: r, value: n } = s, { actualString: o, implicitKey: a, indent: l, indentStep: c, inFlow: u } = e;
  if (a && n.includes(`
`) || u && /[[\]{},]/.test(n))
    return ti(n, e);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(n))
    return a || u || !n.includes(`
`) ? ti(n, e) : sn(s, e, t, i);
  if (!a && !u && r !== te.PLAIN && n.includes(`
`))
    return sn(s, e, t, i);
  if (Bn(n)) {
    if (l === "")
      return e.forceBlockIndent = !0, sn(s, e, t, i);
    if (a && l === c)
      return ti(n, e);
  }
  const h = n.replace(/\n+/g, `$&
${l}`);
  if (o) {
    const f = (v) => {
      var d;
      return v.default && v.tag !== "tag:yaml.org,2002:str" && ((d = v.test) == null ? void 0 : d.test(h));
    }, { compat: m, tags: _ } = e.doc.schema;
    if (_.some(f) || m != null && m.some(f))
      return ti(n, e);
  }
  return a ? h : On(h, l, ad, Pn(e, !1));
}
function vr(s, e, t, i) {
  const { implicitKey: r, inFlow: n } = e, o = typeof s.value == "string" ? s : Object.assign({}, s, { value: String(s.value) });
  let { type: a } = s;
  a !== te.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value) && (a = te.QUOTE_DOUBLE);
  const l = (u) => {
    switch (u) {
      case te.BLOCK_FOLDED:
      case te.BLOCK_LITERAL:
        return r || n ? ti(o.value, e) : sn(o, e, t, i);
      case te.QUOTE_DOUBLE:
        return Ki(o.value, e);
      case te.QUOTE_SINGLE:
        return qo(o.value, e);
      case te.PLAIN:
        return mv(o, e, t, i);
      default:
        return null;
    }
  };
  let c = l(a);
  if (c === null) {
    const { defaultKeyType: u, defaultStringType: h } = e.options, f = r && u || h;
    if (c = l(f), c === null)
      throw new Error(`Unsupported default string type ${f}`);
  }
  return c;
}
function ld(s, e) {
  const t = Object.assign({
    blockQuote: !0,
    commentString: pv,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, s.schema.toStringOptions, e);
  let i;
  switch (t.collectionStyle) {
    case "block":
      i = !1;
      break;
    case "flow":
      i = !0;
      break;
    default:
      i = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: s,
    flowCollectionPadding: t.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof t.indent == "number" ? " ".repeat(t.indent) : "  ",
    inFlow: i,
    options: t
  };
}
function bv(s, e) {
  var r;
  if (e.tag) {
    const n = s.filter((o) => o.tag === e.tag);
    if (n.length > 0)
      return n.find((o) => o.format === e.format) ?? n[0];
  }
  let t, i;
  if (ge(e)) {
    i = e.value;
    let n = s.filter((o) => {
      var a;
      return (a = o.identify) == null ? void 0 : a.call(o, i);
    });
    if (n.length > 1) {
      const o = n.filter((a) => a.test);
      o.length > 0 && (n = o);
    }
    t = n.find((o) => o.format === e.format) ?? n.find((o) => !o.format);
  } else
    i = e, t = s.find((n) => n.nodeClass && i instanceof n.nodeClass);
  if (!t) {
    const n = ((r = i == null ? void 0 : i.constructor) == null ? void 0 : r.name) ?? (i === null ? "null" : typeof i);
    throw new Error(`Tag not resolved for ${n} value`);
  }
  return t;
}
function vv(s, e, { anchors: t, doc: i }) {
  if (!i.directives)
    return "";
  const r = [], n = (ge(s) || $e(s)) && s.anchor;
  n && sd(n) && (t.add(n), r.push(`&${n}`));
  const o = s.tag ?? (e.default ? null : e.tag);
  return o && r.push(i.directives.tagString(o)), r.join(" ");
}
function ui(s, e, t, i) {
  var l;
  if (Se(s))
    return s.toString(e, t, i);
  if (hs(s)) {
    if (e.doc.directives)
      return s.toString(e);
    if ((l = e.resolvedAliases) != null && l.has(s))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(s) : e.resolvedAliases = /* @__PURE__ */ new Set([s]), s = s.resolve(e.doc);
  }
  let r;
  const n = Ae(s) ? s : e.doc.createNode(s, { onTagObj: (c) => r = c });
  r ?? (r = bv(e.doc.schema.tags, n));
  const o = vv(n, r, e);
  o.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + o.length + 1);
  const a = typeof r.stringify == "function" ? r.stringify(n, e, t, i) : ge(n) ? vr(n, e, t, i) : n.toString(e, t, i);
  return o ? ge(n) || a[0] === "{" || a[0] === "[" ? `${o} ${a}` : `${o}
${e.indent}${a}` : a;
}
function _v({ key: s, value: e }, t, i, r) {
  const { allNullValues: n, doc: o, indent: a, indentStep: l, options: { commentString: c, indentSeq: u, simpleKeys: h } } = t;
  let f = Ae(s) && s.comment || null;
  if (h) {
    if (f)
      throw new Error("With simple keys, key nodes cannot have comments");
    if ($e(s) || !Ae(s) && typeof s == "object") {
      const C = "With simple keys, collection cannot be used as a key value";
      throw new Error(C);
    }
  }
  let m = !h && (!s || f && e == null && !t.inFlow || $e(s) || (ge(s) ? s.type === te.BLOCK_FOLDED || s.type === te.BLOCK_LITERAL : typeof s == "object"));
  t = Object.assign({}, t, {
    allNullValues: !1,
    implicitKey: !m && (h || !n),
    indent: a + l
  });
  let _ = !1, v = !1, d = ui(s, t, () => _ = !0, () => v = !0);
  if (!m && !t.inFlow && d.length > 1024) {
    if (h)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    m = !0;
  }
  if (t.inFlow) {
    if (n || e == null)
      return _ && i && i(), d === "" ? "?" : m ? `? ${d}` : d;
  } else if (n && !h || e == null && m)
    return d = `? ${d}`, f && !_ ? d += ws(d, t.indent, c(f)) : v && r && r(), d;
  _ && (f = null), m ? (f && (d += ws(d, t.indent, c(f))), d = `? ${d}
${a}:`) : (d = `${d}:`, f && (d += ws(d, t.indent, c(f))));
  let p, g, b;
  Ae(e) ? (p = !!e.spaceBefore, g = e.commentBefore, b = e.comment) : (p = !1, g = null, b = null, e && typeof e == "object" && (e = o.createNode(e))), t.implicitKey = !1, !m && !f && ge(e) && (t.indentAtStart = d.length + 1), v = !1, !u && l.length >= 2 && !t.inFlow && !m && vi(e) && !e.flow && !e.tag && !e.anchor && (t.indent = t.indent.substring(2));
  let y = !1;
  const w = ui(e, t, () => y = !0, () => v = !0);
  let k = " ";
  if (f || p || g) {
    if (k = p ? `
` : "", g) {
      const C = c(g);
      k += `
${Ut(C, t.indent)}`;
    }
    w === "" && !t.inFlow ? k === `
` && (k = `

`) : k += `
${t.indent}`;
  } else if (!m && $e(e)) {
    const C = w[0], x = w.indexOf(`
`), S = x !== -1, T = t.inFlow ?? e.flow ?? e.items.length === 0;
    if (S || !T) {
      let M = !1;
      if (S && (C === "&" || C === "!")) {
        let E = w.indexOf(" ");
        C === "&" && E !== -1 && E < x && w[E + 1] === "!" && (E = w.indexOf(" ", E + 1)), (E === -1 || x < E) && (M = !0);
      }
      M || (k = `
${t.indent}`);
    }
  } else (w === "" || w[0] === `
`) && (k = "");
  return d += k + w, t.inFlow ? y && i && i() : b && !y ? d += ws(d, t.indent, c(b)) : v && r && r(), d;
}
function cd(s, e) {
  (s === "debug" || s === "warn") && console.warn(e);
}
const Fr = "<<", Wt = {
  identify: (s) => s === Fr || typeof s == "symbol" && s.description === Fr,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new te(Symbol(Fr)), {
    addToJSMap: hd
  }),
  stringify: () => Fr
}, yv = (s, e) => (Wt.identify(e) || ge(e) && (!e.type || e.type === te.PLAIN) && Wt.identify(e.value)) && (s == null ? void 0 : s.doc.schema.tags.some((t) => t.tag === Wt.tag && t.default));
function hd(s, e, t) {
  if (t = s && hs(t) ? t.resolve(s.doc) : t, vi(t))
    for (const i of t.items)
      vo(s, e, i);
  else if (Array.isArray(t))
    for (const i of t)
      vo(s, e, i);
  else
    vo(s, e, t);
}
function vo(s, e, t) {
  const i = s && hs(t) ? t.resolve(s.doc) : t;
  if (!bi(i))
    throw new Error("Merge sources must be maps or map aliases");
  const r = i.toJSON(null, s, Map);
  for (const [n, o] of r)
    e instanceof Map ? e.has(n) || e.set(n, o) : e instanceof Set ? e.add(n) : Object.prototype.hasOwnProperty.call(e, n) || Object.defineProperty(e, n, {
      value: o,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function dd(s, e, { key: t, value: i }) {
  if (Ae(t) && t.addToJSMap)
    t.addToJSMap(s, e, i);
  else if (yv(s, t))
    hd(s, e, i);
  else {
    const r = ft(t, "", s);
    if (e instanceof Map)
      e.set(r, ft(i, r, s));
    else if (e instanceof Set)
      e.add(r);
    else {
      const n = wv(t, r, s), o = ft(i, n, s);
      n in e ? Object.defineProperty(e, n, {
        value: o,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[n] = o;
    }
  }
  return e;
}
function wv(s, e, t) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (Ae(s) && (t != null && t.doc)) {
    const i = ld(t.doc, {});
    i.anchors = /* @__PURE__ */ new Set();
    for (const n of t.anchors.keys())
      i.anchors.add(n.anchor);
    i.inFlow = !0, i.inStringifyKey = !0;
    const r = s.toString(i);
    if (!t.mapKeyWarned) {
      let n = JSON.stringify(r);
      n.length > 40 && (n = n.substring(0, 36) + '..."'), cd(t.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${n}. Set mapAsMap: true to use object keys.`), t.mapKeyWarned = !0;
    }
    return r;
  }
  return JSON.stringify(e);
}
function wa(s, e, t) {
  const i = ar(s, void 0, t), r = ar(e, void 0, t);
  return new Ge(i, r);
}
class Ge {
  constructor(e, t = null) {
    Object.defineProperty(this, pt, { value: Gh }), this.key = e, this.value = t;
  }
  clone(e) {
    let { key: t, value: i } = this;
    return Ae(t) && (t = t.clone(e)), Ae(i) && (i = i.clone(e)), new Ge(t, i);
  }
  toJSON(e, t) {
    const i = t != null && t.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return dd(t, i, this);
  }
  toString(e, t, i) {
    return e != null && e.doc ? _v(this, e, t, i) : JSON.stringify(this);
  }
}
function ud(s, e, t) {
  return (e.inFlow ?? s.flow ? kv : xv)(s, e, t);
}
function xv({ comment: s, items: e }, t, { blockItemPrefix: i, flowChars: r, itemIndent: n, onChompKeep: o, onComment: a }) {
  const { indent: l, options: { commentString: c } } = t, u = Object.assign({}, t, { indent: n, type: null });
  let h = !1;
  const f = [];
  for (let _ = 0; _ < e.length; ++_) {
    const v = e[_];
    let d = null;
    if (Ae(v))
      !h && v.spaceBefore && f.push(""), vn(t, f, v.commentBefore, h), v.comment && (d = v.comment);
    else if (Se(v)) {
      const g = Ae(v.key) ? v.key : null;
      g && (!h && g.spaceBefore && f.push(""), vn(t, f, g.commentBefore, h));
    }
    h = !1;
    let p = ui(v, u, () => d = null, () => h = !0);
    d && (p += ws(p, n, c(d))), h && d && (h = !1), f.push(i + p);
  }
  let m;
  if (f.length === 0)
    m = r.start + r.end;
  else {
    m = f[0];
    for (let _ = 1; _ < f.length; ++_) {
      const v = f[_];
      m += v ? `
${l}${v}` : `
`;
    }
  }
  return s ? (m += `
` + Ut(c(s), l), a && a()) : h && o && o(), m;
}
function kv({ items: s }, e, { flowChars: t, itemIndent: i }) {
  const { indent: r, indentStep: n, flowCollectionPadding: o, options: { commentString: a } } = e;
  i += n;
  const l = Object.assign({}, e, {
    indent: i,
    inFlow: !0,
    type: null
  });
  let c = !1, u = 0;
  const h = [];
  for (let _ = 0; _ < s.length; ++_) {
    const v = s[_];
    let d = null;
    if (Ae(v))
      v.spaceBefore && h.push(""), vn(e, h, v.commentBefore, !1), v.comment && (d = v.comment);
    else if (Se(v)) {
      const g = Ae(v.key) ? v.key : null;
      g && (g.spaceBefore && h.push(""), vn(e, h, g.commentBefore, !1), g.comment && (c = !0));
      const b = Ae(v.value) ? v.value : null;
      b ? (b.comment && (d = b.comment), b.commentBefore && (c = !0)) : v.value == null && (g != null && g.comment) && (d = g.comment);
    }
    d && (c = !0);
    let p = ui(v, l, () => d = null);
    _ < s.length - 1 && (p += ","), d && (p += ws(p, i, a(d))), !c && (h.length > u || p.includes(`
`)) && (c = !0), h.push(p), u = h.length;
  }
  const { start: f, end: m } = t;
  if (h.length === 0)
    return f + m;
  if (!c) {
    const _ = h.reduce((v, d) => v + d.length + 2, 2);
    c = e.options.lineWidth > 0 && _ > e.options.lineWidth;
  }
  if (c) {
    let _ = f;
    for (const v of h)
      _ += v ? `
${n}${r}${v}` : `
`;
    return `${_}
${r}${m}`;
  } else
    return `${f}${o}${h.join(" ")}${o}${m}`;
}
function vn({ indent: s, options: { commentString: e } }, t, i, r) {
  if (i && r && (i = i.replace(/^\n+/, "")), i) {
    const n = Ut(e(i), s);
    t.push(n.trimStart());
  }
}
function xs(s, e) {
  const t = ge(e) ? e.value : e;
  for (const i of s)
    if (Se(i) && (i.key === e || i.key === t || ge(i.key) && i.key.value === t))
      return i;
}
class ht extends od {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(rs, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, t, i) {
    const { keepUndefined: r, replacer: n } = i, o = new this(e), a = (l, c) => {
      if (typeof n == "function")
        c = n.call(t, l, c);
      else if (Array.isArray(n) && !n.includes(l))
        return;
      (c !== void 0 || r) && o.items.push(wa(l, c, i));
    };
    if (t instanceof Map)
      for (const [l, c] of t)
        a(l, c);
    else if (t && typeof t == "object")
      for (const l of Object.keys(t))
        a(l, t[l]);
    return typeof e.sortMapEntries == "function" && o.items.sort(e.sortMapEntries), o;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, t) {
    var o;
    let i;
    Se(e) ? i = e : !e || typeof e != "object" || !("key" in e) ? i = new Ge(e, e == null ? void 0 : e.value) : i = new Ge(e.key, e.value);
    const r = xs(this.items, i.key), n = (o = this.schema) == null ? void 0 : o.sortMapEntries;
    if (r) {
      if (!t)
        throw new Error(`Key ${i.key} already set`);
      ge(r.value) && nd(i.value) ? r.value.value = i.value : r.value = i.value;
    } else if (n) {
      const a = this.items.findIndex((l) => n(i, l) < 0);
      a === -1 ? this.items.push(i) : this.items.splice(a, 0, i);
    } else
      this.items.push(i);
  }
  delete(e) {
    const t = xs(this.items, e);
    return t ? this.items.splice(this.items.indexOf(t), 1).length > 0 : !1;
  }
  get(e, t) {
    const i = xs(this.items, e), r = i == null ? void 0 : i.value;
    return (!t && ge(r) ? r.value : r) ?? void 0;
  }
  has(e) {
    return !!xs(this.items, e);
  }
  set(e, t) {
    this.add(new Ge(e, t), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, t, i) {
    const r = i ? new i() : t != null && t.mapAsMap ? /* @__PURE__ */ new Map() : {};
    t != null && t.onCreate && t.onCreate(r);
    for (const n of this.items)
      dd(t, r, n);
    return r;
  }
  toString(e, t, i) {
    if (!e)
      return JSON.stringify(this);
    for (const r of this.items)
      if (!Se(r))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(r)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), ud(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: i,
      onComment: t
    });
  }
}
const _i = {
  collection: "map",
  default: !0,
  nodeClass: ht,
  tag: "tag:yaml.org,2002:map",
  resolve(s, e) {
    return bi(s) || e("Expected a mapping for this tag"), s;
  },
  createNode: (s, e, t) => ht.from(s, e, t)
};
class ls extends od {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(mi, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const t = zr(e);
    return typeof t != "number" ? !1 : this.items.splice(t, 1).length > 0;
  }
  get(e, t) {
    const i = zr(e);
    if (typeof i != "number")
      return;
    const r = this.items[i];
    return !t && ge(r) ? r.value : r;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const t = zr(e);
    return typeof t == "number" && t < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, t) {
    const i = zr(e);
    if (typeof i != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const r = this.items[i];
    ge(r) && nd(t) ? r.value = t : this.items[i] = t;
  }
  toJSON(e, t) {
    const i = [];
    t != null && t.onCreate && t.onCreate(i);
    let r = 0;
    for (const n of this.items)
      i.push(ft(n, String(r++), t));
    return i;
  }
  toString(e, t, i) {
    return e ? ud(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: i,
      onComment: t
    }) : JSON.stringify(this);
  }
  static from(e, t, i) {
    const { replacer: r } = i, n = new this(e);
    if (t && Symbol.iterator in Object(t)) {
      let o = 0;
      for (let a of t) {
        if (typeof r == "function") {
          const l = t instanceof Set ? a : String(o++);
          a = r.call(t, l, a);
        }
        n.items.push(ar(a, void 0, i));
      }
    }
    return n;
  }
}
function zr(s) {
  let e = ge(s) ? s.value : s;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const yi = {
  collection: "seq",
  default: !0,
  nodeClass: ls,
  tag: "tag:yaml.org,2002:seq",
  resolve(s, e) {
    return vi(s) || e("Expected a sequence for this tag"), s;
  },
  createNode: (s, e, t) => ls.from(s, e, t)
}, Nn = {
  identify: (s) => typeof s == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (s) => s,
  stringify(s, e, t, i) {
    return e = Object.assign({ actualString: !0 }, e), vr(s, e, t, i);
  }
}, Fn = {
  identify: (s) => s == null,
  createNode: () => new te(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new te(null),
  stringify: ({ source: s }, e) => typeof s == "string" && Fn.test.test(s) ? s : e.options.nullStr
}, xa = {
  identify: (s) => typeof s == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (s) => new te(s[0] === "t" || s[0] === "T"),
  stringify({ source: s, value: e }, t) {
    if (s && xa.test.test(s)) {
      const i = s[0] === "t" || s[0] === "T";
      if (e === i)
        return s;
    }
    return e ? t.options.trueStr : t.options.falseStr;
  }
};
function kt({ format: s, minFractionDigits: e, tag: t, value: i }) {
  if (typeof i == "bigint")
    return String(i);
  const r = typeof i == "number" ? i : Number(i);
  if (!isFinite(r))
    return isNaN(r) ? ".nan" : r < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(i);
  if (!s && e && (!t || t === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let o = n.indexOf(".");
    o < 0 && (o = n.length, n += ".");
    let a = e - (n.length - o - 1);
    for (; a-- > 0; )
      n += "0";
  }
  return n;
}
const fd = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (s) => s.slice(-3).toLowerCase() === "nan" ? NaN : s[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: kt
}, pd = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (s) => parseFloat(s),
  stringify(s) {
    const e = Number(s.value);
    return isFinite(e) ? e.toExponential() : kt(s);
  }
}, gd = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(s) {
    const e = new te(parseFloat(s)), t = s.indexOf(".");
    return t !== -1 && s[s.length - 1] === "0" && (e.minFractionDigits = s.length - t - 1), e;
  },
  stringify: kt
}, zn = (s) => typeof s == "bigint" || Number.isInteger(s), ka = (s, e, t, { intAsBigInt: i }) => i ? BigInt(s) : parseInt(s.substring(e), t);
function md(s, e, t) {
  const { value: i } = s;
  return zn(i) && i >= 0 ? t + i.toString(e) : kt(s);
}
const bd = {
  identify: (s) => zn(s) && s >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (s, e, t) => ka(s, 2, 8, t),
  stringify: (s) => md(s, 8, "0o")
}, vd = {
  identify: zn,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (s, e, t) => ka(s, 0, 10, t),
  stringify: kt
}, _d = {
  identify: (s) => zn(s) && s >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (s, e, t) => ka(s, 2, 16, t),
  stringify: (s) => md(s, 16, "0x")
}, Sv = [
  _i,
  yi,
  Nn,
  Fn,
  xa,
  bd,
  vd,
  _d,
  fd,
  pd,
  gd
];
function Ec(s) {
  return typeof s == "bigint" || Number.isInteger(s);
}
const Hr = ({ value: s }) => JSON.stringify(s), Cv = [
  {
    identify: (s) => typeof s == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (s) => s,
    stringify: Hr
  },
  {
    identify: (s) => s == null,
    createNode: () => new te(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: Hr
  },
  {
    identify: (s) => typeof s == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (s) => s === "true",
    stringify: Hr
  },
  {
    identify: Ec,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (s, e, { intAsBigInt: t }) => t ? BigInt(s) : parseInt(s, 10),
    stringify: ({ value: s }) => Ec(s) ? s.toString() : JSON.stringify(s)
  },
  {
    identify: (s) => typeof s == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (s) => parseFloat(s),
    stringify: Hr
  }
], Dv = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(s, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(s)}`), s;
  }
}, $v = [_i, yi].concat(Cv, Dv), Sa = {
  identify: (s) => s instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(s, e) {
    if (typeof atob == "function") {
      const t = atob(s.replace(/[\n\r]/g, "")), i = new Uint8Array(t.length);
      for (let r = 0; r < t.length; ++r)
        i[r] = t.charCodeAt(r);
      return i;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), s;
  },
  stringify({ comment: s, type: e, value: t }, i, r, n) {
    if (!t)
      return "";
    const o = t;
    let a;
    if (typeof btoa == "function") {
      let l = "";
      for (let c = 0; c < o.length; ++c)
        l += String.fromCharCode(o[c]);
      a = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e ?? (e = te.BLOCK_LITERAL), e !== te.QUOTE_DOUBLE) {
      const l = Math.max(i.options.lineWidth - i.indent.length, i.options.minContentWidth), c = Math.ceil(a.length / l), u = new Array(c);
      for (let h = 0, f = 0; h < c; ++h, f += l)
        u[h] = a.substr(f, l);
      a = u.join(e === te.BLOCK_LITERAL ? `
` : " ");
    }
    return vr({ comment: s, type: e, value: a }, i, r, n);
  }
};
function yd(s, e) {
  if (vi(s))
    for (let t = 0; t < s.items.length; ++t) {
      let i = s.items[t];
      if (!Se(i)) {
        if (bi(i)) {
          i.items.length > 1 && e("Each pair must have its own sequence indicator");
          const r = i.items[0] || new Ge(new te(null));
          if (i.commentBefore && (r.key.commentBefore = r.key.commentBefore ? `${i.commentBefore}
${r.key.commentBefore}` : i.commentBefore), i.comment) {
            const n = r.value ?? r.key;
            n.comment = n.comment ? `${i.comment}
${n.comment}` : i.comment;
          }
          i = r;
        }
        s.items[t] = Se(i) ? i : new Ge(i);
      }
    }
  else
    e("Expected a sequence for this tag");
  return s;
}
function wd(s, e, t) {
  const { replacer: i } = t, r = new ls(s);
  r.tag = "tag:yaml.org,2002:pairs";
  let n = 0;
  if (e && Symbol.iterator in Object(e))
    for (let o of e) {
      typeof i == "function" && (o = i.call(e, String(n++), o));
      let a, l;
      if (Array.isArray(o))
        if (o.length === 2)
          a = o[0], l = o[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${o}`);
      else if (o && o instanceof Object) {
        const c = Object.keys(o);
        if (c.length === 1)
          a = c[0], l = o[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        a = o;
      r.items.push(wa(a, l, t));
    }
  return r;
}
const Ca = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: yd,
  createNode: wd
};
class ii extends ls {
  constructor() {
    super(), this.add = ht.prototype.add.bind(this), this.delete = ht.prototype.delete.bind(this), this.get = ht.prototype.get.bind(this), this.has = ht.prototype.has.bind(this), this.set = ht.prototype.set.bind(this), this.tag = ii.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, t) {
    if (!t)
      return super.toJSON(e);
    const i = /* @__PURE__ */ new Map();
    t != null && t.onCreate && t.onCreate(i);
    for (const r of this.items) {
      let n, o;
      if (Se(r) ? (n = ft(r.key, "", t), o = ft(r.value, n, t)) : n = ft(r, "", t), i.has(n))
        throw new Error("Ordered maps must not include duplicate keys");
      i.set(n, o);
    }
    return i;
  }
  static from(e, t, i) {
    const r = wd(e, t, i), n = new this();
    return n.items = r.items, n;
  }
}
ii.tag = "tag:yaml.org,2002:omap";
const Da = {
  collection: "seq",
  identify: (s) => s instanceof Map,
  nodeClass: ii,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(s, e) {
    const t = yd(s, e), i = [];
    for (const { key: r } of t.items)
      ge(r) && (i.includes(r.value) ? e(`Ordered maps must not include duplicate keys: ${r.value}`) : i.push(r.value));
    return Object.assign(new ii(), t);
  },
  createNode: (s, e, t) => ii.from(s, e, t)
};
function xd({ value: s, source: e }, t) {
  return e && (s ? kd : Sd).test.test(e) ? e : s ? t.options.trueStr : t.options.falseStr;
}
const kd = {
  identify: (s) => s === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new te(!0),
  stringify: xd
}, Sd = {
  identify: (s) => s === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new te(!1),
  stringify: xd
}, Av = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (s) => s.slice(-3).toLowerCase() === "nan" ? NaN : s[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: kt
}, Ev = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (s) => parseFloat(s.replace(/_/g, "")),
  stringify(s) {
    const e = Number(s.value);
    return isFinite(e) ? e.toExponential() : kt(s);
  }
}, Tv = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(s) {
    const e = new te(parseFloat(s.replace(/_/g, ""))), t = s.indexOf(".");
    if (t !== -1) {
      const i = s.substring(t + 1).replace(/_/g, "");
      i[i.length - 1] === "0" && (e.minFractionDigits = i.length);
    }
    return e;
  },
  stringify: kt
}, _r = (s) => typeof s == "bigint" || Number.isInteger(s);
function Hn(s, e, t, { intAsBigInt: i }) {
  const r = s[0];
  if ((r === "-" || r === "+") && (e += 1), s = s.substring(e).replace(/_/g, ""), i) {
    switch (t) {
      case 2:
        s = `0b${s}`;
        break;
      case 8:
        s = `0o${s}`;
        break;
      case 16:
        s = `0x${s}`;
        break;
    }
    const o = BigInt(s);
    return r === "-" ? BigInt(-1) * o : o;
  }
  const n = parseInt(s, t);
  return r === "-" ? -1 * n : n;
}
function $a(s, e, t) {
  const { value: i } = s;
  if (_r(i)) {
    const r = i.toString(e);
    return i < 0 ? "-" + t + r.substr(1) : t + r;
  }
  return kt(s);
}
const Lv = {
  identify: _r,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (s, e, t) => Hn(s, 2, 2, t),
  stringify: (s) => $a(s, 2, "0b")
}, Mv = {
  identify: _r,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (s, e, t) => Hn(s, 1, 8, t),
  stringify: (s) => $a(s, 8, "0")
}, Iv = {
  identify: _r,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (s, e, t) => Hn(s, 0, 10, t),
  stringify: kt
}, Rv = {
  identify: _r,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (s, e, t) => Hn(s, 2, 16, t),
  stringify: (s) => $a(s, 16, "0x")
};
class ri extends ht {
  constructor(e) {
    super(e), this.tag = ri.tag;
  }
  add(e) {
    let t;
    Se(e) ? t = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? t = new Ge(e.key, null) : t = new Ge(e, null), xs(this.items, t.key) || this.items.push(t);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, t) {
    const i = xs(this.items, e);
    return !t && Se(i) ? ge(i.key) ? i.key.value : i.key : i;
  }
  set(e, t) {
    if (typeof t != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof t}`);
    const i = xs(this.items, e);
    i && !t ? this.items.splice(this.items.indexOf(i), 1) : !i && t && this.items.push(new Ge(e));
  }
  toJSON(e, t) {
    return super.toJSON(e, t, Set);
  }
  toString(e, t, i) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), t, i);
    throw new Error("Set items must all have null values");
  }
  static from(e, t, i) {
    const { replacer: r } = i, n = new this(e);
    if (t && Symbol.iterator in Object(t))
      for (let o of t)
        typeof r == "function" && (o = r.call(t, o, o)), n.items.push(wa(o, null, i));
    return n;
  }
}
ri.tag = "tag:yaml.org,2002:set";
const Aa = {
  collection: "map",
  identify: (s) => s instanceof Set,
  nodeClass: ri,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (s, e, t) => ri.from(s, e, t),
  resolve(s, e) {
    if (bi(s)) {
      if (s.hasAllNullValues(!0))
        return Object.assign(new ri(), s);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return s;
  }
};
function Ea(s, e) {
  const t = s[0], i = t === "-" || t === "+" ? s.substring(1) : s, r = (o) => e ? BigInt(o) : Number(o), n = i.replace(/_/g, "").split(":").reduce((o, a) => o * r(60) + r(a), r(0));
  return t === "-" ? r(-1) * n : n;
}
function Cd(s) {
  let { value: e } = s, t = (o) => o;
  if (typeof e == "bigint")
    t = (o) => BigInt(o);
  else if (isNaN(e) || !isFinite(e))
    return kt(s);
  let i = "";
  e < 0 && (i = "-", e *= t(-1));
  const r = t(60), n = [e % r];
  return e < 60 ? n.unshift(0) : (e = (e - n[0]) / r, n.unshift(e % r), e >= 60 && (e = (e - n[0]) / r, n.unshift(e))), i + n.map((o) => String(o).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const Dd = {
  identify: (s) => typeof s == "bigint" || Number.isInteger(s),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (s, e, { intAsBigInt: t }) => Ea(s, t),
  stringify: Cd
}, $d = {
  identify: (s) => typeof s == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (s) => Ea(s, !1),
  stringify: Cd
}, jn = {
  identify: (s) => s instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(s) {
    const e = s.match(jn.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, t, i, r, n, o, a] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let c = Date.UTC(t, i - 1, r, n || 0, o || 0, a || 0, l);
    const u = e[8];
    if (u && u !== "Z") {
      let h = Ea(u, !1);
      Math.abs(h) < 30 && (h *= 60), c -= 6e4 * h;
    }
    return new Date(c);
  },
  stringify: ({ value: s }) => (s == null ? void 0 : s.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) ?? ""
}, Tc = [
  _i,
  yi,
  Nn,
  Fn,
  kd,
  Sd,
  Lv,
  Mv,
  Iv,
  Rv,
  Av,
  Ev,
  Tv,
  Sa,
  Wt,
  Da,
  Ca,
  Aa,
  Dd,
  $d,
  jn
], Lc = /* @__PURE__ */ new Map([
  ["core", Sv],
  ["failsafe", [_i, yi, Nn]],
  ["json", $v],
  ["yaml11", Tc],
  ["yaml-1.1", Tc]
]), Mc = {
  binary: Sa,
  bool: xa,
  float: gd,
  floatExp: pd,
  floatNaN: fd,
  floatTime: $d,
  int: vd,
  intHex: _d,
  intOct: bd,
  intTime: Dd,
  map: _i,
  merge: Wt,
  null: Fn,
  omap: Da,
  pairs: Ca,
  seq: yi,
  set: Aa,
  timestamp: jn
}, Ov = {
  "tag:yaml.org,2002:binary": Sa,
  "tag:yaml.org,2002:merge": Wt,
  "tag:yaml.org,2002:omap": Da,
  "tag:yaml.org,2002:pairs": Ca,
  "tag:yaml.org,2002:set": Aa,
  "tag:yaml.org,2002:timestamp": jn
};
function _o(s, e, t) {
  const i = Lc.get(e);
  if (i && !s)
    return t && !i.includes(Wt) ? i.concat(Wt) : i.slice();
  let r = i;
  if (!r)
    if (Array.isArray(s))
      r = [];
    else {
      const n = Array.from(Lc.keys()).filter((o) => o !== "yaml11").map((o) => JSON.stringify(o)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${n} or define customTags array`);
    }
  if (Array.isArray(s))
    for (const n of s)
      r = r.concat(n);
  else typeof s == "function" && (r = s(r.slice()));
  return t && (r = r.concat(Wt)), r.reduce((n, o) => {
    const a = typeof o == "string" ? Mc[o] : o;
    if (!a) {
      const l = JSON.stringify(o), c = Object.keys(Mc).map((u) => JSON.stringify(u)).join(", ");
      throw new Error(`Unknown custom tag ${l}; use one of ${c}`);
    }
    return n.includes(a) || n.push(a), n;
  }, []);
}
const Pv = (s, e) => s.key < e.key ? -1 : s.key > e.key ? 1 : 0;
class Un {
  constructor({ compat: e, customTags: t, merge: i, resolveKnownTags: r, schema: n, sortMapEntries: o, toStringDefaults: a }) {
    this.compat = Array.isArray(e) ? _o(e, "compat") : e ? _o(null, e) : null, this.name = typeof n == "string" && n || "core", this.knownTags = r ? Ov : {}, this.tags = _o(t, this.name, i), this.toStringOptions = a ?? null, Object.defineProperty(this, rs, { value: _i }), Object.defineProperty(this, Mt, { value: Nn }), Object.defineProperty(this, mi, { value: yi }), this.sortMapEntries = typeof o == "function" ? o : o === !0 ? Pv : null;
  }
  clone() {
    const e = Object.create(Un.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
}
function Bv(s, e) {
  var l;
  const t = [];
  let i = e.directives === !0;
  if (e.directives !== !1 && s.directives) {
    const c = s.directives.toString(s);
    c ? (t.push(c), i = !0) : s.directives.docStart && (i = !0);
  }
  i && t.push("---");
  const r = ld(s, e), { commentString: n } = r.options;
  if (s.commentBefore) {
    t.length !== 1 && t.unshift("");
    const c = n(s.commentBefore);
    t.unshift(Ut(c, ""));
  }
  let o = !1, a = null;
  if (s.contents) {
    if (Ae(s.contents)) {
      if (s.contents.spaceBefore && i && t.push(""), s.contents.commentBefore) {
        const h = n(s.contents.commentBefore);
        t.push(Ut(h, ""));
      }
      r.forceBlockIndent = !!s.comment, a = s.contents.comment;
    }
    const c = a ? void 0 : () => o = !0;
    let u = ui(s.contents, r, () => a = null, c);
    a && (u += ws(u, "", n(a))), (u[0] === "|" || u[0] === ">") && t[t.length - 1] === "---" ? t[t.length - 1] = `--- ${u}` : t.push(u);
  } else
    t.push(ui(s.contents, r));
  if ((l = s.directives) != null && l.docEnd)
    if (s.comment) {
      const c = n(s.comment);
      c.includes(`
`) ? (t.push("..."), t.push(Ut(c, ""))) : t.push(`... ${c}`);
    } else
      t.push("...");
  else {
    let c = s.comment;
    c && o && (c = c.replace(/^\n+/, "")), c && ((!o || a) && t[t.length - 1] !== "" && t.push(""), t.push(Ut(n(c), "")));
  }
  return t.join(`
`) + `
`;
}
let Wn = class Ad {
  constructor(e, t, i) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, pt, { value: Wo });
    let r = null;
    typeof t == "function" || Array.isArray(t) ? r = t : i === void 0 && t && (i = t, t = void 0);
    const n = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, i);
    this.options = n;
    let { version: o } = n;
    i != null && i._directives ? (this.directives = i._directives.atDocument(), this.directives.yaml.explicit && (o = this.directives.yaml.version)) : this.directives = new Ze({ version: o }), this.setSchema(o, i), this.contents = e === void 0 ? null : this.createNode(e, r, i);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(Ad.prototype, {
      [pt]: { value: Wo }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = Ae(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    Ys(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, t) {
    Ys(this.contents) && this.contents.addIn(e, t);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, t) {
    if (!e.anchor) {
      const i = id(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !t || i.has(t) ? rd(t || "a", i) : t;
    }
    return new Rn(e.anchor);
  }
  createNode(e, t, i) {
    let r;
    if (typeof t == "function")
      e = t.call({ "": e }, "", e), r = t;
    else if (Array.isArray(t)) {
      const d = (g) => typeof g == "number" || g instanceof String || g instanceof Number, p = t.filter(d).map(String);
      p.length > 0 && (t = t.concat(p)), r = t;
    } else i === void 0 && t && (i = t, t = void 0);
    const { aliasDuplicateObjects: n, anchorPrefix: o, flow: a, keepUndefined: l, onTagObj: c, tag: u } = i ?? {}, { onAnchor: h, setAnchors: f, sourceObjects: m } = dv(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      o || "a"
    ), _ = {
      aliasDuplicateObjects: n ?? !0,
      keepUndefined: l ?? !1,
      onAnchor: h,
      onTagObj: c,
      replacer: r,
      schema: this.schema,
      sourceObjects: m
    }, v = ar(e, u, _);
    return a && $e(v) && (v.flow = !0), f(), v;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, t, i = {}) {
    const r = this.createNode(e, null, i), n = this.createNode(t, null, i);
    return new Ge(r, n);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return Ys(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return Fi(e) ? this.contents == null ? !1 : (this.contents = null, !0) : Ys(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, t) {
    return $e(this.contents) ? this.contents.get(e, t) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, t) {
    return Fi(e) ? !t && ge(this.contents) ? this.contents.value : this.contents : $e(this.contents) ? this.contents.getIn(e, t) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return $e(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return Fi(e) ? this.contents !== void 0 : $e(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, t) {
    this.contents == null ? this.contents = bn(this.schema, [e], t) : Ys(this.contents) && this.contents.set(e, t);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, t) {
    Fi(e) ? this.contents = t : this.contents == null ? this.contents = bn(this.schema, Array.from(e), t) : Ys(this.contents) && this.contents.setIn(e, t);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, t = {}) {
    typeof e == "number" && (e = String(e));
    let i;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Ze({ version: "1.1" }), i = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Ze({ version: e }), i = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, i = null;
        break;
      default: {
        const r = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${r}`);
      }
    }
    if (t.schema instanceof Object)
      this.schema = t.schema;
    else if (i)
      this.schema = new Un(Object.assign(i, t));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: t, mapAsMap: i, maxAliasCount: r, onAnchor: n, reviver: o } = {}) {
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: i === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof r == "number" ? r : 100
    }, l = ft(this.contents, t ?? "", a);
    if (typeof n == "function")
      for (const { count: c, res: u } of a.anchors.values())
        n(u, c);
    return typeof o == "function" ? ei(o, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, t) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: t });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const t = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${t}`);
    }
    return Bv(this, e);
  }
};
function Ys(s) {
  if ($e(s))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class Ta extends Error {
  constructor(e, t, i, r) {
    super(), this.name = e, this.code = i, this.message = r, this.pos = t;
  }
}
class ks extends Ta {
  constructor(e, t, i) {
    super("YAMLParseError", e, t, i);
  }
}
class Ed extends Ta {
  constructor(e, t, i) {
    super("YAMLWarning", e, t, i);
  }
}
const _n = (s, e) => (t) => {
  if (t.pos[0] === -1)
    return;
  t.linePos = t.pos.map((a) => e.linePos(a));
  const { line: i, col: r } = t.linePos[0];
  t.message += ` at line ${i}, column ${r}`;
  let n = r - 1, o = s.substring(e.lineStarts[i - 1], e.lineStarts[i]).replace(/[\n\r]+$/, "");
  if (n >= 60 && o.length > 80) {
    const a = Math.min(n - 39, o.length - 79);
    o = "" + o.substring(a), n -= a - 1;
  }
  if (o.length > 80 && (o = o.substring(0, 79) + ""), i > 1 && /^ *$/.test(o.substring(0, n))) {
    let a = s.substring(e.lineStarts[i - 2], e.lineStarts[i - 1]);
    a.length > 80 && (a = a.substring(0, 79) + `
`), o = a + o;
  }
  if (/[^ ]/.test(o)) {
    let a = 1;
    const l = t.linePos[1];
    l && l.line === i && l.col > r && (a = Math.max(1, Math.min(l.col - r, 80 - n)));
    const c = " ".repeat(n) + "^".repeat(a);
    t.message += `:

${o}
${c}
`;
  }
};
function fi(s, { flow: e, indicator: t, next: i, offset: r, onError: n, parentIndent: o, startOnNewline: a }) {
  let l = !1, c = a, u = a, h = "", f = "", m = !1, _ = !1, v = null, d = null, p = null, g = null, b = null, y = null, w = null;
  for (const x of s)
    switch (_ && (x.type !== "space" && x.type !== "newline" && x.type !== "comma" && n(x.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), _ = !1), v && (c && x.type !== "comment" && x.type !== "newline" && n(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), v = null), x.type) {
      case "space":
        !e && (t !== "doc-start" || (i == null ? void 0 : i.type) !== "flow-collection") && x.source.includes("	") && (v = x), u = !0;
        break;
      case "comment": {
        u || n(x, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const S = x.source.substring(1) || " ";
        h ? h += f + S : h = S, f = "", c = !1;
        break;
      }
      case "newline":
        c ? h ? h += x.source : (!y || t !== "seq-item-ind") && (l = !0) : f += x.source, c = !0, m = !0, (d || p) && (g = x), u = !0;
        break;
      case "anchor":
        d && n(x, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), x.source.endsWith(":") && n(x.offset + x.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), d = x, w ?? (w = x.offset), c = !1, u = !1, _ = !0;
        break;
      case "tag": {
        p && n(x, "MULTIPLE_TAGS", "A node can have at most one tag"), p = x, w ?? (w = x.offset), c = !1, u = !1, _ = !0;
        break;
      }
      case t:
        (d || p) && n(x, "BAD_PROP_ORDER", `Anchors and tags must be after the ${x.source} indicator`), y && n(x, "UNEXPECTED_TOKEN", `Unexpected ${x.source} in ${e ?? "collection"}`), y = x, c = t === "seq-item-ind" || t === "explicit-key-ind", u = !1;
        break;
      case "comma":
        if (e) {
          b && n(x, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), b = x, c = !1, u = !1;
          break;
        }
      default:
        n(x, "UNEXPECTED_TOKEN", `Unexpected ${x.type} token`), c = !1, u = !1;
    }
  const k = s[s.length - 1], C = k ? k.offset + k.source.length : r;
  return _ && i && i.type !== "space" && i.type !== "newline" && i.type !== "comma" && (i.type !== "scalar" || i.source !== "") && n(i.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), v && (c && v.indent <= o || (i == null ? void 0 : i.type) === "block-map" || (i == null ? void 0 : i.type) === "block-seq") && n(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: b,
    found: y,
    spaceBefore: l,
    comment: h,
    hasNewline: m,
    anchor: d,
    tag: p,
    newlineAfterProp: g,
    end: C,
    start: w ?? C
  };
}
function lr(s) {
  if (!s)
    return null;
  switch (s.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (s.source.includes(`
`))
        return !0;
      if (s.end) {
        for (const e of s.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of s.items) {
        for (const t of e.start)
          if (t.type === "newline")
            return !0;
        if (e.sep) {
          for (const t of e.sep)
            if (t.type === "newline")
              return !0;
        }
        if (lr(e.key) || lr(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function Qo(s, e, t) {
  if ((e == null ? void 0 : e.type) === "flow-collection") {
    const i = e.end[0];
    i.indent === s && (i.source === "]" || i.source === "}") && lr(e) && t(i, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function Td(s, e, t) {
  const { uniqueKeys: i } = s.options;
  if (i === !1)
    return !1;
  const r = typeof i == "function" ? i : (n, o) => n === o || ge(n) && ge(o) && n.value === o.value;
  return e.some((n) => r(n.key, t));
}
const Ic = "All mapping items must start at the same column";
function Nv({ composeNode: s, composeEmptyNode: e }, t, i, r, n) {
  var u;
  const o = (n == null ? void 0 : n.nodeClass) ?? ht, a = new o(t.schema);
  t.atRoot && (t.atRoot = !1);
  let l = i.offset, c = null;
  for (const h of i.items) {
    const { start: f, key: m, sep: _, value: v } = h, d = fi(f, {
      indicator: "explicit-key-ind",
      next: m ?? (_ == null ? void 0 : _[0]),
      offset: l,
      onError: r,
      parentIndent: i.indent,
      startOnNewline: !0
    }), p = !d.found;
    if (p) {
      if (m && (m.type === "block-seq" ? r(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in m && m.indent !== i.indent && r(l, "BAD_INDENT", Ic)), !d.anchor && !d.tag && !_) {
        c = d.end, d.comment && (a.comment ? a.comment += `
` + d.comment : a.comment = d.comment);
        continue;
      }
      (d.newlineAfterProp || lr(m)) && r(m ?? f[f.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else ((u = d.found) == null ? void 0 : u.indent) !== i.indent && r(l, "BAD_INDENT", Ic);
    t.atKey = !0;
    const g = d.end, b = m ? s(t, m, d, r) : e(t, g, f, null, d, r);
    t.schema.compat && Qo(i.indent, m, r), t.atKey = !1, Td(t, a.items, b) && r(g, "DUPLICATE_KEY", "Map keys must be unique");
    const y = fi(_ ?? [], {
      indicator: "map-value-ind",
      next: v,
      offset: b.range[2],
      onError: r,
      parentIndent: i.indent,
      startOnNewline: !m || m.type === "block-scalar"
    });
    if (l = y.end, y.found) {
      p && ((v == null ? void 0 : v.type) === "block-map" && !y.hasNewline && r(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), t.options.strict && d.start < y.found.offset - 1024 && r(b.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const w = v ? s(t, v, y, r) : e(t, l, _, null, y, r);
      t.schema.compat && Qo(i.indent, v, r), l = w.range[2];
      const k = new Ge(b, w);
      t.options.keepSourceTokens && (k.srcToken = h), a.items.push(k);
    } else {
      p && r(b.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), y.comment && (b.comment ? b.comment += `
` + y.comment : b.comment = y.comment);
      const w = new Ge(b);
      t.options.keepSourceTokens && (w.srcToken = h), a.items.push(w);
    }
  }
  return c && c < l && r(c, "IMPOSSIBLE", "Map comment with trailing content"), a.range = [i.offset, l, c ?? l], a;
}
function Fv({ composeNode: s, composeEmptyNode: e }, t, i, r, n) {
  const o = (n == null ? void 0 : n.nodeClass) ?? ls, a = new o(t.schema);
  t.atRoot && (t.atRoot = !1), t.atKey && (t.atKey = !1);
  let l = i.offset, c = null;
  for (const { start: u, value: h } of i.items) {
    const f = fi(u, {
      indicator: "seq-item-ind",
      next: h,
      offset: l,
      onError: r,
      parentIndent: i.indent,
      startOnNewline: !0
    });
    if (!f.found)
      if (f.anchor || f.tag || h)
        h && h.type === "block-seq" ? r(f.end, "BAD_INDENT", "All sequence items must start at the same column") : r(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c = f.end, f.comment && (a.comment = f.comment);
        continue;
      }
    const m = h ? s(t, h, f, r) : e(t, f.end, u, null, f, r);
    t.schema.compat && Qo(i.indent, h, r), l = m.range[2], a.items.push(m);
  }
  return a.range = [i.offset, l, c ?? l], a;
}
function yr(s, e, t, i) {
  let r = "";
  if (s) {
    let n = !1, o = "";
    for (const a of s) {
      const { source: l, type: c } = a;
      switch (c) {
        case "space":
          n = !0;
          break;
        case "comment": {
          t && !n && i(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const u = l.substring(1) || " ";
          r ? r += o + u : r = u, o = "";
          break;
        }
        case "newline":
          r && (o += l), n = !0;
          break;
        default:
          i(a, "UNEXPECTED_TOKEN", `Unexpected ${c} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: r, offset: e };
}
const yo = "Block collections are not allowed within flow collections", wo = (s) => s && (s.type === "block-map" || s.type === "block-seq");
function zv({ composeNode: s, composeEmptyNode: e }, t, i, r, n) {
  const o = i.start.source === "{", a = o ? "flow map" : "flow sequence", l = (n == null ? void 0 : n.nodeClass) ?? (o ? ht : ls), c = new l(t.schema);
  c.flow = !0;
  const u = t.atRoot;
  u && (t.atRoot = !1), t.atKey && (t.atKey = !1);
  let h = i.offset + i.start.source.length;
  for (let d = 0; d < i.items.length; ++d) {
    const p = i.items[d], { start: g, key: b, sep: y, value: w } = p, k = fi(g, {
      flow: a,
      indicator: "explicit-key-ind",
      next: b ?? (y == null ? void 0 : y[0]),
      offset: h,
      onError: r,
      parentIndent: i.indent,
      startOnNewline: !1
    });
    if (!k.found) {
      if (!k.anchor && !k.tag && !y && !w) {
        d === 0 && k.comma ? r(k.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`) : d < i.items.length - 1 && r(k.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a}`), k.comment && (c.comment ? c.comment += `
` + k.comment : c.comment = k.comment), h = k.end;
        continue;
      }
      !o && t.options.strict && lr(b) && r(
        b,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (d === 0)
      k.comma && r(k.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`);
    else if (k.comma || r(k.start, "MISSING_CHAR", `Missing , between ${a} items`), k.comment) {
      let C = "";
      e: for (const x of g)
        switch (x.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            C = x.source.substring(1);
            break e;
          default:
            break e;
        }
      if (C) {
        let x = c.items[c.items.length - 1];
        Se(x) && (x = x.value ?? x.key), x.comment ? x.comment += `
` + C : x.comment = C, k.comment = k.comment.substring(C.length + 1);
      }
    }
    if (!o && !y && !k.found) {
      const C = w ? s(t, w, k, r) : e(t, k.end, y, null, k, r);
      c.items.push(C), h = C.range[2], wo(w) && r(C.range, "BLOCK_IN_FLOW", yo);
    } else {
      t.atKey = !0;
      const C = k.end, x = b ? s(t, b, k, r) : e(t, C, g, null, k, r);
      wo(b) && r(x.range, "BLOCK_IN_FLOW", yo), t.atKey = !1;
      const S = fi(y ?? [], {
        flow: a,
        indicator: "map-value-ind",
        next: w,
        offset: x.range[2],
        onError: r,
        parentIndent: i.indent,
        startOnNewline: !1
      });
      if (S.found) {
        if (!o && !k.found && t.options.strict) {
          if (y)
            for (const E of y) {
              if (E === S.found)
                break;
              if (E.type === "newline") {
                r(E, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          k.start < S.found.offset - 1024 && r(S.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else w && ("source" in w && w.source && w.source[0] === ":" ? r(w, "MISSING_CHAR", `Missing space after : in ${a}`) : r(S.start, "MISSING_CHAR", `Missing , or : between ${a} items`));
      const T = w ? s(t, w, S, r) : S.found ? e(t, S.end, y, null, S, r) : null;
      T ? wo(w) && r(T.range, "BLOCK_IN_FLOW", yo) : S.comment && (x.comment ? x.comment += `
` + S.comment : x.comment = S.comment);
      const M = new Ge(x, T);
      if (t.options.keepSourceTokens && (M.srcToken = p), o) {
        const E = c;
        Td(t, E.items, x) && r(C, "DUPLICATE_KEY", "Map keys must be unique"), E.items.push(M);
      } else {
        const E = new ht(t.schema);
        E.flow = !0, E.items.push(M);
        const R = (T ?? x).range;
        E.range = [x.range[0], R[1], R[2]], c.items.push(E);
      }
      h = T ? T.range[2] : S.end;
    }
  }
  const f = o ? "}" : "]", [m, ..._] = i.end;
  let v = h;
  if (m && m.source === f)
    v = m.offset + m.source.length;
  else {
    const d = a[0].toUpperCase() + a.substring(1), p = u ? `${d} must end with a ${f}` : `${d} in block collection must be sufficiently indented and end with a ${f}`;
    r(h, u ? "MISSING_CHAR" : "BAD_INDENT", p), m && m.source.length !== 1 && _.unshift(m);
  }
  if (_.length > 0) {
    const d = yr(_, v, t.options.strict, r);
    d.comment && (c.comment ? c.comment += `
` + d.comment : c.comment = d.comment), c.range = [i.offset, v, d.offset];
  } else
    c.range = [i.offset, v, v];
  return c;
}
function xo(s, e, t, i, r, n) {
  const o = t.type === "block-map" ? Nv(s, e, t, i, n) : t.type === "block-seq" ? Fv(s, e, t, i, n) : zv(s, e, t, i, n), a = o.constructor;
  return r === "!" || r === a.tagName ? (o.tag = a.tagName, o) : (r && (o.tag = r), o);
}
function Hv(s, e, t, i, r) {
  var f;
  const n = i.tag, o = n ? e.directives.tagName(n.source, (m) => r(n, "TAG_RESOLVE_FAILED", m)) : null;
  if (t.type === "block-seq") {
    const { anchor: m, newlineAfterProp: _ } = i, v = m && n ? m.offset > n.offset ? m : n : m ?? n;
    v && (!_ || _.offset < v.offset) && r(v, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const a = t.type === "block-map" ? "map" : t.type === "block-seq" ? "seq" : t.start.source === "{" ? "map" : "seq";
  if (!n || !o || o === "!" || o === ht.tagName && a === "map" || o === ls.tagName && a === "seq")
    return xo(s, e, t, r, o);
  let l = e.schema.tags.find((m) => m.tag === o && m.collection === a);
  if (!l) {
    const m = e.schema.knownTags[o];
    if (m && m.collection === a)
      e.schema.tags.push(Object.assign({}, m, { default: !1 })), l = m;
    else
      return m ? r(n, "BAD_COLLECTION_TYPE", `${m.tag} used for ${a} collection, but expects ${m.collection ?? "scalar"}`, !0) : r(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${o}`, !0), xo(s, e, t, r, o);
  }
  const c = xo(s, e, t, r, o, l), u = ((f = l.resolve) == null ? void 0 : f.call(l, c, (m) => r(n, "TAG_RESOLVE_FAILED", m), e.options)) ?? c, h = Ae(u) ? u : new te(u);
  return h.range = c.range, h.tag = o, l != null && l.format && (h.format = l.format), h;
}
function Ld(s, e, t) {
  const i = e.offset, r = jv(e, s.options.strict, t);
  if (!r)
    return { value: "", type: null, comment: "", range: [i, i, i] };
  const n = r.mode === ">" ? te.BLOCK_FOLDED : te.BLOCK_LITERAL, o = e.source ? Uv(e.source) : [];
  let a = o.length;
  for (let v = o.length - 1; v >= 0; --v) {
    const d = o[v][1];
    if (d === "" || d === "\r")
      a = v;
    else
      break;
  }
  if (a === 0) {
    const v = r.chomp === "+" && o.length > 0 ? `
`.repeat(Math.max(1, o.length - 1)) : "";
    let d = i + r.length;
    return e.source && (d += e.source.length), { value: v, type: n, comment: r.comment, range: [i, d, d] };
  }
  let l = e.indent + r.indent, c = e.offset + r.length, u = 0;
  for (let v = 0; v < a; ++v) {
    const [d, p] = o[v];
    if (p === "" || p === "\r")
      r.indent === 0 && d.length > l && (l = d.length);
    else {
      d.length < l && t(c + d.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), r.indent === 0 && (l = d.length), u = v, l === 0 && !s.atRoot && t(c, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    c += d.length + p.length + 1;
  }
  for (let v = o.length - 1; v >= a; --v)
    o[v][0].length > l && (a = v + 1);
  let h = "", f = "", m = !1;
  for (let v = 0; v < u; ++v)
    h += o[v][0].slice(l) + `
`;
  for (let v = u; v < a; ++v) {
    let [d, p] = o[v];
    c += d.length + p.length + 1;
    const g = p[p.length - 1] === "\r";
    if (g && (p = p.slice(0, -1)), p && d.length < l) {
      const y = `Block scalar lines must not be less indented than their ${r.indent ? "explicit indentation indicator" : "first line"}`;
      t(c - p.length - (g ? 2 : 1), "BAD_INDENT", y), d = "";
    }
    n === te.BLOCK_LITERAL ? (h += f + d.slice(l) + p, f = `
`) : d.length > l || p[0] === "	" ? (f === " " ? f = `
` : !m && f === `
` && (f = `

`), h += f + d.slice(l) + p, f = `
`, m = !0) : p === "" ? f === `
` ? h += `
` : f = `
` : (h += f + p, f = " ", m = !1);
  }
  switch (r.chomp) {
    case "-":
      break;
    case "+":
      for (let v = a; v < o.length; ++v)
        h += `
` + o[v][0].slice(l);
      h[h.length - 1] !== `
` && (h += `
`);
      break;
    default:
      h += `
`;
  }
  const _ = i + r.length + e.source.length;
  return { value: h, type: n, comment: r.comment, range: [i, _, _] };
}
function jv({ offset: s, props: e }, t, i) {
  if (e[0].type !== "block-scalar-header")
    return i(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: r } = e[0], n = r[0];
  let o = 0, a = "", l = -1;
  for (let f = 1; f < r.length; ++f) {
    const m = r[f];
    if (!a && (m === "-" || m === "+"))
      a = m;
    else {
      const _ = Number(m);
      !o && _ ? o = _ : l === -1 && (l = s + f);
    }
  }
  l !== -1 && i(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${r}`);
  let c = !1, u = "", h = r.length;
  for (let f = 1; f < e.length; ++f) {
    const m = e[f];
    switch (m.type) {
      case "space":
        c = !0;
      case "newline":
        h += m.source.length;
        break;
      case "comment":
        t && !c && i(m, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), h += m.source.length, u = m.source.substring(1);
        break;
      case "error":
        i(m, "UNEXPECTED_TOKEN", m.message), h += m.source.length;
        break;
      default: {
        const _ = `Unexpected token in block scalar header: ${m.type}`;
        i(m, "UNEXPECTED_TOKEN", _);
        const v = m.source;
        v && typeof v == "string" && (h += v.length);
      }
    }
  }
  return { mode: n, indent: o, chomp: a, comment: u, length: h };
}
function Uv(s) {
  const e = s.split(/\n( *)/), t = e[0], i = t.match(/^( *)/), n = [i != null && i[1] ? [i[1], t.slice(i[1].length)] : ["", t]];
  for (let o = 1; o < e.length; o += 2)
    n.push([e[o], e[o + 1]]);
  return n;
}
function Md(s, e, t) {
  const { offset: i, type: r, source: n, end: o } = s;
  let a, l;
  const c = (f, m, _) => t(i + f, m, _);
  switch (r) {
    case "scalar":
      a = te.PLAIN, l = Wv(n, c);
      break;
    case "single-quoted-scalar":
      a = te.QUOTE_SINGLE, l = Vv(n, c);
      break;
    case "double-quoted-scalar":
      a = te.QUOTE_DOUBLE, l = qv(n, c);
      break;
    default:
      return t(s, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${r}`), {
        value: "",
        type: null,
        comment: "",
        range: [i, i + n.length, i + n.length]
      };
  }
  const u = i + n.length, h = yr(o, u, e, t);
  return {
    value: l,
    type: a,
    comment: h.comment,
    range: [i, u, h.offset]
  };
}
function Wv(s, e) {
  let t = "";
  switch (s[0]) {
    case "	":
      t = "a tab character";
      break;
    case ",":
      t = "flow indicator character ,";
      break;
    case "%":
      t = "directive indicator character %";
      break;
    case "|":
    case ">": {
      t = `block scalar indicator ${s[0]}`;
      break;
    }
    case "@":
    case "`": {
      t = `reserved character ${s[0]}`;
      break;
    }
  }
  return t && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${t}`), Id(s);
}
function Vv(s, e) {
  return (s[s.length - 1] !== "'" || s.length === 1) && e(s.length, "MISSING_CHAR", "Missing closing 'quote"), Id(s.slice(1, -1)).replace(/''/g, "'");
}
function Id(s) {
  let e, t;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), t = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, t = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let i = e.exec(s);
  if (!i)
    return s;
  let r = i[1], n = " ", o = e.lastIndex;
  for (t.lastIndex = o; i = t.exec(s); )
    i[1] === "" ? n === `
` ? r += n : n = `
` : (r += n + i[1], n = " "), o = t.lastIndex;
  const a = /[ \t]*(.*)/sy;
  return a.lastIndex = o, i = a.exec(s), r + n + ((i == null ? void 0 : i[1]) ?? "");
}
function qv(s, e) {
  let t = "";
  for (let i = 1; i < s.length - 1; ++i) {
    const r = s[i];
    if (!(r === "\r" && s[i + 1] === `
`))
      if (r === `
`) {
        const { fold: n, offset: o } = Kv(s, i);
        t += n, i = o;
      } else if (r === "\\") {
        let n = s[++i];
        const o = Qv[n];
        if (o)
          t += o;
        else if (n === `
`)
          for (n = s[i + 1]; n === " " || n === "	"; )
            n = s[++i + 1];
        else if (n === "\r" && s[i + 1] === `
`)
          for (n = s[++i + 1]; n === " " || n === "	"; )
            n = s[++i + 1];
        else if (n === "x" || n === "u" || n === "U") {
          const a = { x: 2, u: 4, U: 8 }[n];
          t += Yv(s, i + 1, a, e), i += a;
        } else {
          const a = s.substr(i - 1, 2);
          e(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), t += a;
        }
      } else if (r === " " || r === "	") {
        const n = i;
        let o = s[i + 1];
        for (; o === " " || o === "	"; )
          o = s[++i + 1];
        o !== `
` && !(o === "\r" && s[i + 2] === `
`) && (t += i > n ? s.slice(n, i + 1) : r);
      } else
        t += r;
  }
  return (s[s.length - 1] !== '"' || s.length === 1) && e(s.length, "MISSING_CHAR", 'Missing closing "quote'), t;
}
function Kv(s, e) {
  let t = "", i = s[e + 1];
  for (; (i === " " || i === "	" || i === `
` || i === "\r") && !(i === "\r" && s[e + 2] !== `
`); )
    i === `
` && (t += `
`), e += 1, i = s[e + 1];
  return t || (t = " "), { fold: t, offset: e };
}
const Qv = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: "",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function Yv(s, e, t, i) {
  const r = s.substr(e, t), o = r.length === t && /^[0-9a-fA-F]+$/.test(r) ? parseInt(r, 16) : NaN;
  if (isNaN(o)) {
    const a = s.substr(e - 2, t + 2);
    return i(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), a;
  }
  return String.fromCodePoint(o);
}
function Rd(s, e, t, i) {
  const { value: r, type: n, comment: o, range: a } = e.type === "block-scalar" ? Ld(s, e, i) : Md(e, s.options.strict, i), l = t ? s.directives.tagName(t.source, (h) => i(t, "TAG_RESOLVE_FAILED", h)) : null;
  let c;
  s.options.stringKeys && s.atKey ? c = s.schema[Mt] : l ? c = Gv(s.schema, r, l, t, i) : e.type === "scalar" ? c = Xv(s, r, e, i) : c = s.schema[Mt];
  let u;
  try {
    const h = c.resolve(r, (f) => i(t ?? e, "TAG_RESOLVE_FAILED", f), s.options);
    u = ge(h) ? h : new te(h);
  } catch (h) {
    const f = h instanceof Error ? h.message : String(h);
    i(t ?? e, "TAG_RESOLVE_FAILED", f), u = new te(r);
  }
  return u.range = a, u.source = r, n && (u.type = n), l && (u.tag = l), c.format && (u.format = c.format), o && (u.comment = o), u;
}
function Gv(s, e, t, i, r) {
  var a;
  if (t === "!")
    return s[Mt];
  const n = [];
  for (const l of s.tags)
    if (!l.collection && l.tag === t)
      if (l.default && l.test)
        n.push(l);
      else
        return l;
  for (const l of n)
    if ((a = l.test) != null && a.test(e))
      return l;
  const o = s.knownTags[t];
  return o && !o.collection ? (s.tags.push(Object.assign({}, o, { default: !1, test: void 0 })), o) : (r(i, "TAG_RESOLVE_FAILED", `Unresolved tag: ${t}`, t !== "tag:yaml.org,2002:str"), s[Mt]);
}
function Xv({ atKey: s, directives: e, schema: t }, i, r, n) {
  const o = t.tags.find((a) => {
    var l;
    return (a.default === !0 || s && a.default === "key") && ((l = a.test) == null ? void 0 : l.test(i));
  }) || t[Mt];
  if (t.compat) {
    const a = t.compat.find((l) => {
      var c;
      return l.default && ((c = l.test) == null ? void 0 : c.test(i));
    }) ?? t[Mt];
    if (o.tag !== a.tag) {
      const l = e.tagString(o.tag), c = e.tagString(a.tag), u = `Value may be parsed as either ${l} or ${c}`;
      n(r, "TAG_RESOLVE_FAILED", u, !0);
    }
  }
  return o;
}
function Jv(s, e, t) {
  if (e) {
    t ?? (t = e.length);
    for (let i = t - 1; i >= 0; --i) {
      let r = e[i];
      switch (r.type) {
        case "space":
        case "comment":
        case "newline":
          s -= r.source.length;
          continue;
      }
      for (r = e[++i]; (r == null ? void 0 : r.type) === "space"; )
        s += r.source.length, r = e[++i];
      break;
    }
  }
  return s;
}
const Zv = { composeNode: Od, composeEmptyNode: La };
function Od(s, e, t, i) {
  const r = s.atKey, { spaceBefore: n, comment: o, anchor: a, tag: l } = t;
  let c, u = !0;
  switch (e.type) {
    case "alias":
      c = e_(s, e, i), (a || l) && i(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      c = Rd(s, e, l, i), a && (c.anchor = a.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      c = Hv(Zv, s, e, t, i), a && (c.anchor = a.source.substring(1));
      break;
    default: {
      const h = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      i(e, "UNEXPECTED_TOKEN", h), c = La(s, e.offset, void 0, null, t, i), u = !1;
    }
  }
  return a && c.anchor === "" && i(a, "BAD_ALIAS", "Anchor cannot be an empty string"), r && s.options.stringKeys && (!ge(c) || typeof c.value != "string" || c.tag && c.tag !== "tag:yaml.org,2002:str") && i(l ?? e, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), n && (c.spaceBefore = !0), o && (e.type === "scalar" && e.source === "" ? c.comment = o : c.commentBefore = o), s.options.keepSourceTokens && u && (c.srcToken = e), c;
}
function La(s, e, t, i, { spaceBefore: r, comment: n, anchor: o, tag: a, end: l }, c) {
  const u = {
    type: "scalar",
    offset: Jv(e, t, i),
    indent: -1,
    source: ""
  }, h = Rd(s, u, a, c);
  return o && (h.anchor = o.source.substring(1), h.anchor === "" && c(o, "BAD_ALIAS", "Anchor cannot be an empty string")), r && (h.spaceBefore = !0), n && (h.comment = n, h.range[2] = l), h;
}
function e_({ options: s }, { offset: e, source: t, end: i }, r) {
  const n = new Rn(t.substring(1));
  n.source === "" && r(e, "BAD_ALIAS", "Alias cannot be an empty string"), n.source.endsWith(":") && r(e + t.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const o = e + t.length, a = yr(i, o, s.strict, r);
  return n.range = [e, o, a.offset], a.comment && (n.comment = a.comment), n;
}
function t_(s, e, { offset: t, start: i, value: r, end: n }, o) {
  const a = Object.assign({ _directives: e }, s), l = new Wn(void 0, a), c = {
    atKey: !1,
    atRoot: !0,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, u = fi(i, {
    indicator: "doc-start",
    next: r ?? (n == null ? void 0 : n[0]),
    offset: t,
    onError: o,
    parentIndent: 0,
    startOnNewline: !0
  });
  u.found && (l.directives.docStart = !0, r && (r.type === "block-map" || r.type === "block-seq") && !u.hasNewline && o(u.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = r ? Od(c, r, u, o) : La(c, u.end, i, null, u, o);
  const h = l.contents.range[2], f = yr(n, h, !1, o);
  return f.comment && (l.comment = f.comment), l.range = [t, h, f.offset], l;
}
function Li(s) {
  if (typeof s == "number")
    return [s, s + 1];
  if (Array.isArray(s))
    return s.length === 2 ? s : [s[0], s[1]];
  const { offset: e, source: t } = s;
  return [e, e + (typeof t == "string" ? t.length : 1)];
}
function Rc(s) {
  var r;
  let e = "", t = !1, i = !1;
  for (let n = 0; n < s.length; ++n) {
    const o = s[n];
    switch (o[0]) {
      case "#":
        e += (e === "" ? "" : i ? `

` : `
`) + (o.substring(1) || " "), t = !0, i = !1;
        break;
      case "%":
        ((r = s[n + 1]) == null ? void 0 : r[0]) !== "#" && (n += 1), t = !1;
        break;
      default:
        t || (i = !0), t = !1;
    }
  }
  return { comment: e, afterEmptyLine: i };
}
class Ma {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (t, i, r, n) => {
      const o = Li(t);
      n ? this.warnings.push(new Ed(o, i, r)) : this.errors.push(new ks(o, i, r));
    }, this.directives = new Ze({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, t) {
    const { comment: i, afterEmptyLine: r } = Rc(this.prelude);
    if (i) {
      const n = e.contents;
      if (t)
        e.comment = e.comment ? `${e.comment}
${i}` : i;
      else if (r || e.directives.docStart || !n)
        e.commentBefore = i;
      else if ($e(n) && !n.flow && n.items.length > 0) {
        let o = n.items[0];
        Se(o) && (o = o.key);
        const a = o.commentBefore;
        o.commentBefore = a ? `${i}
${a}` : i;
      } else {
        const o = n.commentBefore;
        n.commentBefore = o ? `${i}
${o}` : i;
      }
    }
    t ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: Rc(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, t = !1, i = -1) {
    for (const r of e)
      yield* this.next(r);
    yield* this.end(t, i);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (t, i, r) => {
          const n = Li(e);
          n[0] += t, this.onError(n, "BAD_DIRECTIVE", i, r);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const t = t_(this.options, this.directives, e, this.onError);
        this.atDirectives && !t.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(t, !1), this.doc && (yield this.doc), this.doc = t, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const t = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, i = new ks(Li(e), "UNEXPECTED_TOKEN", t);
        this.atDirectives || !this.doc ? this.errors.push(i) : this.doc.errors.push(i);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const i = "Unexpected doc-end without preceding document";
          this.errors.push(new ks(Li(e), "UNEXPECTED_TOKEN", i));
          break;
        }
        this.doc.directives.docEnd = !0;
        const t = yr(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), t.comment) {
          const i = this.doc.comment;
          this.doc.comment = i ? `${i}
${t.comment}` : t.comment;
        }
        this.doc.range[2] = t.offset;
        break;
      }
      default:
        this.errors.push(new ks(Li(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, t = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const i = Object.assign({ _directives: this.directives }, this.options), r = new Wn(void 0, i);
      this.atDirectives && this.onError(t, "MISSING_CHAR", "Missing directives-end indicator line"), r.range = [0, t, t], this.decorate(r, !1), yield r;
    }
  }
}
function s_(s, e = !0, t) {
  if (s) {
    const i = (r, n, o) => {
      const a = typeof r == "number" ? r : Array.isArray(r) ? r[0] : r.offset;
      if (t)
        t(a, n, o);
      else
        throw new ks([a, a + 1], n, o);
    };
    switch (s.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return Md(s, e, i);
      case "block-scalar":
        return Ld({ options: { strict: e } }, s, i);
    }
  }
  return null;
}
function i_(s, e) {
  const { implicitKey: t = !1, indent: i, inFlow: r = !1, offset: n = -1, type: o = "PLAIN" } = e, a = vr({ type: o, value: s }, {
    implicitKey: t,
    indent: i > 0 ? " ".repeat(i) : "",
    inFlow: r,
    options: { blockQuote: !0, lineWidth: -1 }
  }), l = e.end ?? [
    { type: "newline", offset: -1, indent: i, source: `
` }
  ];
  switch (a[0]) {
    case "|":
    case ">": {
      const c = a.indexOf(`
`), u = a.substring(0, c), h = a.substring(c + 1) + `
`, f = [
        { type: "block-scalar-header", offset: n, indent: i, source: u }
      ];
      return Pd(f, l) || f.push({ type: "newline", offset: -1, indent: i, source: `
` }), { type: "block-scalar", offset: n, indent: i, props: f, source: h };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: n, indent: i, source: a, end: l };
    case "'":
      return { type: "single-quoted-scalar", offset: n, indent: i, source: a, end: l };
    default:
      return { type: "scalar", offset: n, indent: i, source: a, end: l };
  }
}
function r_(s, e, t = {}) {
  let { afterKey: i = !1, implicitKey: r = !1, inFlow: n = !1, type: o } = t, a = "indent" in s ? s.indent : null;
  if (i && typeof a == "number" && (a += 2), !o)
    switch (s.type) {
      case "single-quoted-scalar":
        o = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        o = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const c = s.props[0];
        if (c.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        o = c.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        o = "PLAIN";
    }
  const l = vr({ type: o, value: e }, {
    implicitKey: r || a === null,
    indent: a !== null && a > 0 ? " ".repeat(a) : "",
    inFlow: n,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (l[0]) {
    case "|":
    case ">":
      n_(s, l);
      break;
    case '"':
      ko(s, l, "double-quoted-scalar");
      break;
    case "'":
      ko(s, l, "single-quoted-scalar");
      break;
    default:
      ko(s, l, "scalar");
  }
}
function n_(s, e) {
  const t = e.indexOf(`
`), i = e.substring(0, t), r = e.substring(t + 1) + `
`;
  if (s.type === "block-scalar") {
    const n = s.props[0];
    if (n.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    n.source = i, s.source = r;
  } else {
    const { offset: n } = s, o = "indent" in s ? s.indent : -1, a = [
      { type: "block-scalar-header", offset: n, indent: o, source: i }
    ];
    Pd(a, "end" in s ? s.end : void 0) || a.push({ type: "newline", offset: -1, indent: o, source: `
` });
    for (const l of Object.keys(s))
      l !== "type" && l !== "offset" && delete s[l];
    Object.assign(s, { type: "block-scalar", indent: o, props: a, source: r });
  }
}
function Pd(s, e) {
  if (e)
    for (const t of e)
      switch (t.type) {
        case "space":
        case "comment":
          s.push(t);
          break;
        case "newline":
          return s.push(t), !0;
      }
  return !1;
}
function ko(s, e, t) {
  switch (s.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      s.type = t, s.source = e;
      break;
    case "block-scalar": {
      const i = s.props.slice(1);
      let r = e.length;
      s.props[0].type === "block-scalar-header" && (r -= s.props[0].source.length);
      for (const n of i)
        n.offset += r;
      delete s.props, Object.assign(s, { type: t, source: e, end: i });
      break;
    }
    case "block-map":
    case "block-seq": {
      const r = { type: "newline", offset: s.offset + e.length, indent: s.indent, source: `
` };
      delete s.items, Object.assign(s, { type: t, source: e, end: [r] });
      break;
    }
    default: {
      const i = "indent" in s ? s.indent : -1, r = "end" in s && Array.isArray(s.end) ? s.end.filter((n) => n.type === "space" || n.type === "comment" || n.type === "newline") : [];
      for (const n of Object.keys(s))
        n !== "type" && n !== "offset" && delete s[n];
      Object.assign(s, { type: t, indent: i, source: e, end: r });
    }
  }
}
const o_ = (s) => "type" in s ? yn(s) : rn(s);
function yn(s) {
  switch (s.type) {
    case "block-scalar": {
      let e = "";
      for (const t of s.props)
        e += yn(t);
      return e + s.source;
    }
    case "block-map":
    case "block-seq": {
      let e = "";
      for (const t of s.items)
        e += rn(t);
      return e;
    }
    case "flow-collection": {
      let e = s.start.source;
      for (const t of s.items)
        e += rn(t);
      for (const t of s.end)
        e += t.source;
      return e;
    }
    case "document": {
      let e = rn(s);
      if (s.end)
        for (const t of s.end)
          e += t.source;
      return e;
    }
    default: {
      let e = s.source;
      if ("end" in s && s.end)
        for (const t of s.end)
          e += t.source;
      return e;
    }
  }
}
function rn({ start: s, key: e, sep: t, value: i }) {
  let r = "";
  for (const n of s)
    r += n.source;
  if (e && (r += yn(e)), t)
    for (const n of t)
      r += n.source;
  return i && (r += yn(i)), r;
}
const Yo = Symbol("break visit"), a_ = Symbol("skip children"), Bd = Symbol("remove item");
function Os(s, e) {
  "type" in s && s.type === "document" && (s = { start: s.start, value: s.value }), Nd(Object.freeze([]), s, e);
}
Os.BREAK = Yo;
Os.SKIP = a_;
Os.REMOVE = Bd;
Os.itemAtPath = (s, e) => {
  let t = s;
  for (const [i, r] of e) {
    const n = t == null ? void 0 : t[i];
    if (n && "items" in n)
      t = n.items[r];
    else
      return;
  }
  return t;
};
Os.parentCollection = (s, e) => {
  const t = Os.itemAtPath(s, e.slice(0, -1)), i = e[e.length - 1][0], r = t == null ? void 0 : t[i];
  if (r && "items" in r)
    return r;
  throw new Error("Parent collection not found");
};
function Nd(s, e, t) {
  let i = t(e, s);
  if (typeof i == "symbol")
    return i;
  for (const r of ["key", "value"]) {
    const n = e[r];
    if (n && "items" in n) {
      for (let o = 0; o < n.items.length; ++o) {
        const a = Nd(Object.freeze(s.concat([[r, o]])), n.items[o], t);
        if (typeof a == "number")
          o = a - 1;
        else {
          if (a === Yo)
            return Yo;
          a === Bd && (n.items.splice(o, 1), o -= 1);
        }
      }
      typeof i == "function" && r === "key" && (i = i(e, s));
    }
  }
  return typeof i == "function" ? i(e, s) : i;
}
const Vn = "\uFEFF", qn = "", Kn = "", cr = "", l_ = (s) => !!s && "items" in s, c_ = (s) => !!s && (s.type === "scalar" || s.type === "single-quoted-scalar" || s.type === "double-quoted-scalar" || s.type === "block-scalar");
function h_(s) {
  switch (s) {
    case Vn:
      return "<BOM>";
    case qn:
      return "<DOC>";
    case Kn:
      return "<FLOW_END>";
    case cr:
      return "<SCALAR>";
    default:
      return JSON.stringify(s);
  }
}
function Fd(s) {
  switch (s) {
    case Vn:
      return "byte-order-mark";
    case qn:
      return "doc-mode";
    case Kn:
      return "flow-error-end";
    case cr:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (s[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const d_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: Vn,
  DOCUMENT: qn,
  FLOW_END: Kn,
  SCALAR: cr,
  createScalarToken: i_,
  isCollection: l_,
  isScalar: c_,
  prettyToken: h_,
  resolveAsScalar: s_,
  setScalarValue: r_,
  stringify: o_,
  tokenType: Fd,
  visit: Os
}, Symbol.toStringTag, { value: "Module" }));
function mt(s) {
  switch (s) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const Oc = new Set("0123456789ABCDEFabcdef"), u_ = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), jr = new Set(",[]{}"), f_ = new Set(` ,[]{}
\r	`), So = (s) => !s || f_.has(s);
class zd {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, t = !1) {
    if (e) {
      if (typeof e != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null;
    }
    this.atEnd = !t;
    let i = this.next ?? "stream";
    for (; i && (t || this.hasChars(1)); )
      i = yield* this.parseNext(i);
  }
  atLineEnd() {
    let e = this.pos, t = this.buffer[e];
    for (; t === " " || t === "	"; )
      t = this.buffer[++e];
    return !t || t === "#" || t === `
` ? !0 : t === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let t = this.buffer[e];
    if (this.indentNext > 0) {
      let i = 0;
      for (; t === " "; )
        t = this.buffer[++i + e];
      if (t === "\r") {
        const r = this.buffer[i + e + 1];
        if (r === `
` || !r && !this.atEnd)
          return e + i + 1;
      }
      return t === `
` || i >= this.indentNext || !t && !this.atEnd ? e + i : -1;
    }
    if (t === "-" || t === ".") {
      const i = this.buffer.substr(e, 3);
      if ((i === "---" || i === "...") && mt(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === Vn && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let t = e.length, i = e.indexOf("#");
      for (; i !== -1; ) {
        const n = e[i - 1];
        if (n === " " || n === "	") {
          t = i - 1;
          break;
        } else
          i = e.indexOf("#", i + 1);
      }
      for (; ; ) {
        const n = e[t - 1];
        if (n === " " || n === "	")
          t -= 1;
        else
          break;
      }
      const r = (yield* this.pushCount(t)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - r), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const t = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - t), yield* this.pushNewline(), "stream";
    }
    return yield qn, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const t = this.peek(3);
      if ((t === "---" || t === "...") && mt(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, t === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !mt(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, t] = this.peek(2);
    if (!t && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && mt(t)) {
      const i = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += i, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let t = yield* this.pushIndicators();
    switch (e[t]) {
      case "#":
        yield* this.pushCount(e.length - t);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(So), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return t += yield* this.parseBlockScalarHeader(), t += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - t), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, t, i = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (t = yield* this.pushSpaces(!1), this.indentValue = i = t) : t = 0, t += yield* this.pushSpaces(!0);
    while (e + t > 0);
    const r = this.getLine();
    if (r === null)
      return this.setNext("flow");
    if ((i !== -1 && i < this.indentNext && r[0] !== "#" || i === 0 && (r.startsWith("---") || r.startsWith("...")) && mt(r[3])) && !(i === this.indentNext - 1 && this.flowLevel === 1 && (r[0] === "]" || r[0] === "}")))
      return this.flowLevel = 0, yield Kn, yield* this.parseLineStart();
    let n = 0;
    for (; r[n] === ","; )
      n += yield* this.pushCount(1), n += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (n += yield* this.pushIndicators(), r[n]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(r.length - n), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(So), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const o = this.charAt(1);
        if (this.flowKey || mt(o) || o === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let t = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; t !== -1 && this.buffer[t + 1] === "'"; )
        t = this.buffer.indexOf("'", t + 2);
    else
      for (; t !== -1; ) {
        let n = 0;
        for (; this.buffer[t - 1 - n] === "\\"; )
          n += 1;
        if (n % 2 === 0)
          break;
        t = this.buffer.indexOf('"', t + 1);
      }
    const i = this.buffer.substring(0, t);
    let r = i.indexOf(`
`, this.pos);
    if (r !== -1) {
      for (; r !== -1; ) {
        const n = this.continueScalar(r + 1);
        if (n === -1)
          break;
        r = i.indexOf(`
`, n);
      }
      r !== -1 && (t = r - (i[r - 1] === "\r" ? 2 : 1));
    }
    if (t === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      t = this.buffer.length;
    }
    return yield* this.pushToIndex(t + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const t = this.buffer[++e];
      if (t === "+")
        this.blockScalarKeep = !0;
      else if (t > "0" && t <= "9")
        this.blockScalarIndent = Number(t) - 1;
      else if (t !== "-")
        break;
    }
    return yield* this.pushUntil((t) => mt(t) || t === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, t = 0, i;
    e: for (let n = this.pos; i = this.buffer[n]; ++n)
      switch (i) {
        case " ":
          t += 1;
          break;
        case `
`:
          e = n, t = 0;
          break;
        case "\r": {
          const o = this.buffer[n + 1];
          if (!o && !this.atEnd)
            return this.setNext("block-scalar");
          if (o === `
`)
            break;
        }
        default:
          break e;
      }
    if (!i && !this.atEnd)
      return this.setNext("block-scalar");
    if (t >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = t : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const n = this.continueScalar(e + 1);
        if (n === -1)
          break;
        e = this.buffer.indexOf(`
`, n);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    let r = e + 1;
    for (i = this.buffer[r]; i === " "; )
      i = this.buffer[++r];
    if (i === "	") {
      for (; i === "	" || i === " " || i === "\r" || i === `
`; )
        i = this.buffer[++r];
      e = r - 1;
    } else if (!this.blockScalarKeep)
      do {
        let n = e - 1, o = this.buffer[n];
        o === "\r" && (o = this.buffer[--n]);
        const a = n;
        for (; o === " "; )
          o = this.buffer[--n];
        if (o === `
` && n >= this.pos && n + 1 + t > a)
          e = n;
        else
          break;
      } while (!0);
    return yield cr, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let t = this.pos - 1, i = this.pos - 1, r;
    for (; r = this.buffer[++i]; )
      if (r === ":") {
        const n = this.buffer[i + 1];
        if (mt(n) || e && jr.has(n))
          break;
        t = i;
      } else if (mt(r)) {
        let n = this.buffer[i + 1];
        if (r === "\r" && (n === `
` ? (i += 1, r = `
`, n = this.buffer[i + 1]) : t = i), n === "#" || e && jr.has(n))
          break;
        if (r === `
`) {
          const o = this.continueScalar(i + 1);
          if (o === -1)
            break;
          i = Math.max(i, o - 2);
        }
      } else {
        if (e && jr.has(r))
          break;
        t = i;
      }
    return !r && !this.atEnd ? this.setNext("plain-scalar") : (yield cr, yield* this.pushToIndex(t + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, t) {
    const i = this.buffer.slice(this.pos, e);
    return i ? (yield i, this.pos += i.length, i.length) : (t && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(So)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const e = this.flowLevel > 0, t = this.charAt(1);
        if (mt(t) || e && jr.has(t))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, t = this.buffer[e];
      for (; !mt(t) && t !== ">"; )
        t = this.buffer[++e];
      return yield* this.pushToIndex(t === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, t = this.buffer[e];
      for (; t; )
        if (u_.has(t))
          t = this.buffer[++e];
        else if (t === "%" && Oc.has(this.buffer[e + 1]) && Oc.has(this.buffer[e + 2]))
          t = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let t = this.pos - 1, i;
    do
      i = this.buffer[++t];
    while (i === " " || e && i === "	");
    const r = t - this.pos;
    return r > 0 && (yield this.buffer.substr(this.pos, r), this.pos = t), r;
  }
  *pushUntil(e) {
    let t = this.pos, i = this.buffer[t];
    for (; !e(i); )
      i = this.buffer[++t];
    return yield* this.pushToIndex(t, !1);
  }
}
class Hd {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let t = 0, i = this.lineStarts.length;
      for (; t < i; ) {
        const n = t + i >> 1;
        this.lineStarts[n] < e ? t = n + 1 : i = n;
      }
      if (this.lineStarts[t] === e)
        return { line: t + 1, col: 1 };
      if (t === 0)
        return { line: 0, col: e };
      const r = this.lineStarts[t - 1];
      return { line: t, col: e - r + 1 };
    };
  }
}
function Yt(s, e) {
  for (let t = 0; t < s.length; ++t)
    if (s[t].type === e)
      return !0;
  return !1;
}
function Pc(s) {
  for (let e = 0; e < s.length; ++e)
    switch (s[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function jd(s) {
  switch (s == null ? void 0 : s.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function Ur(s) {
  switch (s.type) {
    case "document":
      return s.start;
    case "block-map": {
      const e = s.items[s.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return s.items[s.items.length - 1].start;
    default:
      return [];
  }
}
function Gs(s) {
  var t;
  if (s.length === 0)
    return [];
  let e = s.length;
  e: for (; --e >= 0; )
    switch (s[e].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; ((t = s[++e]) == null ? void 0 : t.type) === "space"; )
    ;
  return s.splice(e, s.length);
}
function Bc(s) {
  if (s.start.type === "flow-seq-start")
    for (const e of s.items)
      e.sep && !e.value && !Yt(e.start, "explicit-key-ind") && !Yt(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, jd(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class Ia {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new zd(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, t = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const i of this.lexer.lex(e, t))
      yield* this.next(i);
    t || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const t = Fd(e);
    if (t)
      if (t === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = t, yield* this.step(), t) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const i = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: i, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const t = e ?? this.stack.pop();
    if (!t)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield t;
    else {
      const i = this.peek(1);
      switch (t.type === "block-scalar" ? t.indent = "indent" in i ? i.indent : 0 : t.type === "flow-collection" && i.type === "document" && (t.indent = 0), t.type === "flow-collection" && Bc(t), i.type) {
        case "document":
          i.value = t;
          break;
        case "block-scalar":
          i.props.push(t);
          break;
        case "block-map": {
          const r = i.items[i.items.length - 1];
          if (r.value) {
            i.items.push({ start: [], key: t, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (r.sep)
            r.value = t;
          else {
            Object.assign(r, { key: t, sep: [] }), this.onKeyLine = !r.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const r = i.items[i.items.length - 1];
          r.value ? i.items.push({ start: [], value: t }) : r.value = t;
          break;
        }
        case "flow-collection": {
          const r = i.items[i.items.length - 1];
          !r || r.value ? i.items.push({ start: [], key: t, sep: [] }) : r.sep ? r.value = t : Object.assign(r, { key: t, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(t);
      }
      if ((i.type === "document" || i.type === "block-map" || i.type === "block-seq") && (t.type === "block-map" || t.type === "block-seq")) {
        const r = t.items[t.items.length - 1];
        r && !r.sep && !r.value && r.start.length > 0 && Pc(r.start) === -1 && (t.indent === 0 || r.start.every((n) => n.type !== "comment" || n.indent < t.indent)) && (i.type === "document" ? i.end = r.start : i.items.push({ start: r.start }), t.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        Pc(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const t = this.startBlockValue(e);
    t ? this.stack.push(t) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const t = Ur(this.peek(2)), i = Gs(t);
      let r;
      e.end ? (r = e.end, r.push(this.sourceToken), delete e.end) : r = [this.sourceToken];
      const n = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: i, key: e, sep: r }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = n;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let t = this.source.indexOf(`
`) + 1;
          for (; t !== 0; )
            this.onNewLine(this.offset + t), t = this.source.indexOf(`
`, t) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    var i;
    const t = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, t.value) {
          const r = "end" in t.value ? t.value.end : void 0, n = Array.isArray(r) ? r[r.length - 1] : void 0;
          (n == null ? void 0 : n.type) === "comment" ? r == null || r.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else t.sep ? t.sep.push(this.sourceToken) : t.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (t.value)
          e.items.push({ start: [this.sourceToken] });
        else if (t.sep)
          t.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(t.start, e.indent)) {
            const r = e.items[e.items.length - 2], n = (i = r == null ? void 0 : r.value) == null ? void 0 : i.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, t.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          t.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const r = !this.onKeyLine && this.indent === e.indent, n = r && (t.sep || t.explicitKey) && this.type !== "seq-item-ind";
      let o = [];
      if (n && t.sep && !t.value) {
        const a = [];
        for (let l = 0; l < t.sep.length; ++l) {
          const c = t.sep[l];
          switch (c.type) {
            case "newline":
              a.push(l);
              break;
            case "space":
              break;
            case "comment":
              c.indent > e.indent && (a.length = 0);
              break;
            default:
              a.length = 0;
          }
        }
        a.length >= 2 && (o = t.sep.splice(a[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          n || t.value ? (o.push(this.sourceToken), e.items.push({ start: o }), this.onKeyLine = !0) : t.sep ? t.sep.push(this.sourceToken) : t.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !t.sep && !t.explicitKey ? (t.start.push(this.sourceToken), t.explicitKey = !0) : n || t.value ? (o.push(this.sourceToken), e.items.push({ start: o, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (t.explicitKey)
            if (t.sep)
              if (t.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Yt(t.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: null, sep: [this.sourceToken] }]
                });
              else if (jd(t.key) && !Yt(t.sep, "newline")) {
                const a = Gs(t.start), l = t.key, c = t.sep;
                c.push(this.sourceToken), delete t.key, delete t.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: a, key: l, sep: c }]
                });
              } else o.length > 0 ? t.sep = t.sep.concat(o, this.sourceToken) : t.sep.push(this.sourceToken);
            else if (Yt(t.start, "newline"))
              Object.assign(t, { key: null, sep: [this.sourceToken] });
            else {
              const a = Gs(t.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: a, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            t.sep ? t.value || n ? e.items.push({ start: o, key: null, sep: [this.sourceToken] }) : Yt(t.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : t.sep.push(this.sourceToken) : Object.assign(t, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const a = this.flowScalar(this.type);
          n || t.value ? (e.items.push({ start: o, key: a, sep: [] }), this.onKeyLine = !0) : t.sep ? this.stack.push(a) : (Object.assign(t, { key: a, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const a = this.startBlockValue(e);
          if (a) {
            if (a.type === "block-seq") {
              if (!t.explicitKey && t.sep && !Yt(t.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else r && e.items.push({ start: o });
            this.stack.push(a);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    var i;
    const t = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (t.value) {
          const r = "end" in t.value ? t.value.end : void 0, n = Array.isArray(r) ? r[r.length - 1] : void 0;
          (n == null ? void 0 : n.type) === "comment" ? r == null || r.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          t.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (t.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(t.start, e.indent)) {
            const r = e.items[e.items.length - 2], n = (i = r == null ? void 0 : r.value) == null ? void 0 : i.end;
            if (Array.isArray(n)) {
              Array.prototype.push.apply(n, t.start), n.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          t.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (t.value || this.indent <= e.indent)
          break;
        t.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        t.value || Yt(t.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : t.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const r = this.startBlockValue(e);
      if (r) {
        this.stack.push(r);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const t = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let i;
      do
        yield* this.pop(), i = this.peek(1);
      while (i && i.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !t || t.sep ? e.items.push({ start: [this.sourceToken] }) : t.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !t || t.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : t.sep ? t.sep.push(this.sourceToken) : Object.assign(t, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !t || t.value ? e.items.push({ start: [this.sourceToken] }) : t.sep ? t.sep.push(this.sourceToken) : t.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const r = this.flowScalar(this.type);
          !t || t.value ? e.items.push({ start: [], key: r, sep: [] }) : t.sep ? this.stack.push(r) : Object.assign(t, { key: r, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const i = this.startBlockValue(e);
      i ? this.stack.push(i) : (yield* this.pop(), yield* this.step());
    } else {
      const i = this.peek(2);
      if (i.type === "block-map" && (this.type === "map-value-ind" && i.indent === e.indent || this.type === "newline" && !i.items[i.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && i.type !== "flow-collection") {
        const r = Ur(i), n = Gs(r);
        Bc(e);
        const o = e.end.splice(1, e.end.length);
        o.push(this.sourceToken);
        const a = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: n, key: e, sep: o }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = a;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let t = this.source.indexOf(`
`) + 1;
      for (; t !== 0; )
        this.onNewLine(this.offset + t), t = this.source.indexOf(`
`, t) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const t = Ur(e), i = Gs(t);
        return i.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: i, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const t = Ur(e), i = Gs(t);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: i, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, t) {
    return this.type !== "comment" || this.indent <= t ? !1 : e.every((i) => i.type === "newline" || i.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function Ud(s) {
  const e = s.prettyErrors !== !1;
  return { lineCounter: s.lineCounter || e && new Hd() || null, prettyErrors: e };
}
function p_(s, e = {}) {
  const { lineCounter: t, prettyErrors: i } = Ud(e), r = new Ia(t == null ? void 0 : t.addNewLine), n = new Ma(e), o = Array.from(n.compose(r.parse(s)));
  if (i && t)
    for (const a of o)
      a.errors.forEach(_n(s, t)), a.warnings.forEach(_n(s, t));
  return o.length > 0 ? o : Object.assign([], { empty: !0 }, n.streamInfo());
}
function Wd(s, e = {}) {
  const { lineCounter: t, prettyErrors: i } = Ud(e), r = new Ia(t == null ? void 0 : t.addNewLine), n = new Ma(e);
  let o = null;
  for (const a of n.compose(r.parse(s), !0, s.length))
    if (!o)
      o = a;
    else if (o.options.logLevel !== "silent") {
      o.errors.push(new ks(a.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return i && t && (o.errors.forEach(_n(s, t)), o.warnings.forEach(_n(s, t))), o;
}
function g_(s, e, t) {
  let i;
  typeof e == "function" ? i = e : t === void 0 && e && typeof e == "object" && (t = e);
  const r = Wd(s, t);
  if (!r)
    return null;
  if (r.warnings.forEach((n) => cd(r.options.logLevel, n)), r.errors.length > 0) {
    if (r.options.logLevel !== "silent")
      throw r.errors[0];
    r.errors = [];
  }
  return r.toJS(Object.assign({ reviver: i }, t));
}
function m_(s, e, t) {
  let i = null;
  if (typeof e == "function" || Array.isArray(e) ? i = e : t === void 0 && e && (t = e), typeof t == "string" && (t = t.length), typeof t == "number") {
    const r = Math.round(t);
    t = r < 1 ? void 0 : r > 8 ? { indent: 8 } : { indent: r };
  }
  if (s === void 0) {
    const { keepUndefined: r } = t ?? e ?? {};
    if (!r)
      return;
  }
  return Us(s) && !i ? s.toString(t) : new Wn(s, i, t).toString(t);
}
const Co = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: Rn,
  CST: d_,
  Composer: Ma,
  Document: Wn,
  Lexer: zd,
  LineCounter: Hd,
  Pair: Ge,
  Parser: Ia,
  Scalar: te,
  Schema: Un,
  YAMLError: Ta,
  YAMLMap: ht,
  YAMLParseError: ks,
  YAMLSeq: ls,
  YAMLWarning: Ed,
  isAlias: hs,
  isCollection: $e,
  isDocument: Us,
  isMap: bi,
  isNode: Ae,
  isPair: Se,
  isScalar: ge,
  isSeq: vi,
  parse: g_,
  parseAllDocuments: p_,
  parseDocument: Wd,
  stringify: m_,
  visit: Ws,
  visitAsync: In
}, Symbol.toStringTag, { value: "Module" }));
var b_ = Object.defineProperty, v_ = Object.getOwnPropertyDescriptor, Ot = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? v_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && b_(e, t, r), r;
};
let gt = class extends le {
  constructor() {
    super(...arguments), this.show = !1, this.title = "Create Resource", this.value = "", this.loading = !1, this.error = "", this.format = "yaml", this.submitLabel = "Create", this.validationMessage = "", this.validationStatus = "", this.templates = {
      deployment: `apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: nginx:latest
        ports:
        - containerPort: 80`,
      service: `apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: default
spec:
  selector:
    app: my-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP`,
      configmap: `apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
  namespace: default
data:
  config.yaml: |
    key1: value1
    key2: value2`,
      secret: `apiVersion: v1
kind: Secret
metadata:
  name: my-secret
  namespace: default
type: Opaque
data:
  username: YWRtaW4=
  password: cGFzc3dvcmQ=`
    };
  }
  render() {
    return D`
      <div class="drawer" part="drawer">
        <div class="drawer-header" part="header">
          <h2 class="header-title">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
              <path d="M10 2a1 1 0 011 1v6h6a1 1 0 110 2h-6v6a1 1 0 11-2 0v-6H3a1 1 0 110-2h6V3a1 1 0 011-1z"/>
            </svg>
            ${this.title}
          </h2>
          <button class="close-button" @click=${this.handleClose} aria-label="Close">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
              <path d="M15 5L5 15M5 5l10 10" stroke="currentColor" stroke-width="2"/>
            </svg>
          </button>
        </div>

        <div class="format-toggle">
          <div class="format-left">
            <button
              class="format-button ${this.format === "yaml" ? "active" : ""}"
              @click=${() => this.setFormat("yaml")}
            >
              YAML
            </button>
            <button
              class="format-button ${this.format === "json" ? "active" : ""}"
              @click=${() => this.setFormat("json")}
            >
              JSON
            </button>
          </div>
          <div class="format-hint ${this.format}">
            ${this.format.toUpperCase()} format detected
          </div>
        </div>

        <div class="content" part="content">
          <div class="editor-container">
            <textarea
              class="editor"
              part="editor"
              .value=${this.value}
              @input=${this.handleInput}
              placeholder=${this.getPlaceholder()}
              spellcheck="false"
            ></textarea>
            
            ${this.validationMessage ? D`
              <div class="validation-message ${this.validationStatus}">
                <svg class="validation-icon" viewBox="0 0 16 16" fill="currentColor">
                  ${this.validationStatus === "error" ? D`
                    <path d="M8 1a7 7 0 100 14A7 7 0 008 1zm-1 10V6h2v5H7zm0 2v-1h2v1H7z"/>
                  ` : D`
                    <path d="M8 1a7 7 0 100 14A7 7 0 008 1zm3.5 4.5L7 10 4.5 7.5l1-1L7 8l3.5-3.5 1 1z"/>
                  `}
                </svg>
                <span>${this.validationMessage}</span>
              </div>
            ` : ""}
          </div>

          <div class="templates">
            <div class="templates-title">Quick Templates:</div>
            <div class="template-buttons">
              <button class="template-button" @click=${() => this.loadTemplate("deployment")}>
                Deployment
              </button>
              <button class="template-button" @click=${() => this.loadTemplate("service")}>
                Service
              </button>
              <button class="template-button" @click=${() => this.loadTemplate("configmap")}>
                ConfigMap
              </button>
              <button class="template-button" @click=${() => this.loadTemplate("secret")}>
                Secret
              </button>
            </div>
          </div>
        </div>

        <div class="controls" part="controls">
          <button
            class="control-button cancel"
            @click=${this.handleClose}
            ?disabled=${this.loading}
          >
            Cancel
          </button>
          <button
            class="control-button create"
            @click=${this.handleCreate}
            ?disabled=${this.loading || !this.value.trim() || this.validationStatus === "error"}
          >
            ${this.loading ? "Processing..." : this.submitLabel}
          </button>
        </div>
      </div>
    `;
  }
  getPlaceholder() {
    return this.format === "yaml" ? `# Enter your Kubernetes resource definition in YAML format
# Example:
# apiVersion: v1
# kind: Pod
# metadata:
#   name: my-pod
# spec:
#   containers:
#   - name: my-container
#     image: nginx` : `{
  "apiVersion": "v1",
  "kind": "Pod",
  "metadata": {
    "name": "my-pod"
  },
  "spec": {
    "containers": [{
      "name": "my-container",
      "image": "nginx"
    }]
  }
}`;
  }
  handleInput(s) {
    const e = s.target;
    this.value = e.value;
    const t = this.detectFormat(this.value);
    this.format = t, this.validateResource();
  }
  setFormat(s) {
    this.format = s, this.value.trim() && this.convertFormat();
  }
  detectFormat(s) {
    const e = s.trim();
    if (!e) return this.format;
    if (e.startsWith("{") || e.startsWith("["))
      try {
        return JSON.parse(e), "json";
      } catch {
        return "yaml";
      }
    return "yaml";
  }
  convertFormat() {
    try {
      if (this.format === "json") {
        const s = Co.parse(this.value);
        this.value = JSON.stringify(s, null, 2), this.validationMessage = "", this.validationStatus = "";
      } else {
        const s = JSON.parse(this.value);
        this.value = Co.stringify(s), this.validationMessage = "", this.validationStatus = "";
      }
      this.validateResource();
    } catch {
      this.validationMessage = "Failed to convert format", this.validationStatus = "error";
    }
  }
  validateResource() {
    if (!this.value.trim()) {
      this.validationMessage = "", this.validationStatus = "";
      return;
    }
    try {
      if (this.format === "json") {
        const s = JSON.parse(this.value);
        this.validateResourceStructure(s);
      } else {
        const s = Co.parse(this.value);
        this.validateResourceStructure(s);
      }
    } catch (s) {
      this.validationMessage = s.message || "Invalid format", this.validationStatus = "error";
    }
  }
  validateResourceStructure(s) {
    if (!s.apiVersion)
      throw new Error("Missing required field: apiVersion");
    if (!s.kind)
      throw new Error("Missing required field: kind");
    if (!s.metadata)
      throw new Error("Missing required field: metadata");
    if (!s.metadata.name)
      throw new Error("Missing required field: metadata.name");
    this.validationMessage = `Valid ${s.kind} resource`, this.validationStatus = "success";
  }
  loadTemplate(s) {
    this.value = this.templates[s], this.format = "yaml", this.validateResource();
  }
  handleClose() {
    this.show = !1, this.dispatchEvent(new CustomEvent("close", {
      bubbles: !0,
      composed: !0
    }));
  }
  handleCreate() {
    if (!this.value.trim() || this.validationStatus === "error")
      return;
    let s;
    try {
      this.format === "json" ? s = JSON.parse(this.value) : s = { yaml: this.value }, this.dispatchEvent(new CustomEvent("create", {
        detail: { resource: s, format: this.format },
        bubbles: !0,
        composed: !0
      }));
    } catch {
      this.validationMessage = "Failed to parse resource", this.validationStatus = "error";
    }
  }
};
gt.styles = re`
    :host {
      display: block;
      position: fixed;
      top: 0;
      right: 0;
      width: 700px;
      height: 100vh;
      z-index: 1000;
      /* Prevent overlay from intercepting clicks when hidden */
      pointer-events: none;
    }

    :host([show]) {
      pointer-events: auto;
    }

.drawer {
      width: 100%;
      height: 100%;
      background: var(--vscode-editor-background, var(--vscode-bg-light));
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      border-left: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
    }

    :host([show]) .drawer {
      transform: translateX(0);
    }

.drawer-header {
      padding: 20px;
      background: var(--vscode-bg-lighter, #2c2f3a);
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .header-title {
      font-size: 18px;
      font-weight: 500;
      color: var(--title-color, #e0e0e0);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .close-button {
      background: none;
      border: none;
      color: var(--close-color, #999);
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .close-button:hover {
      background: var(--close-hover-bg, rgba(255, 255, 255, 0.1));
      color: var(--close-hover-color, #e0e0e0);
    }

.format-toggle {
      padding: 12px 20px;
      background: var(--vscode-bg-lighter, #2c2f3a);
      border-bottom: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .format-left {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .format-hint {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border: 1px solid transparent;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
    }

    .format-hint.yaml {
      background: rgba(137, 209, 133, 0.08);
      border-color: #89d185;
      color: #89d185;
    }

    .format-hint.json {
      background: rgba(55, 148, 255, 0.08);
      border-color: #3794ff;
      color: #3794ff;
    }

.format-button {
      padding: 8px 16px;
      background: var(--button-bg, var(--vscode-bg-lighter, #3a3d4a));
      color: var(--button-color, var(--vscode-foreground, #e0e0e0));
      border: 1px solid var(--button-border, var(--vscode-widget-border, #4a4d5a));
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

.format-button:hover {
      background: var(--button-hover-bg, #4a4d5a);
      border-color: var(--button-hover-border, #5a5d6a);
    }

.format-button.active {
      background: var(--vscode-button-background, #0e639c);
      border-color: var(--vscode-button-border, transparent);
      color: var(--vscode-button-foreground, #ffffff);
    }

    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .editor-container {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

.editor {
      width: 100%;
      min-height: 400px;
      padding: 16px;
      background: var(--vscode-editor-background, #1e1e1e);
      color: var(--vscode-editor-foreground, #d4d4d4);
      border: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      resize: vertical;
      outline: none;
    }

.editor:focus {
      border-color: var(--vscode-focusBorder, #007acc);
    }

    .editor::placeholder {
      color: var(--editor-placeholder, #666);
    }

    .validation-message {
      margin-top: 12px;
      padding: 12px;
      border-radius: 4px;
      font-size: 14px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .validation-message.error {
      background: var(--error-bg, rgba(244, 67, 54, 0.1));
      color: var(--error-color, #f44336);
      border: 1px solid var(--error-border, rgba(244, 67, 54, 0.3));
    }

    .validation-message.success {
      background: var(--success-bg, rgba(76, 175, 80, 0.1));
      color: var(--success-color, #4caf50);
      border: 1px solid var(--success-border, rgba(76, 175, 80, 0.3));
    }

    .validation-icon {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
    }

    .templates {
      padding: 0 20px 20px;
    }

    .templates-title {
      font-size: 14px;
      color: var(--templates-title-color, #999);
      margin-bottom: 8px;
    }

    .template-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .template-button {
      padding: 6px 12px;
      background: var(--template-bg, #3a3d4a);
      color: var(--template-color, #e0e0e0);
      border: 1px solid var(--template-border, #4a4d5a);
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .template-button:hover {
      background: var(--template-hover-bg, #4a4d5a);
      border-color: var(--template-hover-border, #5a5d6a);
    }

.controls {
      padding: 20px;
      background: var(--vscode-bg-lighter, #2c2f3a);
      border-top: 1px solid var(--vscode-widget-border, var(--vscode-panel-border, #454545));
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-shrink: 0;
    }

    .control-button {
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

.control-button.cancel {
      background: var(--vscode-button-secondaryBackground, #3a3d4a);
      color: var(--vscode-button-secondaryForeground, #e0e0e0);
      border-color: var(--vscode-button-border, #4a4d5a);
    }

.control-button.cancel:hover {
      background: var(--vscode-button-secondaryHoverBackground, #4a4d5a);
      border-color: var(--vscode-button-border, #5a5d6a);
    }

.control-button.create {
      background: var(--vscode-button-background, #0e639c);
      color: var(--vscode-button-foreground, #ffffff);
      border-color: var(--vscode-button-border, transparent);
    }

.control-button.create:hover {
      background: var(--vscode-button-hoverBackground, #1177bb);
      border-color: var(--vscode-button-border, transparent);
    }

    .control-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Scrollbar styling */
    .editor-container::-webkit-scrollbar {
      width: 8px;
    }

.editor-container::-webkit-scrollbar-track {
      background: var(--scrollbar-track, var(--vscode-editor-background, #1e1e1e));
    }

.editor-container::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb, var(--vscode-scrollbarSlider-background, #4a4d5a));
      border-radius: 4px;
    }

    .editor-container::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover, #5a5d6a);
    }
  `;
Ot([
  H({ type: Boolean, reflect: !0 })
], gt.prototype, "show", 2);
Ot([
  H({ type: String })
], gt.prototype, "title", 2);
Ot([
  H({ type: String })
], gt.prototype, "value", 2);
Ot([
  H({ type: Boolean })
], gt.prototype, "loading", 2);
Ot([
  H({ type: String })
], gt.prototype, "error", 2);
Ot([
  H({ type: String })
], gt.prototype, "format", 2);
Ot([
  H({ type: String })
], gt.prototype, "submitLabel", 2);
Ot([
  B()
], gt.prototype, "validationMessage", 2);
Ot([
  B()
], gt.prototype, "validationStatus", 2);
gt = Ot([
  me("create-resource-drawer")
], gt);
var __ = Object.defineProperty, y_ = Object.getOwnPropertyDescriptor, wr = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? y_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && __(e, t, r), r;
};
let Ps = class extends le {
  constructor() {
    super(...arguments), this.notifications = [], this.defaultDuration = 5e3, this.maxNotifications = 5, this.closingIds = /* @__PURE__ */ new Set(), this.timers = /* @__PURE__ */ new Map();
  }
  render() {
    const s = this.notifications.slice(-this.maxNotifications);
    return D`
      <div class="container" part="container">
        ${s.map((e) => this.renderNotification(e))}
      </div>
    `;
  }
  renderNotification(s) {
    const e = this.closingIds.has(s.id), t = this.getIcon(s.type);
    return D`
      <div
        class="notification ${s.type} ${e ? "closing" : ""}"
        part="notification notification-${s.type}"
        @animationend=${(i) => this.handleAnimationEnd(i, s.id)}
      >
        <svg class="notification-icon" viewBox="0 0 20 20" fill="currentColor">
          ${t}
        </svg>
        
        <div class="notification-content">
          <div class="notification-message">${s.message}</div>
          
          ${s.actions && s.actions.length > 0 ? D`
            <div class="notification-actions">
              ${s.actions.map((i) => D`
                <button
                  class="notification-action"
                  @click=${() => {
      i.handler(), this.closeNotification(s.id);
    }}
                >
                  ${i.label}
                </button>
              `)}
            </div>
          ` : ""}
        </div>
        
        <button
          class="close-button"
          @click=${() => this.closeNotification(s.id)}
          aria-label="Close notification"
        >
          <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
            <path d="M9 3L3 9M3 3l6 6" stroke="currentColor" stroke-width="2"/>
          </svg>
        </button>
        
        ${s.duration ? D`
          <div
            class="progress-bar"
            style="width: 100%; transition-duration: ${s.duration}ms;"
          ></div>
        ` : ""}
      </div>
    `;
  }
  getIcon(s) {
    switch (s) {
      case "info":
        return D`<path d="M10 2a8 8 0 100 16 8 8 0 000-16zM9 7h2v7H9zm0-2h2v1.5H9z"/>`;
      case "success":
        return D`<path d="M10 2a8 8 0 100 16 8 8 0 000-16zm4 6l-5 5-3-3 1-1 2 2 4-4 1 1z"/>`;
      case "warning":
        return D`<path d="M10 2l8 14H2L10 2zm0 4l-4 7h8l-4-7zm-1 3h2v3H9zm0 4h2v1H9z"/>`;
      case "error":
        return D`<path d="M10 2a8 8 0 100 16 8 8 0 000-16zm3 4L10 9l-3-3-1 1 3 3-3 3 1 1 3-3 3 3 1-1-3-3 3-3-1-1z"/>`;
    }
  }
  closeNotification(s) {
    this.closingIds.add(s), this.requestUpdate();
    const e = this.timers.get(s);
    e && (clearTimeout(e), this.timers.delete(s));
  }
  handleAnimationEnd(s, e) {
    s.animationName === "slideOut" && this.removeNotification(e);
  }
  removeNotification(s) {
    this.notifications = this.notifications.filter((e) => e.id !== s), this.closingIds.delete(s), this.timers.delete(s), this.dispatchEvent(new CustomEvent("notification-closed", {
      detail: { id: s },
      bubbles: !0,
      composed: !0
    }));
  }
  addNotification(s) {
    const e = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, t = {
      ...s,
      id: e,
      duration: s.duration ?? (s.type === "error" ? 0 : this.defaultDuration)
    };
    if (this.notifications = [...this.notifications, t], t.duration && t.duration > 0) {
      const i = setTimeout(() => {
        this.closeNotification(e);
      }, t.duration);
      this.timers.set(e, i);
    }
    return e;
  }
  removeAllNotifications() {
    this.timers.forEach((s) => clearTimeout(s)), this.timers.clear(), this.notifications.forEach((s) => this.closingIds.add(s.id)), this.requestUpdate(), setTimeout(() => {
      this.notifications = [], this.closingIds.clear();
    }, 300);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timers.forEach((s) => clearTimeout(s)), this.timers.clear();
  }
};
Ps.styles = re`
    :host {
      display: block;
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      pointer-events: none;
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 400px;
    }

    .notification {
      background: var(--notification-bg, #2c2f3a);
      border: 1px solid var(--notification-border, #3a3d4a);
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: flex-start;
      gap: 12px;
      pointer-events: auto;
      animation: slideIn 0.3s ease-out;
      position: relative;
    }

    .notification.closing {
      animation: slideOut 0.3s ease-out forwards;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    .notification-icon {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
    }

    .notification.info {
      border-color: var(--info-border, #2196f3);
    }

    .notification.info .notification-icon {
      color: var(--info-color, #2196f3);
    }

    .notification.success {
      border-color: var(--success-border, #4caf50);
    }

    .notification.success .notification-icon {
      color: var(--success-color, #4caf50);
    }

    .notification.warning {
      border-color: var(--warning-border, #ff9800);
    }

    .notification.warning .notification-icon {
      color: var(--warning-color, #ff9800);
    }

    .notification.error {
      border-color: var(--error-border, #f44336);
    }

    .notification.error .notification-icon {
      color: var(--error-color, #f44336);
    }

    .notification-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .notification-message {
      color: var(--message-color, #e0e0e0);
      font-size: 14px;
      line-height: 1.5;
      word-break: break-word;
    }

    .notification-actions {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }

    .notification-action {
      background: none;
      border: 1px solid var(--action-border, #4a4d5a);
      color: var(--action-color, #e0e0e0);
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .notification-action:hover {
      background: var(--action-hover-bg, rgba(255, 255, 255, 0.1));
      border-color: var(--action-hover-border, #5a5d6a);
    }

    .close-button {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      color: var(--close-color, #999);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
      opacity: 0.7;
    }

    .close-button:hover {
      background: var(--close-hover-bg, rgba(255, 255, 255, 0.1));
      opacity: 1;
    }

    .progress-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: var(--progress-color, currentColor);
      border-radius: 0 0 8px 8px;
      transition: width linear;
      opacity: 0.3;
    }
  `;
wr([
  H({ type: Array })
], Ps.prototype, "notifications", 2);
wr([
  H({ type: Number })
], Ps.prototype, "defaultDuration", 2);
wr([
  H({ type: Number })
], Ps.prototype, "maxNotifications", 2);
wr([
  B()
], Ps.prototype, "closingIds", 2);
Ps = wr([
  me("notification-container")
], Ps);
var w_ = Object.defineProperty, x_ = Object.getOwnPropertyDescriptor, Be = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? x_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && w_(e, t, r), r;
};
let Me = class extends le {
  constructor() {
    super(...arguments), this.workloads = [], this.namespaces = [], this.selectedNamespace = "All Namespaces", this.searchQuery = "", this.loading = !1, this.error = null, this.activeTab = "pods", this.showDetails = !1, this.selectedItem = null, this.loadingDetails = !1, this.detailsData = null, this.showDeleteModal = !1, this.itemToDelete = null, this.isDeleting = !1, this.showCreateDrawer = !1, this.createResourceValue = "", this.createDrawerTitle = "Create Resource", this.isCreating = !1, this.tabs = [
      { id: "pods", label: "Pods" },
      { id: "deployments", label: "Deployments" },
      { id: "statefulsets", label: "StatefulSets" },
      { id: "daemonsets", label: "DaemonSets" },
      { id: "jobs", label: "Jobs" },
      { id: "cronjobs", label: "CronJobs" }
    ];
  }
  getColumns() {
    const s = [
      { key: "name", label: "Name", type: "link" },
      { key: "type", label: "Type" },
      { key: "namespace", label: "Namespace" },
      { key: "status", label: "Status", type: "status" }
    ];
    return this.activeTab === "cronjobs" ? s.push({ key: "replicas", label: "Schedule" }) : this.activeTab === "jobs" ? s.push({ key: "replicas", label: "Completions" }) : s.push({ key: "replicas", label: "Replicas" }), s.push({ key: "age", label: "Age" }), s;
  }
  getActions(s) {
    const e = [
      { label: "View Details", action: "view" }
    ];
    return "status" in s && s.type === "Pod" && e.push({ label: "View Logs", action: "logs" }), e.push(
      { label: "Edit", action: "edit" },
      { label: "Delete", action: "delete", danger: !0 }
    ), e;
  }
  getFilteredData() {
    let s = this.workloads;
    return this.searchQuery && (s = s.filter(
      (e) => JSON.stringify(e).toLowerCase().includes(this.searchQuery.toLowerCase())
    )), s;
  }
  getResourceType() {
    return {
      pods: "Pod",
      deployments: "Deployment",
      statefulsets: "StatefulSet",
      daemonsets: "DaemonSet",
      jobs: "Job",
      cronjobs: "CronJob"
    }[this.activeTab] || "Pod";
  }
  async handleTabChange(s) {
    this.activeTab = s.detail.tabId, await this.fetchData();
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  async handleNamespaceChange(s) {
    this.selectedNamespace = s.detail.namespace, await this.fetchData();
  }
  handleCellClick(s) {
    const e = s.detail.item;
    this.viewDetails(e);
  }
  handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        this.viewDetails(t);
        break;
      case "logs":
        this.viewLogs(t);
        break;
      case "edit":
        this.editItem(t);
        break;
      case "delete":
        this.deleteItem(t);
        break;
    }
  }
  async viewDetails(s) {
    this.selectedItem = s, this.showDetails = !0, this.loadingDetails = !0;
    try {
      const e = this.getResourceType();
      this.detailsData = await se.getResourceDetails(e, s.name, s.namespace);
    } catch (e) {
      console.error("Failed to fetch details:", e), this.detailsData = null;
    } finally {
      this.loadingDetails = !1;
    }
  }
  viewLogs(s) {
    console.log("View logs for:", s);
  }
  editItem(s) {
    console.log("Edit item:", s);
  }
  deleteItem(s) {
    const e = this.getResourceType();
    this.itemToDelete = {
      type: e,
      name: s.name,
      namespace: s.namespace
    }, this.showDeleteModal = !0;
  }
  async handleConfirmDelete() {
    if (this.itemToDelete) {
      this.isDeleting = !0;
      try {
        await se.deleteResource(this.itemToDelete.type, this.itemToDelete.name, this.itemToDelete.namespace), await this.fetchData(), this.showDeleteModal = !1, this.itemToDelete = null;
      } catch (s) {
        console.error("Failed to delete resource:", s);
      } finally {
        this.isDeleting = !1;
      }
    }
  }
  handleCancelDelete() {
    this.showDeleteModal = !1, this.itemToDelete = null;
  }
  handleCreate() {
    var e;
    const s = this.selectedNamespace === "All Namespaces" ? "default" : this.selectedNamespace;
    switch ((this.activeTab || "").toLowerCase()) {
      case "pods":
        this.createDrawerTitle = "Create Pod", this.createResourceValue = `apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  namespace: ${s}
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80`;
        break;
      case "deployments":
        this.createDrawerTitle = "Create Deployment", this.createResourceValue = `apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
  namespace: ${s}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80`;
        break;
      case "statefulsets":
        this.createDrawerTitle = "Create StatefulSet", this.createResourceValue = `apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-statefulset
  namespace: ${s}
spec:
  serviceName: my-service
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80`;
        break;
      case "daemonsets":
        this.createDrawerTitle = "Create DaemonSet", this.createResourceValue = `apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: my-daemonset
  namespace: ${s}
spec:
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: nginx
        image: nginx:latest`;
        break;
      case "jobs":
        this.createDrawerTitle = "Create Job", this.createResourceValue = `apiVersion: batch/v1
kind: Job
metadata:
  name: my-job
  namespace: ${s}
spec:
  template:
    spec:
      containers:
      - name: hello
        image: busybox
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 30']
      restartPolicy: Never
  backoffLimit: 4`;
        break;
      case "cronjobs":
        this.createDrawerTitle = "Create CronJob", this.createResourceValue = `apiVersion: batch/v1
kind: CronJob
metadata:
  name: my-cronjob
  namespace: ${s}
spec:
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            command: ['sh', '-c', 'date; echo Hello from the Kubernetes cluster']
          restartPolicy: OnFailure`;
        break;
      default:
        const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("notification-container");
        t && typeof t.addNotification == "function" && t.addNotification({ type: "info", message: `Create is not yet available for ${this.activeTab}.` });
        return;
    }
    this.showCreateDrawer = !0;
  }
  async handleCreateResource(s) {
    var r, n;
    const { resource: e, format: t } = s.detail;
    let i = "";
    try {
      t === "json" ? i = JSON.stringify(e) : i = e.yaml, this.isCreating = !0, await se.createResource(i, t), await this.fetchData(), this.showCreateDrawer = !1, this.createResourceValue = "";
      const o = (r = this.shadowRoot) == null ? void 0 : r.querySelector("notification-container");
      o && typeof o.addNotification == "function" && o.addNotification({ type: "success", message: "Resource applied successfully" });
    } catch (o) {
      const a = (n = this.shadowRoot) == null ? void 0 : n.querySelector("notification-container");
      a && typeof a.addNotification == "function" && a.addNotification({ type: "error", message: `Failed to apply resource: ${(o == null ? void 0 : o.message) || "Unknown error"}` });
    } finally {
      this.isCreating = !1;
    }
  }
  handleDetailsClose() {
    this.showDetails = !1, this.selectedItem = null, this.detailsData = null;
  }
  async fetchData() {
    this.loading = !0, this.error = null;
    try {
      this.namespaces = await se.getNamespaces();
      const s = this.selectedNamespace === "All Namespaces" ? void 0 : this.selectedNamespace;
      let e = [];
      switch (this.activeTab) {
        case "pods":
          e = (await se.getPods(s)).map((l) => ({ ...l, type: "Pod" }));
          break;
        case "deployments":
          e = (await se.getDeployments(s)).map((l) => ({ ...l, type: "Deployment", replicas: l.ready }));
          break;
        case "statefulsets":
          e = (await se.getStatefulSets(s)).map((l) => ({ ...l, type: "StatefulSet", replicas: l.ready }));
          break;
        case "daemonsets":
          e = (await se.getDaemonSets(s)).map((l) => ({ ...l, type: "DaemonSet", replicas: `${l.ready}/${l.desired}` }));
          break;
        case "jobs":
          e = (await se.getJobs(s)).map((l) => ({ ...l, type: "Job", replicas: l.completions }));
          break;
        case "cronjobs":
          e = (await se.getCronJobs(s)).map((l) => ({ ...l, type: "CronJob", replicas: l.schedule }));
          break;
      }
      this.workloads = e;
    } catch (s) {
      console.error("Failed to fetch workloads:", s), this.error = s.message || "Failed to fetch workloads";
    } finally {
      this.loading = !1;
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchData();
  }
  render() {
    var s;
    return D`
      <div class="container">
        <tab-group
          .tabs="${this.tabs}"
          .activeTab="${this.activeTab}"
          @tab-change="${this.handleTabChange}"
        ></tab-group>

        <div class="header">
          <namespace-dropdown
            .namespaces="${this.namespaces.map((e) => ({ name: e.name }))}"
            .selectedNamespace="${this.selectedNamespace}"
            @namespace-change="${this.handleNamespaceChange}"
            .loading="${this.loading}"
            .includeAllOption="${!0}"
          ></namespace-dropdown>
          
          <search-input
            .value="${this.searchQuery}"
            placeholder="Search workloads..."
            @search-change="${this.handleSearchChange}"
          ></search-input>
          
          <div class="controls">
            <button class="btn-create" @click="${this.handleCreate}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              Create
            </button>
          </div>
        </div>

        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading workloads..."></loading-state>
          ` : this.error ? D`
            <empty-state 
              message="${this.error}" 
              icon=""
            ></empty-state>
          ` : D`
            <resource-table
              .columns="${this.getColumns()}"
              .data="${this.getFilteredData()}"
              .getActions="${(e) => this.getActions(e)}"
              emptyMessage="No ${this.activeTab} found"
              @cell-click="${this.handleCellClick}"
              @action="${this.handleAction}"
            ></resource-table>
          `}
        </div>

        <detail-drawer
          .show="${this.showDetails}"
          .loading="${this.loadingDetails}"
          title="${(s = this.selectedItem) == null ? void 0 : s.type} Details"
          @close="${this.handleDetailsClose}"
        >
          ${this.detailsData ? D`
            <resource-detail-view .resource="${this.detailsData}"></resource-detail-view>
          ` : ""}
        </detail-drawer>

        <delete-modal
          .show="${this.showDeleteModal}"
          .item="${this.itemToDelete}"
          .loading="${this.isDeleting}"
          @confirm-delete="${this.handleConfirmDelete}"
          @cancel-delete="${this.handleCancelDelete}"
        ></delete-modal>
        <create-resource-drawer
          .show="${this.showCreateDrawer}"
          ?show="${this.showCreateDrawer}"
          .title="${this.createDrawerTitle}"
          .value="${this.createResourceValue}"
          .submitLabel="Apply"
          .loading="${this.isCreating}"
          @close="${() => {
      this.showCreateDrawer = !1;
    }}"
          @create="${this.handleCreateResource}"
        ></create-resource-drawer>

        <notification-container></notification-container>
      </div>
    `;
  }
};
Me.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-create {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-create:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    namespace-dropdown {
      --dropdown-bg: var(--vscode-dropdown-background, #3c3c3c);
      --dropdown-color: var(--vscode-dropdown-foreground, #cccccc);
      --dropdown-border: var(--vscode-dropdown-border, #3c3c3c);
      --dropdown-hover-bg: var(--vscode-dropdown-hoverBackground, #2a2a2a);
      --menu-bg: var(--vscode-dropdown-background, #3c3c3c);
      --menu-border: var(--vscode-dropdown-border, #3c3c3c);
      --input-bg: var(--vscode-input-background, #3c3c3c);
      --input-color: var(--vscode-input-foreground, #cccccc);
      --input-border: var(--vscode-input-border, #3c3c3c);
      --option-hover-bg: var(--vscode-list-hoverBackground, #2a2a2a);
      --option-selected-bg: var(--vscode-list-activeSelectionBackground, #094771);
    }
  `;
Be([
  H({ type: Array })
], Me.prototype, "workloads", 2);
Be([
  H({ type: Array })
], Me.prototype, "namespaces", 2);
Be([
  H({ type: String })
], Me.prototype, "selectedNamespace", 2);
Be([
  H({ type: String })
], Me.prototype, "searchQuery", 2);
Be([
  H({ type: Boolean })
], Me.prototype, "loading", 2);
Be([
  H({ type: String })
], Me.prototype, "error", 2);
Be([
  B()
], Me.prototype, "activeTab", 2);
Be([
  B()
], Me.prototype, "showDetails", 2);
Be([
  B()
], Me.prototype, "selectedItem", 2);
Be([
  B()
], Me.prototype, "loadingDetails", 2);
Be([
  B()
], Me.prototype, "detailsData", 2);
Be([
  B()
], Me.prototype, "showDeleteModal", 2);
Be([
  B()
], Me.prototype, "itemToDelete", 2);
Be([
  B()
], Me.prototype, "isDeleting", 2);
Be([
  B()
], Me.prototype, "showCreateDrawer", 2);
Be([
  B()
], Me.prototype, "createResourceValue", 2);
Be([
  B()
], Me.prototype, "createDrawerTitle", 2);
Be([
  B()
], Me.prototype, "isCreating", 2);
Me = Be([
  me("kubernetes-workloads")
], Me);
var k_ = Object.defineProperty, S_ = Object.getOwnPropertyDescriptor, Ne = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? S_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && k_(e, t, r), r;
};
let Ie = class extends le {
  constructor() {
    super(...arguments), this.resources = [], this.namespaces = [], this.selectedNamespace = "All Namespaces", this.searchQuery = "", this.loading = !1, this.error = null, this.activeTab = "services", this.showDetails = !1, this.selectedItem = null, this.loadingDetails = !1, this.detailsData = null, this.showDeleteModal = !1, this.itemToDelete = null, this.isDeleting = !1, this.showCreateDrawer = !1, this.createResourceValue = "", this.createDrawerTitle = "Create Resource", this.isCreating = !1, this.tabs = [
      { id: "services", label: "Services" },
      { id: "ingresses", label: "Ingresses" },
      { id: "ingressclasses", label: "IngressClasses" },
      { id: "networkpolicies", label: "NetworkPolicies" }
    ];
  }
  getColumns() {
    return this.activeTab === "services" ? [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "type", label: "Type" },
      { key: "clusterIP", label: "Cluster IP" },
      { key: "ports", label: "Ports" },
      { key: "age", label: "Age" }
    ] : this.activeTab === "ingresses" ? [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "class", label: "Class" },
      { key: "hosts", label: "Hosts" },
      { key: "address", label: "Address" },
      { key: "age", label: "Age" }
    ] : this.activeTab === "ingressclasses" ? [
      { key: "name", label: "Name", type: "link" },
      { key: "controller", label: "Controller" },
      { key: "parameters", label: "Parameters" },
      { key: "age", label: "Age" }
    ] : [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "podSelector", label: "Pod Selector" },
      { key: "policyTypes", label: "Policy Types" },
      { key: "age", label: "Age" }
    ];
  }
  getActions(s) {
    return [
      { label: "View Details", action: "view" },
      { label: "Edit", action: "edit" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  getFilteredData() {
    let s = this.resources;
    return this.activeTab === "ingressclasses" && (s = s.map((e) => {
      const t = e;
      return {
        ...t,
        parameters: t.parameters ? `${t.parameters.kind || "-"}/${t.parameters.name || "-"}` : "-"
      };
    })), this.activeTab === "networkpolicies" && (s = s.map((e) => {
      const t = e;
      return {
        ...t,
        podSelector: t.podSelector && Object.keys(t.podSelector).length > 0 ? Object.entries(t.podSelector).map(([i, r]) => `${i}=${r}`).join(", ") : "All Pods",
        policyTypes: t.policyTypes ? t.policyTypes.join(", ") : "-"
      };
    })), this.searchQuery && (s = s.filter(
      (e) => JSON.stringify(e).toLowerCase().includes(this.searchQuery.toLowerCase())
    )), s;
  }
  getResourceType() {
    return this.activeTab === "services" ? "Service" : this.activeTab === "ingresses" ? "Ingress" : this.activeTab === "ingressclasses" ? "IngressClass" : "NetworkPolicy";
  }
  async handleTabChange(s) {
    this.activeTab = s.detail.tabId, await this.fetchData();
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  async handleNamespaceChange(s) {
    this.selectedNamespace = s.detail.namespace, await this.fetchData();
  }
  handleCellClick(s) {
    const e = s.detail.item;
    this.viewDetails(e);
  }
  handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        this.viewDetails(t);
        break;
      case "edit":
        this.editItem(t);
        break;
      case "delete":
        this.deleteItem(t);
        break;
    }
  }
  async viewDetails(s) {
    this.selectedItem = s, this.showDetails = !0, this.loadingDetails = !0;
    try {
      const e = this.getResourceType(), t = "namespace" in s ? s.namespace : void 0;
      this.detailsData = await se.getResourceDetails(e, s.name, t);
    } catch (e) {
      console.error("Failed to fetch details:", e), this.detailsData = null;
    } finally {
      this.loadingDetails = !1;
    }
  }
  editItem(s) {
    console.log("Edit item:", s);
  }
  deleteItem(s) {
    const e = this.getResourceType(), t = "namespace" in s ? s.namespace : void 0;
    this.itemToDelete = {
      type: e,
      name: s.name,
      namespace: t
    }, this.showDeleteModal = !0;
  }
  async handleConfirmDelete() {
    if (this.itemToDelete) {
      this.isDeleting = !0;
      try {
        await se.deleteResource(this.itemToDelete.type, this.itemToDelete.name, this.itemToDelete.namespace), await this.fetchData(), this.showDeleteModal = !1, this.itemToDelete = null;
      } catch (s) {
        console.error("Failed to delete resource:", s);
      } finally {
        this.isDeleting = !1;
      }
    }
  }
  handleCancelDelete() {
    this.showDeleteModal = !1, this.itemToDelete = null;
  }
  handleCreate() {
    const s = this.selectedNamespace === "All Namespaces" ? "default" : this.selectedNamespace;
    this.activeTab === "services" ? (this.createDrawerTitle = "Create Service", this.createResourceValue = `apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: ${s}
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP`, this.showCreateDrawer = !0) : this.activeTab === "ingresses" ? (this.createDrawerTitle = "Create Ingress", this.createResourceValue = `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  namespace: ${s}
spec:
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: my-service
                port:
                  number: 80`, this.showCreateDrawer = !0) : this.activeTab === "ingressclasses" ? (this.createDrawerTitle = "Create IngressClass", this.createResourceValue = `apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: my-ingressclass
  annotations:
    ingressclass.kubernetes.io/is-default-class: "false"
spec:
  controller: example.com/ingress-controller`, this.showCreateDrawer = !0) : (this.createDrawerTitle = "Create NetworkPolicy", this.createResourceValue = `apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: my-network-policy
  namespace: ${s}
spec:
  podSelector:
    matchLabels:
      app: my-app
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: allowed-app
      ports:
        - protocol: TCP
          port: 80
  egress:
    - to:
        - podSelector:
            matchLabels:
              app: database
      ports:
        - protocol: TCP
          port: 5432`, this.showCreateDrawer = !0);
  }
  async handleCreateResource(s) {
    var r, n;
    const { resource: e, format: t } = s.detail;
    let i = "";
    try {
      i = t === "json" ? JSON.stringify(e) : e.yaml, this.isCreating = !0, await se.createResource(i, t), await this.fetchData(), this.showCreateDrawer = !1, this.createResourceValue = "";
      const o = (r = this.shadowRoot) == null ? void 0 : r.querySelector("notification-container");
      if (o && typeof o.addNotification == "function") {
        const a = this.getResourceType();
        o.addNotification({ type: "success", message: `${a} created successfully` });
      }
    } catch (o) {
      const a = (n = this.shadowRoot) == null ? void 0 : n.querySelector("notification-container");
      a && typeof a.addNotification == "function" && a.addNotification({ type: "error", message: `Failed to create resource: ${(o == null ? void 0 : o.message) || "Unknown error"}` });
    } finally {
      this.isCreating = !1;
    }
  }
  handleDetailsClose() {
    this.showDetails = !1, this.selectedItem = null, this.detailsData = null;
  }
  async fetchData() {
    this.loading = !0, this.error = null;
    try {
      this.namespaces.length === 0 && (this.namespaces = await se.getNamespaces());
      const s = this.selectedNamespace === "All Namespaces" ? void 0 : this.selectedNamespace;
      if (this.activeTab === "services") {
        const e = await se.getServices(s);
        this.resources = e;
      } else if (this.activeTab === "ingresses") {
        const e = await se.getIngresses(s);
        this.resources = e;
      } else if (this.activeTab === "ingressclasses") {
        const e = await se.getIngressClasses();
        this.resources = e;
      } else {
        const e = await se.getNetworkPolicies(s);
        this.resources = e;
      }
    } catch (s) {
      console.error("Failed to fetch network resources:", s), this.error = s.message || "Failed to fetch network resources";
    } finally {
      this.loading = !1;
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchData();
  }
  render() {
    var s;
    return D`
      <div class="container">
        <tab-group
          .tabs="${this.tabs}"
          .activeTab="${this.activeTab}"
          @tab-change="${this.handleTabChange}"
        ></tab-group>

        <div class="header">
          ${this.activeTab !== "ingressclasses" ? D`
            <namespace-dropdown
              .namespaces="${this.namespaces.map((e) => ({ name: e.name }))}"
              .selectedNamespace="${this.selectedNamespace}"
              @namespace-change="${this.handleNamespaceChange}"
              .loading="${this.loading}"
              .includeAllOption="${!0}"
            ></namespace-dropdown>
          ` : ""}
          
          <search-input
            .value="${this.searchQuery}"
            placeholder="Search network resources..."
            @search-change="${this.handleSearchChange}"
          ></search-input>
          
          <div class="controls">
            <button class="btn-create" @click="${this.handleCreate}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              Create
            </button>
          </div>
        </div>

        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading network resources..."></loading-state>
          ` : this.error ? D`
            <empty-state 
              message="${this.error}" 
              icon=""
            ></empty-state>
          ` : D`
            <resource-table
              .columns="${this.getColumns()}"
              .data="${this.getFilteredData()}"
              .getActions="${(e) => this.getActions(e)}"
              emptyMessage="No ${this.activeTab} found"
              @cell-click="${this.handleCellClick}"
              @action="${this.handleAction}"
            ></resource-table>
          `}
        </div>

        <detail-drawer
          .show="${this.showDetails}"
          .loading="${this.loadingDetails}"
          title="${((s = this.selectedItem) == null ? void 0 : s.name) || ""} Details"
          @close="${this.handleDetailsClose}"
        >
          ${this.detailsData ? D`
            <resource-detail-view .resource="${this.detailsData}"></resource-detail-view>
          ` : ""}
        </detail-drawer>
        <delete-modal
          .show="${this.showDeleteModal}"
          .item="${this.itemToDelete}"
          .loading="${this.isDeleting}"
          @confirm-delete="${this.handleConfirmDelete}"
          @cancel-delete="${this.handleCancelDelete}"
        ></delete-modal>

        <create-resource-drawer
          .show="${this.showCreateDrawer}"
          .title="${this.createDrawerTitle}"
          .value="${this.createResourceValue}"
          .submitLabel="Apply"
          .loading="${this.isCreating}"
          @close="${() => {
      this.showCreateDrawer = !1;
    }}"
          @create="${this.handleCreateResource}"
        ></create-resource-drawer>

        <notification-container></notification-container>
      </div>
    `;
  }
};
Ie.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-create {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-create:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    namespace-dropdown {
      --dropdown-bg: var(--vscode-dropdown-background, #3c3c3c);
      --dropdown-color: var(--vscode-dropdown-foreground, #cccccc);
      --dropdown-border: var(--vscode-dropdown-border, #3c3c3c);
      --dropdown-hover-bg: var(--vscode-dropdown-hoverBackground, #2a2a2a);
      --menu-bg: var(--vscode-dropdown-background, #3c3c3c);
      --menu-border: var(--vscode-dropdown-border, #3c3c3c);
      --input-bg: var(--vscode-input-background, #3c3c3c);
      --input-color: var(--vscode-input-foreground, #cccccc);
      --input-border: var(--vscode-input-border, #3c3c3c);
      --option-hover-bg: var(--vscode-list-hoverBackground, #2a2a2a);
      --option-selected-bg: var(--vscode-list-activeSelectionBackground, #094771);
    }
  `;
Ne([
  H({ type: Array })
], Ie.prototype, "resources", 2);
Ne([
  H({ type: Array })
], Ie.prototype, "namespaces", 2);
Ne([
  H({ type: String })
], Ie.prototype, "selectedNamespace", 2);
Ne([
  H({ type: String })
], Ie.prototype, "searchQuery", 2);
Ne([
  H({ type: Boolean })
], Ie.prototype, "loading", 2);
Ne([
  H({ type: String })
], Ie.prototype, "error", 2);
Ne([
  B()
], Ie.prototype, "activeTab", 2);
Ne([
  B()
], Ie.prototype, "showDetails", 2);
Ne([
  B()
], Ie.prototype, "selectedItem", 2);
Ne([
  B()
], Ie.prototype, "loadingDetails", 2);
Ne([
  B()
], Ie.prototype, "detailsData", 2);
Ne([
  B()
], Ie.prototype, "showDeleteModal", 2);
Ne([
  B()
], Ie.prototype, "itemToDelete", 2);
Ne([
  B()
], Ie.prototype, "isDeleting", 2);
Ne([
  B()
], Ie.prototype, "showCreateDrawer", 2);
Ne([
  B()
], Ie.prototype, "createResourceValue", 2);
Ne([
  B()
], Ie.prototype, "createDrawerTitle", 2);
Ne([
  B()
], Ie.prototype, "isCreating", 2);
Ie = Ne([
  me("kubernetes-networks")
], Ie);
var C_ = Object.defineProperty, D_ = Object.getOwnPropertyDescriptor, et = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? D_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && C_(e, t, r), r;
};
let Ue = class extends le {
  constructor() {
    super(...arguments), this.resources = [], this.namespaces = [], this.selectedNamespace = "All Namespaces", this.searchQuery = "", this.loading = !1, this.error = null, this.activeTab = "pvs", this.showDetails = !1, this.selectedItem = null, this.loadingDetails = !1, this.detailsData = null, this.showDeleteModal = !1, this.itemToDelete = null, this.isDeleting = !1, this.tabs = [
      { id: "pvs", label: "Persistent Volumes" },
      { id: "pvcs", label: "Persistent Volume Claims" }
    ];
  }
  getColumns() {
    return this.activeTab === "pvs" ? [
      { key: "name", label: "Name", type: "link" },
      { key: "capacity", label: "Capacity" },
      { key: "accessModes", label: "Access Modes" },
      { key: "reclaimPolicy", label: "Reclaim Policy" },
      { key: "status", label: "Status", type: "custom" },
      { key: "claim", label: "Claim" },
      { key: "storageClass", label: "Storage Class" },
      { key: "age", label: "Age" }
    ] : [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "status", label: "Status", type: "custom" },
      { key: "volume", label: "Volume" },
      { key: "capacity", label: "Capacity" },
      { key: "accessModes", label: "Access Modes" },
      { key: "storageClass", label: "Storage Class" },
      { key: "age", label: "Age" }
    ];
  }
  getActions(s) {
    return [
      { label: "View Details", action: "view" },
      { label: "Edit", action: "edit" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  getFilteredData() {
    let s = this.resources;
    return this.searchQuery && (s = s.filter(
      (e) => JSON.stringify(e).toLowerCase().includes(this.searchQuery.toLowerCase())
    )), s;
  }
  getResourceType() {
    return this.activeTab === "pvs" ? "PersistentVolume" : "PersistentVolumeClaim";
  }
  async handleTabChange(s) {
    this.activeTab = s.detail.tabId, await this.fetchData();
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  async handleNamespaceChange(s) {
    this.selectedNamespace = s.detail.namespace, await this.fetchData();
  }
  handleCellClick(s) {
    const { column: e, item: t } = s.detail;
    e.type === "link" && this.viewDetails(t);
  }
  getStatusClass(s) {
    return {
      Bound: "bound",
      Available: "available",
      Released: "released",
      Pending: "pending",
      Failed: "failed"
    }[s] || "unknown";
  }
  handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        this.viewDetails(t);
        break;
      case "edit":
        this.editItem(t);
        break;
      case "delete":
        this.deleteItem(t);
        break;
    }
  }
  async viewDetails(s) {
    this.selectedItem = s, this.showDetails = !0, this.loadingDetails = !0;
    try {
      const e = this.getResourceType(), t = "namespace" in s ? s.namespace : void 0;
      this.detailsData = await se.getResourceDetails(e, s.name, t);
    } catch (e) {
      console.error("Failed to fetch details:", e), this.detailsData = null;
    } finally {
      this.loadingDetails = !1;
    }
  }
  editItem(s) {
    console.log("Edit item:", s);
  }
  deleteItem(s) {
    const e = this.getResourceType(), t = "namespace" in s ? s.namespace : void 0;
    this.itemToDelete = {
      type: e,
      name: s.name,
      namespace: t || ""
    }, this.showDeleteModal = !0;
  }
  async handleConfirmDelete() {
    if (this.itemToDelete) {
      this.isDeleting = !0;
      try {
        const s = this.itemToDelete.namespace || void 0;
        await se.deleteResource(this.itemToDelete.type, this.itemToDelete.name, s), await this.fetchData(), this.showDeleteModal = !1, this.itemToDelete = null;
      } catch (s) {
        console.error("Failed to delete resource:", s);
      } finally {
        this.isDeleting = !1;
      }
    }
  }
  handleCancelDelete() {
    this.showDeleteModal = !1, this.itemToDelete = null;
  }
  handleCreate() {
    console.log("Create new resource");
  }
  handleDetailsClose() {
    this.showDetails = !1, this.selectedItem = null, this.detailsData = null;
  }
  async fetchData() {
    this.loading = !0, this.error = null;
    try {
      if (this.namespaces.length === 0 && (this.namespaces = await se.getNamespaces()), this.activeTab === "pvs") {
        const s = await se.getPersistentVolumes();
        this.resources = s;
      } else {
        const s = this.selectedNamespace === "All Namespaces" ? void 0 : this.selectedNamespace, e = await se.getPersistentVolumeClaims(s);
        this.resources = e;
      }
    } catch (s) {
      console.error("Failed to fetch storage resources:", s), this.error = s.message || "Failed to fetch storage resources";
    } finally {
      this.loading = !1;
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchData();
  }
  render() {
    var e;
    const s = this.activeTab === "pvcs";
    return D`
      <div class="container">
        <tab-group
          .tabs="${this.tabs}"
          .activeTab="${this.activeTab}"
          @tab-change="${this.handleTabChange}"
        ></tab-group>

        <div class="header">
          ${s ? D`
            <namespace-dropdown
              .namespaces="${this.namespaces.map((t) => ({ name: t.name }))}"
              .selectedNamespace="${this.selectedNamespace}"
              @namespace-change="${this.handleNamespaceChange}"
              .loading="${this.loading}"
              .includeAllOption="${!0}"
            ></namespace-dropdown>
          ` : ""}
          
          <search-input
            .value="${this.searchQuery}"
            placeholder="Search storage resources..."
            @search-change="${this.handleSearchChange}"
          ></search-input>
          
          <div class="controls">
            <button class="btn-create" @click="${this.handleCreate}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              Create
            </button>
          </div>
        </div>

        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading storage resources..."></loading-state>
          ` : this.error ? D`
            <empty-state 
              message="${this.error}" 
              icon=""
            ></empty-state>
          ` : D`
            <resource-table
              .columns="${this.getColumns()}"
              .data="${this.getFilteredData()}"
              .getActions="${(t) => this.getActions(t)}"
              .customRenderers="${{
      status: (t) => D`
                  <span class="status-badge ${this.getStatusClass(t)}">${t}</span>
                `
    }}"
              emptyMessage="No ${this.activeTab === "pvs" ? "persistent volumes" : "persistent volume claims"} found"
              @cell-click="${this.handleCellClick}"
              @action="${this.handleAction}"
            ></resource-table>
          `}
        </div>

        <detail-drawer
          .show="${this.showDetails}"
          .loading="${this.loadingDetails}"
          title="${((e = this.selectedItem) == null ? void 0 : e.name) || ""} Details"
          @close="${this.handleDetailsClose}"
        >
          ${this.detailsData ? D`
            <resource-detail-view .resource="${this.detailsData}"></resource-detail-view>
          ` : ""}
        </detail-drawer>

        <delete-modal
          .show="${this.showDeleteModal}"
          .item="${this.itemToDelete}"
          .loading="${this.isDeleting}"
          @confirm-delete="${this.handleConfirmDelete}"
          @cancel-delete="${this.handleCancelDelete}"
        ></delete-modal>
      </div>
    `;
  }
};
Ue.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-create {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-create:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    namespace-dropdown {
      --dropdown-bg: var(--vscode-dropdown-background, #3c3c3c);
      --dropdown-color: var(--vscode-dropdown-foreground, #cccccc);
      --dropdown-border: var(--vscode-dropdown-border, #3c3c3c);
      --dropdown-hover-bg: var(--vscode-dropdown-hoverBackground, #2a2a2a);
      --menu-bg: var(--vscode-dropdown-background, #3c3c3c);
      --menu-border: var(--vscode-dropdown-border, #3c3c3c);
      --input-bg: var(--vscode-input-background, #3c3c3c);
      --input-color: var(--vscode-input-foreground, #cccccc);
      --input-border: var(--vscode-input-border, #3c3c3c);
      --option-hover-bg: var(--vscode-list-hoverBackground, #2a2a2a);
      --option-selected-bg: var(--vscode-list-activeSelectionBackground, #094771);
    }

    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }

    .status-badge.bound {
      background: var(--vscode-testing-iconPassed, #73c991);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.available {
      background: var(--vscode-testing-iconPassed, #73c991);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.released {
      background: var(--vscode-testing-iconQueued, #cca700);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.pending {
      background: var(--vscode-testing-iconQueued, #cca700);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.failed {
      background: var(--vscode-testing-iconFailed, #f14c4c);
      color: var(--vscode-editor-background, #1e1e1e);
    }
  `;
et([
  H({ type: Array })
], Ue.prototype, "resources", 2);
et([
  H({ type: Array })
], Ue.prototype, "namespaces", 2);
et([
  H({ type: String })
], Ue.prototype, "selectedNamespace", 2);
et([
  H({ type: String })
], Ue.prototype, "searchQuery", 2);
et([
  H({ type: Boolean })
], Ue.prototype, "loading", 2);
et([
  H({ type: String })
], Ue.prototype, "error", 2);
et([
  B()
], Ue.prototype, "activeTab", 2);
et([
  B()
], Ue.prototype, "showDetails", 2);
et([
  B()
], Ue.prototype, "selectedItem", 2);
et([
  B()
], Ue.prototype, "loadingDetails", 2);
et([
  B()
], Ue.prototype, "detailsData", 2);
et([
  B()
], Ue.prototype, "showDeleteModal", 2);
et([
  B()
], Ue.prototype, "itemToDelete", 2);
et([
  B()
], Ue.prototype, "isDeleting", 2);
Ue = et([
  me("kubernetes-storage")
], Ue);
var $_ = Object.defineProperty, A_ = Object.getOwnPropertyDescriptor, tt = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? A_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && $_(e, t, r), r;
};
let We = class extends le {
  constructor() {
    super(...arguments), this.resources = [], this.namespaces = [], this.selectedNamespace = "All Namespaces", this.searchQuery = "", this.loading = !1, this.error = null, this.activeTab = "configmaps", this.showDetails = !1, this.selectedItem = null, this.loadingDetails = !1, this.detailsData = null, this.showDeleteModal = !1, this.itemToDelete = null, this.isDeleting = !1, this.tabs = [
      { id: "configmaps", label: "ConfigMaps" },
      { id: "secrets", label: "Secrets" }
    ];
  }
  getColumns() {
    return this.activeTab === "configmaps" ? [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "data", label: "Data Items" },
      { key: "age", label: "Age" }
    ] : [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "type", label: "Type", type: "custom" },
      { key: "data", label: "Data Items" },
      { key: "age", label: "Age" }
    ];
  }
  getActions(s) {
    return [
      { label: "View Details", action: "view" },
      { label: "Edit", action: "edit" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  getFilteredData() {
    let s = this.resources;
    return this.searchQuery && (s = s.filter(
      (e) => JSON.stringify(e).toLowerCase().includes(this.searchQuery.toLowerCase())
    )), s;
  }
  getResourceType() {
    return this.activeTab === "configmaps" ? "ConfigMap" : "Secret";
  }
  async handleTabChange(s) {
    this.activeTab = s.detail.tabId, await this.fetchData();
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  async handleNamespaceChange(s) {
    this.selectedNamespace = s.detail.namespace, await this.fetchData();
  }
  handleCellClick(s) {
    const { column: e, item: t } = s.detail;
    e.type === "link" && this.viewDetails(t);
  }
  getSecretTypeClass(s) {
    return s.includes("tls") ? "tls" : s.includes("docker") ? "dockercfg" : s === "Opaque" ? "opaque" : "";
  }
  getSecretTypeLabel(s) {
    return {
      Opaque: "Opaque",
      "kubernetes.io/service-account-token": "Service Account",
      "kubernetes.io/dockercfg": "Docker Config",
      "kubernetes.io/dockerconfigjson": "Docker Config JSON",
      "kubernetes.io/basic-auth": "Basic Auth",
      "kubernetes.io/ssh-auth": "SSH Auth",
      "kubernetes.io/tls": "TLS"
    }[s] || s;
  }
  handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        this.viewDetails(t);
        break;
      case "edit":
        this.editItem(t);
        break;
      case "delete":
        this.deleteItem(t);
        break;
    }
  }
  async viewDetails(s) {
    this.selectedItem = s, this.showDetails = !0, this.loadingDetails = !0;
    try {
      const e = this.getResourceType();
      this.detailsData = await se.getResourceDetails(e, s.name, s.namespace);
    } catch (e) {
      console.error("Failed to fetch details:", e), this.detailsData = null;
    } finally {
      this.loadingDetails = !1;
    }
  }
  editItem(s) {
    console.log("Edit item:", s);
  }
  deleteItem(s) {
    const e = this.getResourceType();
    this.itemToDelete = {
      type: e,
      name: s.name,
      namespace: s.namespace
    }, this.showDeleteModal = !0;
  }
  async handleConfirmDelete() {
    if (this.itemToDelete) {
      this.isDeleting = !0;
      try {
        await se.deleteResource(this.itemToDelete.type, this.itemToDelete.name, this.itemToDelete.namespace), await this.fetchData(), this.showDeleteModal = !1, this.itemToDelete = null;
      } catch (s) {
        console.error("Failed to delete resource:", s);
      } finally {
        this.isDeleting = !1;
      }
    }
  }
  handleCancelDelete() {
    this.showDeleteModal = !1, this.itemToDelete = null;
  }
  handleCreate() {
    console.log("Create new resource");
  }
  handleDetailsClose() {
    this.showDetails = !1, this.selectedItem = null, this.detailsData = null;
  }
  async fetchData() {
    this.loading = !0, this.error = null;
    try {
      this.namespaces.length === 0 && (this.namespaces = await se.getNamespaces());
      const s = this.selectedNamespace === "All Namespaces" ? void 0 : this.selectedNamespace;
      if (this.activeTab === "configmaps") {
        const e = await se.getConfigMaps(s);
        this.resources = e;
      } else {
        const e = await se.getSecrets(s);
        this.resources = e;
      }
    } catch (s) {
      console.error("Failed to fetch configuration resources:", s), this.error = s.message || "Failed to fetch configuration resources";
    } finally {
      this.loading = !1;
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchData();
  }
  render() {
    var s;
    return D`
      <div class="container">
        <tab-group
          .tabs="${this.tabs}"
          .activeTab="${this.activeTab}"
          @tab-change="${this.handleTabChange}"
        ></tab-group>

        <div class="header">
          <namespace-dropdown
            .namespaces="${this.namespaces.map((e) => ({ name: e.name }))}"
            .selectedNamespace="${this.selectedNamespace}"
            @namespace-change="${this.handleNamespaceChange}"
            .loading="${this.loading}"
            .includeAllOption="${!0}"
          ></namespace-dropdown>
          
          <search-input
            .value="${this.searchQuery}"
            placeholder="Search configurations..."
            @search-change="${this.handleSearchChange}"
          ></search-input>
          
          <div class="controls">
            <button class="btn-create" @click="${this.handleCreate}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              Create
            </button>
          </div>
        </div>

        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading configurations..."></loading-state>
          ` : this.error ? D`
            <empty-state 
              message="${this.error}" 
              icon=""
            ></empty-state>
          ` : D`
            <resource-table
              .columns="${this.getColumns()}"
              .data="${this.getFilteredData()}"
              .getActions="${(e) => this.getActions(e)}"
              .customRenderers="${this.activeTab === "secrets" ? {
      type: (e) => D`
                  <span class="type-badge ${this.getSecretTypeClass(e)}">
                    ${this.getSecretTypeLabel(e)}
                  </span>
                `
    } : {}}"
              emptyMessage="No ${this.activeTab} found"
              @cell-click="${this.handleCellClick}"
              @action="${this.handleAction}"
            ></resource-table>
          `}
        </div>

        <detail-drawer
          .show="${this.showDetails}"
          .loading="${this.loadingDetails}"
          title="${((s = this.selectedItem) == null ? void 0 : s.name) || ""} Details"
          @close="${this.handleDetailsClose}"
        >
          ${this.detailsData ? D`
            <resource-detail-view .resource="${this.detailsData}"></resource-detail-view>
          ` : ""}
        </detail-drawer>

        <delete-modal
          .show="${this.showDeleteModal}"
          .item="${this.itemToDelete}"
          .loading="${this.isDeleting}"
          @confirm-delete="${this.handleConfirmDelete}"
          @cancel-delete="${this.handleCancelDelete}"
        ></delete-modal>
      </div>
    `;
  }
};
We.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-create {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-create:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    namespace-dropdown {
      --dropdown-bg: var(--vscode-dropdown-background, #3c3c3c);
      --dropdown-color: var(--vscode-dropdown-foreground, #cccccc);
      --dropdown-border: var(--vscode-dropdown-border, #3c3c3c);
      --dropdown-hover-bg: var(--vscode-dropdown-hoverBackground, #2a2a2a);
      --menu-bg: var(--vscode-dropdown-background, #3c3c3c);
      --menu-border: var(--vscode-dropdown-border, #3c3c3c);
      --input-bg: var(--vscode-input-background, #3c3c3c);
      --input-color: var(--vscode-input-foreground, #cccccc);
      --input-border: var(--vscode-input-border, #3c3c3c);
      --option-hover-bg: var(--vscode-list-hoverBackground, #2a2a2a);
      --option-selected-bg: var(--vscode-list-activeSelectionBackground, #094771);
    }

    .type-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      background: var(--vscode-badge-background, #007acc);
      color: var(--vscode-badge-foreground, white);
    }

    .type-badge.opaque {
      background: var(--vscode-testing-iconQueued, #cca700);
    }

    .type-badge.tls {
      background: var(--vscode-testing-iconPassed, #73c991);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .type-badge.dockercfg {
      background: var(--vscode-terminalCommandDecoration-defaultBackground, #40679e);
    }

    .detail-content {
      padding: 1rem;
    }

    .detail-section {
      margin-bottom: 1.5rem;
    }

    .detail-section h3 {
      margin: 0 0 0.5rem 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--vscode-foreground, #cccccc);
    }

    .detail-item {
      margin-bottom: 0.5rem;
      font-size: 13px;
    }

    .detail-key {
      font-weight: 500;
      color: var(--vscode-textLink-foreground, #3794ff);
    }

    .detail-value {
      color: var(--vscode-foreground, #cccccc);
      font-family: var(--vscode-editor-font-family, monospace);
      white-space: pre-wrap;
      word-break: break-all;
    }

    .secret-value {
      color: var(--vscode-textPreformat-foreground, #d7ba7d);
      font-style: italic;
    }

    .data-grid {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .data-item {
      padding: 0.5rem;
      background: var(--vscode-editor-background, #1e1e1e);
      border: 1px solid var(--vscode-widget-border, #303031);
      border-radius: 4px;
    }
  `;
tt([
  H({ type: Array })
], We.prototype, "resources", 2);
tt([
  H({ type: Array })
], We.prototype, "namespaces", 2);
tt([
  H({ type: String })
], We.prototype, "selectedNamespace", 2);
tt([
  H({ type: String })
], We.prototype, "searchQuery", 2);
tt([
  H({ type: Boolean })
], We.prototype, "loading", 2);
tt([
  H({ type: String })
], We.prototype, "error", 2);
tt([
  B()
], We.prototype, "activeTab", 2);
tt([
  B()
], We.prototype, "showDetails", 2);
tt([
  B()
], We.prototype, "selectedItem", 2);
tt([
  B()
], We.prototype, "loadingDetails", 2);
tt([
  B()
], We.prototype, "detailsData", 2);
tt([
  B()
], We.prototype, "showDeleteModal", 2);
tt([
  B()
], We.prototype, "itemToDelete", 2);
tt([
  B()
], We.prototype, "isDeleting", 2);
We = tt([
  me("kubernetes-configurations")
], We);
var E_ = Object.defineProperty, T_ = Object.getOwnPropertyDescriptor, st = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? T_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && E_(e, t, r), r;
};
let Ve = class extends le {
  constructor() {
    super(...arguments), this.releases = [], this.namespaces = [], this.selectedNamespace = "all", this.searchQuery = "", this.loading = !1, this.error = null, this.activeTab = "releases", this.showDetails = !1, this.selectedItem = null, this.loadingDetails = !1, this.detailsData = null, this.showDeleteModal = !1, this.itemToDelete = null, this.isDeleting = !1, this.tabs = [
      { id: "releases", label: "Helm Releases" },
      { id: "repositories", label: "Repositories" }
    ];
  }
  getColumns() {
    return this.activeTab === "releases" ? [
      { key: "name", label: "Name", type: "link" },
      { key: "namespace", label: "Namespace" },
      { key: "revision", label: "Revision", type: "custom" },
      { key: "updated", label: "Updated" },
      { key: "status", label: "Status", type: "custom" },
      { key: "chart", label: "Chart", type: "custom" },
      { key: "appVersion", label: "App Version" }
    ] : [
      { key: "name", label: "Repository Name" },
      { key: "url", label: "URL" },
      { key: "type", label: "Type" }
    ];
  }
  getActions(s) {
    return [
      { label: "View Details", action: "view" },
      { label: "View Values", action: "values" },
      { label: "Upgrade", action: "upgrade" },
      { label: "Rollback", action: "rollback" },
      { label: "Uninstall", action: "delete", danger: !0 }
    ];
  }
  getFilteredData() {
    let s = this.releases;
    return this.selectedNamespace !== "all" && (s = s.filter((e) => e.namespace === this.selectedNamespace)), this.searchQuery && (s = s.filter(
      (e) => JSON.stringify(e).toLowerCase().includes(this.searchQuery.toLowerCase())
    )), s;
  }
  async handleTabChange(s) {
    this.activeTab = s.detail.tabId, await this.fetchData();
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  async handleNamespaceChange(s) {
    const e = s.target;
    this.selectedNamespace = e.value, await this.fetchData();
  }
  handleCellClick(s) {
    const { column: e, item: t } = s.detail;
    e.type === "link" && this.viewDetails(t);
  }
  getStatusClass(s) {
    const e = s.toLowerCase();
    return e === "deployed" ? "status-deployed" : e === "failed" ? "status-failed" : e === "pending" || e === "pending-install" || e === "pending-upgrade" ? "status-pending" : e === "superseded" ? "status-superseded" : "";
  }
  handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        this.viewDetails(t);
        break;
      case "values":
        this.viewValues(t);
        break;
      case "upgrade":
        this.upgradeRelease(t);
        break;
      case "rollback":
        this.rollbackRelease(t);
        break;
      case "delete":
        this.deleteRelease(t);
        break;
    }
  }
  async viewDetails(s) {
    this.selectedItem = s, this.showDetails = !0, this.loadingDetails = !0;
    try {
      this.detailsData = await se.getResourceDetails("Release", s.name, s.namespace);
    } catch (e) {
      console.error("Failed to fetch release details:", e), this.detailsData = null;
    } finally {
      this.loadingDetails = !1;
    }
  }
  viewValues(s) {
    console.log("View values:", s);
  }
  upgradeRelease(s) {
    console.log("Upgrade release:", s);
  }
  rollbackRelease(s) {
    console.log("Rollback release:", s);
  }
  deleteRelease(s) {
    this.itemToDelete = {
      type: "Helm Release",
      name: s.name,
      namespace: s.namespace
    }, this.showDeleteModal = !0;
  }
  async handleConfirmDelete() {
    if (this.itemToDelete) {
      this.isDeleting = !0;
      try {
        await se.deleteResource("Release", this.itemToDelete.name, this.itemToDelete.namespace), await this.fetchData(), this.showDeleteModal = !1, this.itemToDelete = null;
      } catch (s) {
        console.error("Failed to uninstall release:", s);
      } finally {
        this.isDeleting = !1;
      }
    }
  }
  handleCancelDelete() {
    this.showDeleteModal = !1, this.itemToDelete = null;
  }
  handleInstall() {
    console.log("Install new chart");
  }
  handleDetailsClose() {
    this.showDetails = !1, this.selectedItem = null, this.detailsData = null;
  }
  async fetchData() {
    this.loading = !0, this.error = null;
    try {
      if (this.namespaces.length === 0 && (this.namespaces = await se.getNamespaces()), this.activeTab === "releases") {
        const s = this.selectedNamespace === "all" ? void 0 : this.selectedNamespace, e = await se.getHelmReleases(s);
        this.releases = e;
      } else
        this.releases = [];
    } catch (s) {
      console.error("Failed to fetch Helm resources:", s), this.error = s.message || "Failed to fetch Helm resources";
    } finally {
      this.loading = !1;
    }
  }
  renderDetailContent() {
    var e, t;
    if (!this.detailsData && !this.selectedItem) return D``;
    const s = this.selectedItem;
    return s ? D`
      <div class="detail-content">
        <div class="detail-section">
          <h3>Release Information</h3>
          <div class="detail-item">
            <span class="detail-key">Name:</span> ${s.name}
          </div>
          <div class="detail-item">
            <span class="detail-key">Namespace:</span> ${s.namespace}
          </div>
          <div class="detail-item">
            <span class="detail-key">Status:</span> 
            <span class="${this.getStatusClass(s.status)}">${s.status}</span>
          </div>
          <div class="detail-item">
            <span class="detail-key">Revision:</span> 
            <span class="revision-badge">${s.revision}</span>
          </div>
          <div class="detail-item">
            <span class="detail-key">Last Updated:</span> ${s.updated}
          </div>
        </div>

        <div class="detail-section">
          <h3>Chart Information</h3>
          <div class="detail-item">
            <span class="detail-key">Chart:</span> 
            <span class="chart-badge">${s.chart}</span>
          </div>
          <div class="detail-item">
            <span class="detail-key">App Version:</span> ${s.appVersion || "N/A"}
          </div>
        </div>

        ${this.detailsData ? D`
          ${(e = this.detailsData.metadata) != null && e.notes ? D`
            <div class="detail-section">
              <h3>Release Notes</h3>
              <div class="notes-content">
                ${this.detailsData.metadata.notes}
              </div>
            </div>
          ` : ""}

          ${(t = this.detailsData.spec) != null && t.values ? D`
            <div class="detail-section">
              <h3>Values</h3>
              <div class="values-content">
                ${JSON.stringify(this.detailsData.spec.values, null, 2)}
              </div>
            </div>
          ` : ""}
        ` : ""}
      </div>
    ` : D``;
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchData();
  }
  render() {
    var s;
    return D`
      <div class="container">
        <tab-group
          .tabs="${this.tabs}"
          .activeTab="${this.activeTab}"
          @tab-change="${this.handleTabChange}"
        ></tab-group>

        <div class="header">
          <search-input
            .value="${this.searchQuery}"
            placeholder="Search Helm releases..."
            @search-change="${this.handleSearchChange}"
          ></search-input>
          
          <div class="controls">
            <div class="namespace-selector">
              <label for="namespace-select">Namespace:</label>
              <select id="namespace-select" @change="${this.handleNamespaceChange}" .value="${this.selectedNamespace}">
                <option value="all">All namespaces</option>
                ${this.namespaces.map((e) => D`
                  <option value="${e.name}">${e.name}</option>
                `)}
              </select>
            </div>
            
            <button class="btn-install" @click="${this.handleInstall}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              Install Chart
            </button>
          </div>
        </div>

        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading Helm releases..."></loading-state>
          ` : this.error ? D`
            <empty-state 
              message="${this.error}" 
              icon=""
            ></empty-state>
          ` : D`
            <resource-table
              .columns="${this.getColumns()}"
              .data="${this.getFilteredData()}"
              .getActions="${(e) => this.getActions(e)}"
              .customRenderers="${{
      status: (e) => D`
                    <span class="${this.getStatusClass(e)}">${e}</span>
                  `,
      chart: (e) => D`
                    <span class="chart-badge">${e}</span>
                  `,
      revision: (e) => D`
                    <span class="revision-badge">${e}</span>
                  `
    }}"
              emptyMessage="No ${this.activeTab} found"
              @cell-click="${this.handleCellClick}"
              @action="${this.handleAction}"
            ></resource-table>
          `}
        </div>

        <detail-drawer
          .show="${this.showDetails}"
          .loading="${this.loadingDetails}"
          title="${((s = this.selectedItem) == null ? void 0 : s.name) || ""} Details"
          @close="${this.handleDetailsClose}"
        >
          ${this.renderDetailContent()}
        </detail-drawer>

        <delete-modal
          .show="${this.showDeleteModal}"
          .item="${this.itemToDelete}"
          .loading="${this.isDeleting}"
          @confirm-delete="${this.handleConfirmDelete}"
          @cancel-delete="${this.handleCancelDelete}"
        ></delete-modal>
      </div>
    `;
  }
};
Ve.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-install {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-install:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .namespace-selector {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .namespace-selector label {
      font-size: 13px;
      color: var(--vscode-foreground, #cccccc);
    }

    .namespace-selector select {
      padding: 6px 10px;
      background: var(--vscode-dropdown-background, #3c3c3c);
      color: var(--vscode-dropdown-foreground, #cccccc);
      border: 1px solid var(--vscode-dropdown-border, #3c3c3c);
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
    }

    .namespace-selector select:hover {
      background: var(--vscode-dropdown-hoverBackground, #2a2a2a);
    }

    .detail-content {
      padding: 1rem;
    }

    .detail-section {
      margin-bottom: 1.5rem;
    }

    .detail-section h3 {
      margin: 0 0 0.5rem 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--vscode-foreground, #cccccc);
    }

    .detail-item {
      margin-bottom: 0.5rem;
      font-size: 13px;
    }

    .detail-key {
      font-weight: 500;
      color: var(--vscode-textLink-foreground, #3794ff);
    }

    .detail-value {
      color: var(--vscode-foreground, #cccccc);
      font-family: var(--vscode-editor-font-family, monospace);
      white-space: pre-wrap;
      word-break: break-all;
    }

    .status-deployed {
      color: var(--vscode-testing-iconPassed, #73c991);
    }

    .status-failed {
      color: var(--vscode-testing-iconFailed, #f14c4c);
    }

    .status-pending {
      color: var(--vscode-testing-iconQueued, #cca700);
    }

    .status-superseded {
      color: var(--vscode-descriptionForeground, #cccccc80);
    }

    .chart-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      background: var(--vscode-badge-background, #007acc);
      color: var(--vscode-badge-foreground, white);
    }

    .revision-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      background: var(--vscode-textPreformat-background, #ffffff1a);
      color: var(--vscode-textPreformat-foreground, #d7ba7d);
    }

    .values-content {
      background: var(--vscode-editor-background, #1e1e1e);
      border: 1px solid var(--vscode-widget-border, #303031);
      border-radius: 4px;
      padding: 1rem;
      font-family: var(--vscode-editor-font-family, monospace);
      font-size: 12px;
      white-space: pre-wrap;
      overflow-x: auto;
      max-height: 400px;
      overflow-y: auto;
    }

    .notes-content {
      background: var(--vscode-textBlockQuote-background, #7f7f7f1a);
      border-left: 4px solid var(--vscode-textBlockQuote-border, #007acc);
      padding: 0.5rem 1rem;
      margin: 0.5rem 0;
      font-size: 13px;
      white-space: pre-wrap;
    }
  `;
st([
  H({ type: Array })
], Ve.prototype, "releases", 2);
st([
  H({ type: Array })
], Ve.prototype, "namespaces", 2);
st([
  H({ type: String })
], Ve.prototype, "selectedNamespace", 2);
st([
  H({ type: String })
], Ve.prototype, "searchQuery", 2);
st([
  H({ type: Boolean })
], Ve.prototype, "loading", 2);
st([
  H({ type: String })
], Ve.prototype, "error", 2);
st([
  B()
], Ve.prototype, "activeTab", 2);
st([
  B()
], Ve.prototype, "showDetails", 2);
st([
  B()
], Ve.prototype, "selectedItem", 2);
st([
  B()
], Ve.prototype, "loadingDetails", 2);
st([
  B()
], Ve.prototype, "detailsData", 2);
st([
  B()
], Ve.prototype, "showDeleteModal", 2);
st([
  B()
], Ve.prototype, "itemToDelete", 2);
st([
  B()
], Ve.prototype, "isDeleting", 2);
Ve = st([
  me("kubernetes-helm")
], Ve);
var L_ = Object.defineProperty, M_ = Object.getOwnPropertyDescriptor, qt = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? M_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && L_(e, t, r), r;
};
let wt = class extends le {
  constructor() {
    super(...arguments), this.nodes = [], this.searchQuery = "", this.loading = !1, this.error = null, this.showDetails = !1, this.selectedNode = null, this.loadingDetails = !1, this.nodeDetails = null;
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchNodes();
  }
  render() {
    var s;
    return D`
      <div class="container">
        <div class="header">
          <h1 class="title">Nodes</h1>
        </div>

        <div class="content">
          <div class="filters">
            <search-input
              .value=${this.searchQuery}
              placeholder="Search nodes..."
              @search-change=${this.handleSearchChange}
            ></search-input>

            <span class="resource-count">
              ${this.getFilteredNodes().length} nodes
            </span>
          </div>

          ${this.loading ? D`
            <loading-state message="Loading nodes..."></loading-state>
          ` : this.error ? D`
            <empty-state
              message="Error: ${this.error}"
              icon="error"
            ></empty-state>
          ` : this.renderContent()}
        </div>

        <detail-drawer
          .show=${this.showDetails}
          .title=${((s = this.selectedNode) == null ? void 0 : s.name) || "Node Details"}
          .width="800px"
          @close=${() => this.showDetails = !1}
        >
          ${this.renderNodeDetail()}
        </detail-drawer>

        <notification-container></notification-container>
      </div>
    `;
  }
  renderContent() {
    const s = this.getFilteredNodes();
    return s.length === 0 ? D`
        <empty-state
          message="No nodes found"
          icon="servers"
        ></empty-state>
      ` : D`
      <resource-table
        .columns=${this.getColumns()}
        .data=${s}
        .getActions=${(e) => this.getNodeActions(e)}
        @cell-click=${this.handleCellClick}
        @action=${this.handleAction}
      ></resource-table>
    `;
  }
  getColumns() {
    return [
      { key: "name", label: "Name", type: "link" },
      { key: "status", label: "Status", type: "status" },
      { key: "roles", label: "Roles" },
      { key: "age", label: "Age" },
      { key: "version", label: "Version" },
      { key: "os", label: "OS" },
      { key: "containerRuntime", label: "Container Runtime" }
    ];
  }
  getFilteredNodes() {
    if (!this.searchQuery)
      return this.nodes;
    const s = this.searchQuery.toLowerCase();
    return this.nodes.filter(
      (e) => e.name.toLowerCase().includes(s) || e.status.toLowerCase().includes(s) || e.roles.toLowerCase().includes(s) || e.version.toLowerCase().includes(s) || e.os.toLowerCase().includes(s)
    );
  }
  getNodeActions(s) {
    var i, r;
    const e = [
      { label: "View Details", action: "view" }
    ];
    return ((r = (i = this.nodeDetails) == null ? void 0 : i.spec) == null ? void 0 : r.unschedulable) ? e.push({ label: "Uncordon", action: "uncordon" }) : e.push({ label: "Cordon", action: "cordon" }), e.push({ label: "Drain", action: "drain", danger: !0 }), e;
  }
  async fetchNodes() {
    this.loading = !0, this.error = null;
    try {
      this.nodes = await se.getNodes();
    } catch (s) {
      console.error("Failed to fetch nodes:", s), this.error = s instanceof Error ? s.message : "Failed to load nodes", this.showNotification("Failed to load nodes", "error");
    } finally {
      this.loading = !1;
    }
  }
  async fetchNodeDetails(s) {
    this.loadingDetails = !0;
    try {
      const e = await se.getNodeDetails(s);
      this.nodeDetails = e.node || e;
    } catch (e) {
      console.error("Failed to fetch node details:", e), this.showNotification("Failed to load node details", "error");
    } finally {
      this.loadingDetails = !1;
    }
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  async handleCellClick(s) {
    const { column: e, item: t } = s.detail;
    e.key === "name" && await this.viewNodeDetails(t);
  }
  async handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        await this.viewNodeDetails(t);
        break;
      case "cordon":
        await this.cordonNode(t);
        break;
      case "uncordon":
        await this.uncordonNode(t);
        break;
      case "drain":
        await this.drainNode(t);
        break;
    }
  }
  async viewNodeDetails(s) {
    this.selectedNode = s, this.showDetails = !0, await this.fetchNodeDetails(s.name);
  }
  async cordonNode(s) {
    try {
      await se.updateResource(
        "Node",
        s.name,
        void 0,
        JSON.stringify({
          spec: {
            unschedulable: !0
          }
        }),
        "json"
      ), this.showNotification(`Node ${s.name} cordoned successfully`, "success"), await this.fetchNodes();
    } catch (e) {
      console.error("Failed to cordon node:", e), this.showNotification(`Failed to cordon node ${s.name}`, "error");
    }
  }
  async uncordonNode(s) {
    try {
      await se.updateResource(
        "Node",
        s.name,
        void 0,
        JSON.stringify({
          spec: {
            unschedulable: !1
          }
        }),
        "json"
      ), this.showNotification(`Node ${s.name} uncordoned successfully`, "success"), await this.fetchNodes();
    } catch (e) {
      console.error("Failed to uncordon node:", e), this.showNotification(`Failed to uncordon node ${s.name}`, "error");
    }
  }
  async drainNode(s) {
    this.showNotification("Node draining is not yet implemented", "warning");
  }
  renderNodeDetail() {
    return this.selectedNode ? this.loadingDetails ? D`
        <div class="detail-content">
          <loading-state message="Loading node details..."></loading-state>
        </div>
      ` : D`
      <div class="detail-content">
        ${this.renderNodeInfo()}
        ${this.renderSystemInfo()}
        ${this.renderResourceMetrics()}
        ${this.renderConditions()}
        ${this.renderTaints()}
        ${this.renderActionButtons()}
      </div>
    ` : D``;
  }
  renderNodeInfo() {
    var e, t;
    if (!this.selectedNode || !this.nodeDetails) return D``;
    const s = this.nodeDetails.metadata || {};
    return D`
      <h3>Node Information</h3>
      <div class="detail-item">
        <span class="label">Name</span>
        <span class="value">${this.selectedNode.name}</span>
      </div>
      <div class="detail-item">
        <span class="label">Status</span>
        <span class="value">${this.selectedNode.status}</span>
      </div>
      <div class="detail-item">
        <span class="label">Roles</span>
        <span class="value">${this.selectedNode.roles}</span>
      </div>
      <div class="detail-item">
        <span class="label">Created</span>
        <span class="value">${new Date(s.creationTimestamp).toLocaleString()}</span>
      </div>
      <div class="detail-item">
        <span class="label">UID</span>
        <span class="value">${s.uid}</span>
      </div>
      <div class="detail-item">
        <span class="label">Pod CIDR</span>
        <span class="value">${((e = this.nodeDetails.spec) == null ? void 0 : e.podCIDR) || "N/A"}</span>
      </div>
      <div class="detail-item">
        <span class="label">Provider ID</span>
        <span class="value">${((t = this.nodeDetails.spec) == null ? void 0 : t.providerID) || "N/A"}</span>
      </div>
    `;
  }
  renderSystemInfo() {
    var e;
    if (!this.selectedNode || !this.nodeDetails) return D``;
    const s = ((e = this.nodeDetails.status) == null ? void 0 : e.nodeInfo) || {};
    return D`
      <h3>System Information</h3>
      <div class="detail-item">
        <span class="label">Kubernetes Version</span>
        <span class="value">${s.kubeletVersion || "N/A"}</span>
      </div>
      <div class="detail-item">
        <span class="label">OS</span>
        <span class="value">${s.operatingSystem} (${s.osImage})</span>
      </div>
      <div class="detail-item">
        <span class="label">Architecture</span>
        <span class="value">${s.architecture}</span>
      </div>
      <div class="detail-item">
        <span class="label">Kernel Version</span>
        <span class="value">${s.kernelVersion}</span>
      </div>
      <div class="detail-item">
        <span class="label">Container Runtime</span>
        <span class="value">${s.containerRuntimeVersion}</span>
      </div>
      <div class="detail-item">
        <span class="label">Boot ID</span>
        <span class="value">${s.bootID}</span>
      </div>
    `;
  }
  renderResourceMetrics() {
    var t, i;
    if (!this.nodeDetails) return D``;
    const s = ((t = this.nodeDetails.status) == null ? void 0 : t.capacity) || {}, e = ((i = this.nodeDetails.status) == null ? void 0 : i.allocatable) || {};
    return D`
      <h3>Resources</h3>
      <div class="resource-metrics">
        <div class="metric-item">
          <div class="metric-label">CPU</div>
          <div class="metric-value">${s.cpu || "N/A"}</div>
          <div class="metric-usage">Allocatable: ${e.cpu || "N/A"}</div>
        </div>
        <div class="metric-item">
          <div class="metric-label">Memory</div>
          <div class="metric-value">${this.formatMemory(s.memory)}</div>
          <div class="metric-usage">Allocatable: ${this.formatMemory(e.memory)}</div>
        </div>
        <div class="metric-item">
          <div class="metric-label">Pods</div>
          <div class="metric-value">${s.pods || "N/A"}</div>
          <div class="metric-usage">Allocatable: ${e.pods || "N/A"}</div>
        </div>
        <div class="metric-item">
          <div class="metric-label">Ephemeral Storage</div>
          <div class="metric-value">${this.formatMemory(s["ephemeral-storage"])}</div>
          <div class="metric-usage">Allocatable: ${this.formatMemory(e["ephemeral-storage"])}</div>
        </div>
      </div>
    `;
  }
  renderConditions() {
    var e;
    if (!this.nodeDetails) return D``;
    const s = ((e = this.nodeDetails.status) == null ? void 0 : e.conditions) || [];
    return D`
      <h3>Conditions</h3>
      <div class="conditions-grid">
        ${s.map((t) => D`
          <div class="condition-item">
            <div class="condition-status ${t.status.toLowerCase()}"></div>
            <div class="condition-info">
              <div class="condition-type">${t.type}</div>
              <div class="condition-message">${t.message || t.reason || "No message"}</div>
            </div>
          </div>
        `)}
      </div>
    `;
  }
  renderTaints() {
    var e;
    if (!this.nodeDetails) return D``;
    const s = ((e = this.nodeDetails.spec) == null ? void 0 : e.taints) || [];
    return s.length === 0 ? D`` : D`
      <h3>Taints</h3>
      <div class="taints-list">
        ${s.map((t) => D`
          <div class="taint-item">
            <span>${t.key}${t.value ? `=${t.value}` : ""}</span>
            <span class="taint-effect">${t.effect}</span>
          </div>
        `)}
      </div>
    `;
  }
  renderActionButtons() {
    var e;
    if (!this.selectedNode || !this.nodeDetails) return D``;
    const s = (e = this.nodeDetails.spec) == null ? void 0 : e.unschedulable;
    return D`
      <div class="action-buttons">
        ${s ? D`
          <button class="action-button primary" @click=${() => this.uncordonNode(this.selectedNode)}>
            Uncordon Node
          </button>
        ` : D`
          <button class="action-button primary" @click=${() => this.cordonNode(this.selectedNode)}>
            Cordon Node
          </button>
        `}
        <button class="action-button danger" @click=${() => this.drainNode(this.selectedNode)}>
          Drain Node
        </button>
      </div>
    `;
  }
  formatMemory(s) {
    if (!s) return "N/A";
    const e = s.match(/(\d+)Ki/);
    return e && e[1] ? `${(parseInt(e[1]) / 1024 / 1024).toFixed(2)} GB` : s;
  }
  showNotification(s, e = "info") {
    const t = new CustomEvent("show-notification", {
      detail: { message: s, type: e },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(t);
  }
};
wt.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .filters {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .resource-count {
      font-size: 13px;
      color: var(--vscode-descriptionForeground, #cccccc80);
      margin-left: auto;
    }

    /* Detail styles */
    .detail-content {
      padding: 1rem;
    }

    .detail-section {
      margin-bottom: 1.5rem;
    }

    .detail-section h3 {
      margin: 0 0 0.5rem 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--vscode-foreground, #cccccc);
    }

    .detail-item {
      margin-bottom: 0.5rem;
      font-size: 13px;
    }

    .detail-key {
      font-weight: 500;
      color: var(--vscode-textLink-foreground, #3794ff);
    }

    .detail-value {
      color: var(--vscode-foreground, #cccccc);
      font-family: var(--vscode-editor-font-family, monospace);
      white-space: pre-wrap;
      word-break: break-all;
    }

    .condition-item {
      background: var(--vscode-editor-background, #1e1e1e);
      border: 1px solid var(--vscode-widget-border, #303031);
      border-radius: 4px;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .condition-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .condition-type {
      font-weight: 500;
      color: var(--vscode-foreground, #cccccc);
    }

    .condition-status {
      font-size: 12px;
      color: var(--vscode-descriptionForeground, #cccccc80);
    }

    .taint-item {
      display: inline-block;
      background: var(--vscode-textBlockQuote-background, #7f7f7f1a);
      border-radius: 4px;
      padding: 4px 8px;
      margin: 2px;
      font-size: 11px;
    }

    .role-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      background: var(--vscode-badge-background, #007acc);
      color: var(--vscode-badge-foreground, white);
      margin-right: 4px;
    }

    .addresses-grid {
      display: grid;
      gap: 0.5rem;
    }

    .address-item {
      padding: 0.5rem;
      background: var(--vscode-editor-background, #1e1e1e);
      border: 1px solid var(--vscode-widget-border, #303031);
      border-radius: 4px;
    }

  `;
qt([
  H({ type: Array })
], wt.prototype, "nodes", 2);
qt([
  H({ type: String })
], wt.prototype, "searchQuery", 2);
qt([
  H({ type: Boolean })
], wt.prototype, "loading", 2);
qt([
  H({ type: String })
], wt.prototype, "error", 2);
qt([
  B()
], wt.prototype, "showDetails", 2);
qt([
  B()
], wt.prototype, "selectedNode", 2);
qt([
  B()
], wt.prototype, "loadingDetails", 2);
qt([
  B()
], wt.prototype, "nodeDetails", 2);
wt = qt([
  me("kubernetes-nodes")
], wt);
var I_ = Object.defineProperty, R_ = Object.getOwnPropertyDescriptor, Je = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? R_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && I_(e, t, r), r;
};
let ze = class extends le {
  constructor() {
    super(...arguments), this.show = !1, this.crdName = "", this.crdKind = "", this.crdGroup = "", this.crdVersion = "", this.crdScope = "Namespaced", this.loading = !1, this.searchQuery = "", this.selectedNamespace = "All Namespaces", this.instances = [], this.showInstanceDetails = !1, this.selectedInstance = null, this.instanceDetailsData = null, this.loadingDetails = !1, this.error = null;
  }
  async fetchInstances() {
    this.loading = !0, this.error = null;
    try {
      const s = await se.getCRDInstances(this.crdName);
      let e = [];
      if (Array.isArray(s))
        e = s;
      else if (s && typeof s == "object") {
        const t = s;
        Array.isArray(t.items) ? e = t.items : Array.isArray(t.instances) ? e = t.instances : Array.isArray(t.resources) ? e = t.resources : e = [];
      }
      this.instances = e.map((t) => {
        var i, r, n, o, a, l, c;
        return {
          name: ((i = t.metadata) == null ? void 0 : i.name) || t.name || "",
          namespace: ((r = t.metadata) == null ? void 0 : r.namespace) || t.namespace,
          apiVersion: t.apiVersion || `${this.crdGroup}/${this.crdVersion}`,
          kind: t.kind || this.crdKind,
          status: ((n = t.status) == null ? void 0 : n.phase) || ((o = t.status) == null ? void 0 : o.state) || "Unknown",
          age: this.calculateAge(((a = t.metadata) == null ? void 0 : a.creationTimestamp) || t.creationTimestamp),
          labels: ((l = t.metadata) == null ? void 0 : l.labels) || t.labels || {},
          annotations: ((c = t.metadata) == null ? void 0 : c.annotations) || t.annotations || {}
        };
      });
    } catch (s) {
      console.error("Failed to fetch CRD instances:", s), this.error = `Failed to fetch instances: ${(s == null ? void 0 : s.message) || "Unknown error"}`, this.instances = [];
    } finally {
      this.loading = !1;
    }
  }
  async fetchInstanceDetails(s) {
    this.loadingDetails = !0;
    try {
      const e = this.crdScope === "Namespaced", t = await se.getCRDInstanceDetails(
        this.crdName,
        s.name,
        e ? s.namespace : void 0
      );
      this.instanceDetailsData = t;
    } catch (e) {
      console.error("Failed to fetch instance details:", e), this.instanceDetailsData = {
        apiVersion: s.apiVersion,
        kind: s.kind,
        metadata: {
          name: s.name,
          namespace: s.namespace,
          labels: s.labels,
          annotations: s.annotations
        },
        error: `Failed to fetch details: ${(e == null ? void 0 : e.message) || "Unknown error"}`
      };
    } finally {
      this.loadingDetails = !1;
    }
  }
  calculateAge(s) {
    if (!s) return "Unknown";
    const e = new Date(s), i = (/* @__PURE__ */ new Date()).getTime() - e.getTime(), r = Math.floor(i / 1e3), n = Math.floor(r / 60), o = Math.floor(n / 60), a = Math.floor(o / 24);
    return a > 0 ? `${a}d ${o % 24}h` : o > 0 ? `${o}h ${n % 60}m` : n > 0 ? `${n}m ${r % 60}s` : `${r}s`;
  }
  getColumns() {
    const s = [
      { key: "name", label: "Name", type: "link" }
    ];
    return this.crdScope === "Namespaced" && s.push({ key: "namespace", label: "Namespace" }), s.push(
      { key: "status", label: "Status", type: "custom" },
      { key: "age", label: "Age" }
    ), s;
  }
  getActions(s) {
    return [
      { label: "View Details", action: "view" },
      { label: "Edit YAML", action: "edit" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  getFilteredInstances() {
    let s = this.instances;
    return this.crdScope === "Namespaced" && this.selectedNamespace !== "All Namespaces" && (s = s.filter((e) => e.namespace === this.selectedNamespace)), this.searchQuery && (s = s.filter(
      (e) => {
        var t, i;
        return e.name.toLowerCase().includes(this.searchQuery.toLowerCase()) || ((i = (t = e.namespace) == null ? void 0 : t.toLowerCase()) == null ? void 0 : i.includes(this.searchQuery.toLowerCase())) || !1;
      }
    )), s;
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  handleNamespaceChange(s) {
    this.selectedNamespace = s.detail.namespace;
  }
  handleCellClick(s) {
    const e = s.detail.item;
    this.viewInstanceDetails(e);
  }
  async handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        await this.viewInstanceDetails(t);
        break;
      case "edit":
        console.log("Edit YAML for:", t.name);
        break;
      case "delete":
        confirm(`Are you sure you want to delete ${t.name}?`) && await this.deleteInstance(t);
        break;
    }
  }
  async deleteInstance(s) {
    try {
      const e = this.crdScope === "Namespaced";
      await se.deleteCRDInstance(
        this.crdName,
        s.name,
        e ? s.namespace : void 0
      ), await this.fetchInstances(), console.log(`Successfully deleted ${s.name}`);
    } catch (e) {
      console.error("Failed to delete instance:", e), alert(`Failed to delete instance: ${(e == null ? void 0 : e.message) || "Unknown error"}`);
    }
  }
  async viewInstanceDetails(s) {
    this.selectedInstance = s, this.showInstanceDetails = !0, await this.fetchInstanceDetails(s);
  }
  handleInstanceDetailsClose() {
    this.showInstanceDetails = !1, this.selectedInstance = null, this.instanceDetailsData = null;
  }
  handleClose() {
    this.dispatchEvent(new CustomEvent("close"));
  }
  connectedCallback() {
    super.connectedCallback();
  }
  updated(s) {
    super.updated(s), s.has("show") && this.show && !s.get("show") && (this.fetchInstances(), this.searchQuery = "", this.selectedNamespace = "All Namespaces", this.error = null);
  }
  render() {
    var n;
    const s = this.getFilteredInstances(), e = this.instances.length, t = new Set(this.instances.map((o) => o.namespace).filter(Boolean)), i = Array.from(t).sort(), r = {
      ready: this.instances.filter((o) => o.status === "Ready").length,
      progressing: this.instances.filter((o) => o.status === "Progressing").length,
      error: this.instances.filter((o) => o.status === "Error").length
    };
    return D`
      <div class="header">
        <div class="title-section">
          <h2 class="title">
            ${this.crdKind} Instances
            <span class="kind-badge">${this.crdGroup}/${this.crdVersion}</span>
          </h2>
          <div class="subtitle">
            Viewing instances of ${this.crdName}
          </div>
        </div>
        <button class="close-button" @click="${this.handleClose}">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>

      <div class="controls">
        ${this.crdScope === "Namespaced" ? D`
          <namespace-dropdown
            .namespaces="${i.map((o) => ({ name: o }))}"
            .selectedNamespace="${this.selectedNamespace}"
            @namespace-change="${this.handleNamespaceChange}"
            .loading="${this.loading}"
            .includeAllOption="${!0}"
          ></namespace-dropdown>
        ` : ""}
        
        <search-input
          .value="${this.searchQuery}"
          placeholder="Search instances..."
          @search-change="${this.handleSearchChange}"
        ></search-input>
      </div>

      <div class="content">
        ${this.error ? D`
          <div style="padding: 1rem; color: var(--vscode-errorForeground, #f48771); background: var(--vscode-inputValidation-errorBackground, #5a1d1d); border-radius: 4px; margin-bottom: 1rem;">
            ${this.error}
          </div>
        ` : ""}
        
        ${this.error ? "" : D`
          <div class="stats">
            <div class="stat">
              <div class="stat-label">Total Instances</div>
              <div class="stat-value">${e}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Ready</div>
              <div class="stat-value" style="color: var(--vscode-testing-iconPassed, #73c991)">
                ${r.ready}
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">Progressing</div>
              <div class="stat-value" style="color: var(--vscode-testing-iconQueued, #cca700)">
                ${r.progressing}
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">Error</div>
              <div class="stat-value" style="color: var(--vscode-testing-iconFailed, #f14c4c)">
                ${r.error}
              </div>
            </div>
          </div>
        `}

        ${this.loading ? D`
          <loading-state message="Loading instances..."></loading-state>
        ` : this.error ? "" : s.length === 0 ? D`
          <empty-state 
            message="${this.searchQuery || this.selectedNamespace !== "All Namespaces" ? "No instances found matching your filters" : `No ${this.crdKind} instances found`}"
            icon=""
          ></empty-state>
        ` : D`
          <resource-table
            .columns="${this.getColumns()}"
            .data="${s}"
            .getActions="${(o) => this.getActions(o)}"
            .customRenderers="${{
      status: (o) => {
        const a = (o == null ? void 0 : o.toLowerCase()) || "unknown";
        return D`
                  <span class="status-badge ${a}">
                    ${o || "Unknown"}
                  </span>
                `;
      }
    }}"
            @cell-click="${this.handleCellClick}"
            @action="${this.handleAction}"
          ></resource-table>
        `}
      </div>

      <detail-drawer
        .show="${this.showInstanceDetails}"
        title="${((n = this.selectedInstance) == null ? void 0 : n.name) || ""} Details"
        @close="${this.handleInstanceDetailsClose}"
      >
        ${this.loadingDetails ? D`
          <loading-state message="Loading instance details..."></loading-state>
        ` : this.instanceDetailsData ? D`
          <resource-detail-view .resource="${this.instanceDetailsData}"></resource-detail-view>
        ` : ""}
      </detail-drawer>
    `;
  }
};
ze.styles = re`
    :host {
      display: block;
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 60%;
      max-width: 900px;
      background: var(--vscode-sideBar-background, #252526);
      border-left: 1px solid var(--vscode-widget-border, #303031);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }

    :host([show]) {
      transform: translateX(0);
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid var(--vscode-widget-border, #303031);
      background: var(--vscode-editor-background, #1e1e1e);
    }

    .title-section {
      flex: 1;
    }

    .title {
      font-size: 1.2rem;
      font-weight: 600;
      margin: 0;
      color: var(--vscode-foreground, #cccccc);
    }

    .subtitle {
      font-size: 0.9rem;
      color: var(--vscode-descriptionForeground, #8e8e8e);
      margin-top: 0.25rem;
    }

    .kind-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      background: var(--vscode-badge-background, #007acc);
      color: var(--vscode-badge-foreground, white);
      margin-left: 0.5rem;
    }

    .close-button {
      background: none;
      border: none;
      color: var(--vscode-foreground, #cccccc);
      cursor: pointer;
      padding: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-button:hover {
      color: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      padding: 1rem;
      display: flex;
      gap: 1rem;
      align-items: center;
      border-bottom: 1px solid var(--vscode-widget-border, #303031);
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .stats {
      display: flex;
      gap: 2rem;
      padding: 1rem;
      background: var(--vscode-editor-background, #1e1e1e);
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    .stat {
      display: flex;
      flex-direction: column;
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--vscode-descriptionForeground, #8e8e8e);
      margin-bottom: 0.25rem;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--vscode-foreground, #cccccc);
    }

    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
    }

    .status-badge.ready {
      background: var(--vscode-testing-iconPassed, #73c991);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.progressing {
      background: var(--vscode-testing-iconQueued, #cca700);
      color: var(--vscode-editor-background, #1e1e1e);
    }

    .status-badge.error {
      background: var(--vscode-testing-iconFailed, #f14c4c);
      color: white;
    }

    .status-badge.unknown {
      background: var(--vscode-descriptionForeground, #8e8e8e);
      color: white;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 999;
    }

    :host([show]) ~ .overlay,
    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
  `;
Je([
  H({ type: Boolean, reflect: !0 })
], ze.prototype, "show", 2);
Je([
  H({ type: String })
], ze.prototype, "crdName", 2);
Je([
  H({ type: String })
], ze.prototype, "crdKind", 2);
Je([
  H({ type: String })
], ze.prototype, "crdGroup", 2);
Je([
  H({ type: String })
], ze.prototype, "crdVersion", 2);
Je([
  H({ type: String })
], ze.prototype, "crdScope", 2);
Je([
  H({ type: Boolean })
], ze.prototype, "loading", 2);
Je([
  B()
], ze.prototype, "searchQuery", 2);
Je([
  B()
], ze.prototype, "selectedNamespace", 2);
Je([
  B()
], ze.prototype, "instances", 2);
Je([
  B()
], ze.prototype, "showInstanceDetails", 2);
Je([
  B()
], ze.prototype, "selectedInstance", 2);
Je([
  B()
], ze.prototype, "instanceDetailsData", 2);
Je([
  B()
], ze.prototype, "loadingDetails", 2);
Je([
  B()
], ze.prototype, "error", 2);
ze = Je([
  me("crd-instances-drawer")
], ze);
var O_ = Object.defineProperty, P_ = Object.getOwnPropertyDescriptor, qe = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? P_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && O_(e, t, r), r;
};
let Pe = class extends le {
  constructor() {
    super(...arguments), this.resources = [], this.searchQuery = "", this.loading = !1, this.error = null, this.showDetails = !1, this.selectedItem = null, this.loadingDetails = !1, this.detailsData = null, this.showDeleteModal = !1, this.itemToDelete = null, this.isDeleting = !1, this.showCreateDrawer = !1, this.createResourceValue = "", this.isCreating = !1, this.showInstancesDrawer = !1, this.selectedCRDForInstances = null;
  }
  getColumns() {
    return [
      { key: "name", label: "Name", type: "link" },
      { key: "group", label: "Group" },
      { key: "version", label: "Version" },
      { key: "kind", label: "Kind" },
      { key: "age", label: "Age" }
    ];
  }
  getActions(s) {
    return [
      { label: "View Details", action: "view" },
      { label: "View Instances", action: "instances" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  getFilteredData() {
    let s = this.resources;
    return this.searchQuery && (s = s.filter(
      (e) => JSON.stringify(e).toLowerCase().includes(this.searchQuery.toLowerCase())
    )), s;
  }
  handleSearchChange(s) {
    this.searchQuery = s.detail.value;
  }
  handleCellClick(s) {
    const e = s.detail.item;
    this.viewDetails(e);
  }
  handleAction(s) {
    const { action: e, item: t } = s.detail;
    switch (e) {
      case "view":
        this.viewDetails(t);
        break;
      case "instances":
        this.viewInstances(t);
        break;
      case "delete":
        this.deleteItem(t);
        break;
    }
  }
  async viewDetails(s) {
    this.selectedItem = s, this.showDetails = !0, this.loadingDetails = !0;
    try {
      this.detailsData = await se.getResourceDetails("crd", s.name);
    } catch (e) {
      console.error("Failed to fetch CRD details:", e), this.detailsData = null;
    } finally {
      this.loadingDetails = !1;
    }
  }
  viewInstances(s) {
    this.selectedCRDForInstances = s, this.showInstancesDrawer = !0;
  }
  deleteItem(s) {
    this.itemToDelete = {
      type: "CustomResourceDefinition",
      name: s.name,
      namespace: void 0
    }, this.showDeleteModal = !0;
  }
  async handleConfirmDelete() {
    var s, e;
    if (this.itemToDelete) {
      this.isDeleting = !0;
      try {
        await se.deleteResource("crd", this.itemToDelete.name), await this.fetchData(), this.showDeleteModal = !1, this.itemToDelete = null;
        const t = (s = this.shadowRoot) == null ? void 0 : s.querySelector("notification-container");
        t && typeof t.addNotification == "function" && t.addNotification({ type: "success", message: "CRD deleted successfully" });
      } catch (t) {
        console.error("Failed to delete CRD:", t);
        const i = (e = this.shadowRoot) == null ? void 0 : e.querySelector("notification-container");
        i && typeof i.addNotification == "function" && i.addNotification({ type: "error", message: "Failed to delete CRD" });
      } finally {
        this.isDeleting = !1;
      }
    }
  }
  handleCancelDelete() {
    this.showDeleteModal = !1, this.itemToDelete = null;
  }
  handleCreate() {
    this.createResourceValue = `apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: crontabs.example.com
spec:
  group: example.com
  versions:
  - name: v1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              cronSpec:
                type: string
              image:
                type: string
              replicas:
                type: integer
  scope: Namespaced
  names:
    plural: crontabs
    singular: crontab
    kind: CronTab
    shortNames:
    - ct`, this.showCreateDrawer = !0;
  }
  async handleCreateResource(s) {
    var r, n;
    const { resource: e, format: t } = s.detail;
    let i = "";
    try {
      i = t === "json" ? JSON.stringify(e) : e.yaml, this.isCreating = !0, await se.createResource(i, t), await this.fetchData(), this.showCreateDrawer = !1, this.createResourceValue = "";
      const o = (r = this.shadowRoot) == null ? void 0 : r.querySelector("notification-container");
      o && typeof o.addNotification == "function" && o.addNotification({ type: "success", message: "CRD created successfully" });
    } catch (o) {
      const a = (n = this.shadowRoot) == null ? void 0 : n.querySelector("notification-container");
      a && typeof a.addNotification == "function" && a.addNotification({ type: "error", message: `Failed to create CRD: ${(o == null ? void 0 : o.message) || "Unknown error"}` });
    } finally {
      this.isCreating = !1;
    }
  }
  handleDetailsClose() {
    this.showDetails = !1, this.selectedItem = null, this.detailsData = null;
  }
  handleInstancesDrawerClose() {
    this.showInstancesDrawer = !1, this.selectedCRDForInstances = null;
  }
  async fetchData() {
    this.loading = !0, this.error = null;
    try {
      const s = await se.getCRDs();
      this.resources = s;
    } catch (s) {
      console.error("Failed to fetch CRDs:", s), this.error = s.message || "Failed to fetch Custom Resource Definitions";
    } finally {
      this.loading = !1;
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.fetchData();
  }
  render() {
    var s, e, t, i, r, n;
    return D`
      <div class="container">
        <div class="header">
          <search-input
            .value="${this.searchQuery}"
            placeholder="Search CRDs..."
            @search-change="${this.handleSearchChange}"
          ></search-input>
          
          <div class="controls">
            <button class="btn-create" @click="${this.handleCreate}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              Create CRD
            </button>
          </div>
        </div>

        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading Custom Resource Definitions..."></loading-state>
          ` : this.error ? D`
            <empty-state 
              message="${this.error}" 
              icon=""
            ></empty-state>
          ` : D`
            <resource-table
              .columns="${this.getColumns()}"
              .data="${this.getFilteredData()}"
              .getActions="${(o) => this.getActions(o)}"
              emptyMessage="No Custom Resource Definitions found"
              @cell-click="${this.handleCellClick}"
              @action="${this.handleAction}"
            ></resource-table>
          `}
        </div>

        <detail-drawer
          .show="${this.showDetails}"
          .loading="${this.loadingDetails}"
          title="${((s = this.selectedItem) == null ? void 0 : s.name) || ""} Details"
          @close="${this.handleDetailsClose}"
        >
          ${this.detailsData ? D`
            <resource-detail-view .resource="${this.detailsData}"></resource-detail-view>
          ` : ""}
        </detail-drawer>

        <delete-modal
          .show="${this.showDeleteModal}"
          .item="${this.itemToDelete}"
          .loading="${this.isDeleting}"
          @confirm-delete="${this.handleConfirmDelete}"
          @cancel-delete="${this.handleCancelDelete}"
        ></delete-modal>

        <create-resource-drawer
          .show="${this.showCreateDrawer}"
          .title="Create Custom Resource Definition"
          .value="${this.createResourceValue}"
          .submitLabel="Apply"
          .loading="${this.isCreating}"
          @close="${() => {
      this.showCreateDrawer = !1;
    }}"
          @create="${this.handleCreateResource}"
        ></create-resource-drawer>

        <notification-container></notification-container>
      </div>

      <crd-instances-drawer
        .show="${this.showInstancesDrawer}"
        .crdName="${((e = this.selectedCRDForInstances) == null ? void 0 : e.name) || ""}"
        .crdKind="${((t = this.selectedCRDForInstances) == null ? void 0 : t.kind) || ""}"
        .crdGroup="${((i = this.selectedCRDForInstances) == null ? void 0 : i.group) || ""}"
        .crdVersion="${((r = this.selectedCRDForInstances) == null ? void 0 : r.version) || ""}"
        .crdScope="${((n = this.selectedCRDForInstances) == null ? void 0 : n.scope) || "Namespaced"}"
        @close="${this.handleInstancesDrawerClose}"
      ></crd-instances-drawer>
    `;
  }
};
Pe.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-create {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-create:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
  `;
qe([
  H({ type: Array })
], Pe.prototype, "resources", 2);
qe([
  H({ type: String })
], Pe.prototype, "searchQuery", 2);
qe([
  H({ type: Boolean })
], Pe.prototype, "loading", 2);
qe([
  H({ type: String })
], Pe.prototype, "error", 2);
qe([
  B()
], Pe.prototype, "showDetails", 2);
qe([
  B()
], Pe.prototype, "selectedItem", 2);
qe([
  B()
], Pe.prototype, "loadingDetails", 2);
qe([
  B()
], Pe.prototype, "detailsData", 2);
qe([
  B()
], Pe.prototype, "showDeleteModal", 2);
qe([
  B()
], Pe.prototype, "itemToDelete", 2);
qe([
  B()
], Pe.prototype, "isDeleting", 2);
qe([
  B()
], Pe.prototype, "showCreateDrawer", 2);
qe([
  B()
], Pe.prototype, "createResourceValue", 2);
qe([
  B()
], Pe.prototype, "isCreating", 2);
qe([
  B()
], Pe.prototype, "showInstancesDrawer", 2);
qe([
  B()
], Pe.prototype, "selectedCRDForInstances", 2);
Pe = qe([
  me("kubernetes-crds")
], Pe);
var B_ = Object.defineProperty, N_ = Object.getOwnPropertyDescriptor, Ra = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? N_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && B_(e, t, r), r;
};
let hr = class extends le {
  constructor() {
    super(...arguments), this.subRoute = null, this.activeView = "workloads";
  }
  connectedCallback() {
    super.connectedCallback(), this.updateActiveView();
  }
  updated(s) {
    super.updated(s), s.has("subRoute") && this.updateActiveView();
  }
  updateActiveView() {
    var s;
    if (this.subRoute)
      ["workloads", "networks", "storage", "configurations", "helm", "nodes", "crds"].includes(this.subRoute) && (this.activeView = this.subRoute);
    else {
      const e = window.location.pathname;
      if (e.includes("/kubernetes/")) {
        const t = (s = e.split("/kubernetes/")[1]) == null ? void 0 : s.split("/")[0];
        t && ["workloads", "networks", "storage", "configurations", "helm", "nodes", "crds"].includes(t) && (this.activeView = t);
      }
    }
  }
  render() {
    return D`
      <div class="kubernetes-container">
        <div class="view-container">
          ${this.renderActiveView()}
        </div>
      </div>
    `;
  }
  renderActiveView() {
    switch (this.activeView) {
      case "workloads":
        return D`<kubernetes-workloads></kubernetes-workloads>`;
      case "networks":
        return D`<kubernetes-networks></kubernetes-networks>`;
      case "storage":
        return D`<kubernetes-storage></kubernetes-storage>`;
      case "configurations":
        return D`<kubernetes-configurations></kubernetes-configurations>`;
      case "helm":
        return D`<kubernetes-helm></kubernetes-helm>`;
      case "nodes":
        return D`<kubernetes-nodes></kubernetes-nodes>`;
      case "crds":
        return D`<kubernetes-crds></kubernetes-crds>`;
      default:
        return D`
          <div class="error-message">
            <h2>Invalid Kubernetes View</h2>
            <p>The requested view "${this.activeView}" is not available.</p>
          </div>
        `;
    }
  }
};
hr.styles = re`
    :host {
      display: block;
      height: 100%;
      width: 100%;
    }

    .kubernetes-container {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .view-container {
      flex: 1;
      overflow: hidden;
    }

    .error-message {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }
  `;
Ra([
  H({ type: String })
], hr.prototype, "subRoute", 2);
Ra([
  H({ type: String })
], hr.prototype, "activeView", 2);
hr = Ra([
  me("kubernetes-tab")
], hr);
var F_ = Object.defineProperty, z_ = Object.getOwnPropertyDescriptor, ds = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? z_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && F_(e, t, r), r;
};
let It = class extends le {
  constructor() {
    super(...arguments), this.initialTab = "playbooks", this.loading = !1, this.activeTab = "playbooks", this.searchQuery = "", this.playbooks = [], this.templates = [], this.showCreateDropdown = !1, this.handleOutsideClick = (s) => {
      s.target.closest(".action-menu") || (this.showCreateDropdown = !1);
    }, this.handleLocationChange = () => {
      const s = window.location.pathname;
      s.includes("/ansible/templates") ? this.activeTab = "templates" : s.includes("/ansible/playbooks") ? this.activeTab = "playbooks" : this.activeTab = this.initialTab || "playbooks";
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.handleLocationChange(), this.loadData(), document.addEventListener("click", this.handleOutsideClick), window.addEventListener("popstate", this.handleLocationChange);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("click", this.handleOutsideClick), window.removeEventListener("popstate", this.handleLocationChange);
  }
  async loadData() {
    this.loading = !0, await new Promise((s) => setTimeout(s, 500)), this.playbooks = [
      {
        id: "1",
        name: "deploy-webapp.yml",
        description: "Deploy web application to production servers",
        path: "/ansible/playbooks/deploy-webapp.yml",
        hosts: "webservers",
        tags: ["deployment", "webapp", "production"],
        lastModified: "2024-01-15T10:30:00Z",
        status: "active"
      },
      {
        id: "2",
        name: "update-system.yml",
        description: "System update and security patches for all servers",
        path: "/ansible/playbooks/update-system.yml",
        hosts: "all",
        tags: ["maintenance", "security", "updates"],
        lastModified: "2024-01-14T15:45:00Z",
        status: "active"
      },
      {
        id: "3",
        name: "backup-databases.yml",
        description: "Automated database backup for MySQL and PostgreSQL",
        path: "/ansible/playbooks/backup-databases.yml",
        hosts: "dbservers",
        tags: ["backup", "database", "scheduled"],
        lastModified: "2024-01-13T08:00:00Z",
        status: "draft"
      }
    ], this.templates = [
      {
        id: "1",
        name: "Deploy Production App",
        description: "Template for deploying applications to production environment",
        type: "job",
        playbook: "deploy-webapp.yml",
        inventory: "production",
        credentials: ["ssh-prod", "vault-prod"],
        variables: { version: "latest", environment: "production" },
        lastUsed: "2024-01-15T14:30:00Z",
        status: "enabled"
      },
      {
        id: "2",
        name: "System Maintenance Workflow",
        description: "Complete system maintenance workflow including updates and cleanup",
        type: "workflow",
        playbook: "update-system.yml",
        inventory: "all-servers",
        credentials: ["ssh-admin"],
        variables: { reboot: !0, cleanup: !0 },
        lastUsed: "2024-01-14T20:00:00Z",
        status: "enabled"
      },
      {
        id: "3",
        name: "Database Backup Job",
        description: "Scheduled database backup job template",
        type: "job",
        playbook: "backup-databases.yml",
        inventory: "database-servers",
        credentials: ["ssh-db", "backup-storage"],
        variables: { compression: "gzip", retention_days: 30 },
        lastUsed: "2024-01-13T03:00:00Z",
        status: "disabled"
      }
    ], this.loading = !1;
  }
  handleTabClick(s, e) {
    s.preventDefault(), this.activeTab = e;
    const t = e === "templates" ? "/ansible/templates" : "/ansible/playbooks";
    window.history.pushState({}, "", t);
  }
  handleSearch(s) {
    this.searchQuery = s.detail.value;
  }
  get filteredPlaybooks() {
    if (!this.searchQuery) return this.playbooks;
    const s = this.searchQuery.toLowerCase();
    return this.playbooks.filter(
      (e) => e.name.toLowerCase().includes(s) || e.description.toLowerCase().includes(s) || e.tags.some((t) => t.toLowerCase().includes(s))
    );
  }
  get filteredTemplates() {
    if (!this.searchQuery) return this.templates;
    const s = this.searchQuery.toLowerCase();
    return this.templates.filter(
      (e) => e.name.toLowerCase().includes(s) || e.description.toLowerCase().includes(s) || e.playbook.toLowerCase().includes(s)
    );
  }
  formatDate(s) {
    const e = new Date(s), i = (/* @__PURE__ */ new Date()).getTime() - e.getTime(), r = Math.floor(i / (1e3 * 60 * 60 * 24));
    return r === 0 ? "Today" : r === 1 ? "Yesterday" : r < 7 ? `${r} days ago` : e.toLocaleDateString();
  }
  getPlaybooksColumns() {
    return [
      { key: "name", label: "Name", type: "link" },
      { key: "path", label: "Path" },
      { key: "hosts", label: "Hosts" },
      { key: "status", label: "Status" },
      { key: "tags", label: "Tags" },
      { key: "lastModified", label: "Last Modified" }
    ];
  }
  getTemplatesColumns() {
    return [
      { key: "name", label: "Name", type: "link" },
      { key: "type", label: "Type" },
      { key: "playbook", label: "Playbook" },
      { key: "inventory", label: "Inventory" },
      { key: "status", label: "Status" },
      { key: "lastUsed", label: "Last Used" }
    ];
  }
  getPlaybookActions(s) {
    return [
      { label: "Run", action: "run" },
      { label: "Edit", action: "edit" },
      { label: "Duplicate", action: "duplicate" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  getTemplateActions(s) {
    return [
      { label: "Run Template", action: "run" },
      { label: "Edit", action: "edit" },
      { label: "Duplicate", action: "duplicate" },
      { label: "Delete", action: "delete", danger: !0 }
    ];
  }
  renderPlaybooks() {
    if (this.loading)
      return D`<loading-state></loading-state>`;
    const s = this.filteredPlaybooks;
    if (s.length === 0)
      return D`
        <empty-state
          .message=${"No playbooks found"}
        ></empty-state>
      `;
    const e = this.getPlaybooksColumns(), t = s.map((i) => ({
      ...i,
      tags: i.tags.join(", "),
      lastModified: this.formatDate(i.lastModified)
    }));
    return D`
      <resource-table
        .columns=${e}
        .data=${t}
        .actions=${this.getPlaybookActions}
        @action=${this.handlePlaybookAction}
      ></resource-table>
    `;
  }
  renderTemplates() {
    if (this.loading)
      return D`<loading-state></loading-state>`;
    const s = this.filteredTemplates;
    if (s.length === 0)
      return D`
        <empty-state
          .message=${"No templates found"}
        ></empty-state>
      `;
    const e = this.getTemplatesColumns(), t = s.map((i) => ({
      ...i,
      lastUsed: this.formatDate(i.lastUsed)
    }));
    return D`
      <resource-table
        .columns=${e}
        .data=${t}
        .actions=${this.getTemplateActions}
        @action=${this.handleTemplateAction}
      ></resource-table>
    `;
  }
  handlePlaybookAction(s) {
    const { action: e, item: t } = s.detail;
    console.log("Playbook action:", e, t);
  }
  handleTemplateAction(s) {
    const { action: e, item: t } = s.detail;
    console.log("Template action:", e, t);
  }
  toggleCreateDropdown(s) {
    s.stopPropagation(), this.showCreateDropdown = !this.showCreateDropdown;
  }
  handleCreateAction(s) {
    this.showCreateDropdown = !1, console.log("Create action:", s);
  }
  render() {
    return D`
      <div class="container">
        <div class="tab-header">
          <a 
            href="/ansible/playbooks"
            class="tab-button ${this.activeTab === "playbooks" ? "active" : ""}" 
            @click="${(s) => this.handleTabClick(s, "playbooks")}"
          >
            Playbooks
          </a>
          <a 
            href="/ansible/templates"
            class="tab-button ${this.activeTab === "templates" ? "active" : ""}" 
            @click="${(s) => this.handleTabClick(s, "templates")}"
          >
            Templates
          </a>
        </div>

        <div class="header">
          <search-input
            .placeholder=${this.activeTab === "playbooks" ? "Search playbooks..." : "Search templates..."}
            @search=${this.handleSearch}
          ></search-input>
          
          ${this.activeTab === "playbooks" ? D`
            <div class="action-menu">
              <button class="btn-create" @click=${(s) => this.toggleCreateDropdown(s)}>
                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                  <path d="M8 2a1 1 0 011 1v4h4a1 1 0 110 2H9v4a1 1 0 11-2 0V9H3a1 1 0 110-2h4V3a1 1 0 011-1z"/>
                </svg>
                Add Playbook
              </button>
              <div class="action-dropdown ${this.showCreateDropdown ? "show" : ""}">
                <button @click=${() => this.handleCreateAction("upload")}>Upload</button>
                <button @click=${() => this.handleCreateAction("template")}>Template</button>
                <button @click=${() => this.handleCreateAction("git")}>Git</button>
                <button @click=${() => this.handleCreateAction("url")}>URL</button>
                <button @click=${() => this.handleCreateAction("galaxy")}>Ansible Galaxy</button>
              </div>
            </div>
          ` : D`
            <button class="btn-create">
              <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                <path d="M8 2a1 1 0 011 1v4h4a1 1 0 110 2H9v4a1 1 0 11-2 0V9H3a1 1 0 110-2h4V3a1 1 0 011-1z"/>
              </svg>
              Create Job Template
            </button>
          `}
        </div>

        <div class="content">
          ${this.activeTab === "playbooks" ? this.renderPlaybooks() : this.renderTemplates()}
        </div>
      </div>
    `;
  }
};
It.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    search-input {
      flex: 1;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .btn-create {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-create:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .tab-header {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.2s;
      text-decoration: none;
      display: inline-block;
    }

    .tab-button:hover {
      color: var(--text-primary);
    }

    .tab-button.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .action-menu {
      position: relative;
      display: inline-block;
    }

    .action-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--vscode-dropdown-background, var(--vscode-editor-background, #1e1e1e));
      border: 1px solid var(--vscode-dropdown-border, var(--vscode-widget-border, #454545));
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 180px;
      z-index: 1000;
      display: none;
      /* Ensure solid background */
      backdrop-filter: none;
    }

    .action-dropdown.show {
      display: block;
    }

    .action-dropdown button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 16px;
      border: none;
      background: none;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }

    .action-dropdown button:hover {
      background-color: var(--vscode-list-hoverBackground, rgba(255, 255, 255, 0.08));
    }

  `;
ds([
  H({ type: String })
], It.prototype, "initialTab", 2);
ds([
  B()
], It.prototype, "loading", 2);
ds([
  B()
], It.prototype, "activeTab", 2);
ds([
  B()
], It.prototype, "searchQuery", 2);
ds([
  B()
], It.prototype, "playbooks", 2);
ds([
  B()
], It.prototype, "templates", 2);
ds([
  B()
], It.prototype, "showCreateDropdown", 2);
It = ds([
  me("ansible-playbooks")
], It);
var H_ = Object.defineProperty, j_ = Object.getOwnPropertyDescriptor, xr = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? j_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && H_(e, t, r), r;
};
let Bs = class extends le {
  constructor() {
    super(...arguments), this.loading = !1, this.searchQuery = "", this.inventoryItems = [], this.typeFilter = "all";
  }
  connectedCallback() {
    super.connectedCallback(), this.loadInventory();
  }
  async loadInventory() {
    this.loading = !0, await new Promise((s) => setTimeout(s, 500)), this.inventoryItems = [
      {
        id: "1",
        name: "web-server-01",
        type: "host",
        description: "Primary web server",
        groups: ["webservers", "production"],
        variables: {
          ansible_host: "192.168.1.10",
          ansible_port: 22,
          ansible_user: "admin"
        },
        enabled: !0,
        lastSync: "2024-01-15T10:30:00Z",
        source: "manual"
      },
      {
        id: "2",
        name: "web-server-02",
        type: "host",
        description: "Secondary web server",
        groups: ["webservers", "production"],
        variables: {
          ansible_host: "192.168.1.11",
          ansible_port: 22,
          ansible_user: "admin"
        },
        enabled: !0,
        lastSync: "2024-01-15T10:30:00Z",
        source: "manual"
      },
      {
        id: "3",
        name: "db-server-01",
        type: "host",
        description: "Primary database server",
        groups: ["databases", "production"],
        variables: {
          ansible_host: "192.168.1.20",
          ansible_port: 22,
          ansible_user: "dbadmin",
          db_port: 5432
        },
        enabled: !0,
        lastSync: "2024-01-15T10:30:00Z",
        source: "manual"
      },
      {
        id: "4",
        name: "webservers",
        type: "group",
        description: "All web servers",
        hosts: 2,
        variables: {
          http_port: 80,
          https_port: 443,
          max_connections: 1e3
        },
        enabled: !0,
        source: "manual"
      },
      {
        id: "5",
        name: "databases",
        type: "group",
        description: "All database servers",
        hosts: 1,
        variables: {
          backup_schedule: "0 2 * * *",
          replication_enabled: !0
        },
        enabled: !0,
        source: "manual"
      },
      {
        id: "6",
        name: "production",
        type: "group",
        description: "Production environment",
        hosts: 3,
        variables: {
          environment: "production",
          monitoring_enabled: !0,
          alert_email: "ops@example.com"
        },
        enabled: !0,
        source: "manual"
      },
      {
        id: "7",
        name: "dev-server-01",
        type: "host",
        description: "Development server",
        groups: ["development"],
        variables: {
          ansible_host: "10.0.1.50",
          ansible_port: 22,
          ansible_user: "developer"
        },
        enabled: !1,
        lastSync: "2024-01-14T15:45:00Z",
        source: "dynamic"
      },
      {
        id: "8",
        name: "monitoring-server",
        type: "host",
        description: "Monitoring and alerting server",
        groups: ["monitoring", "infrastructure"],
        variables: {
          ansible_host: "192.168.1.100",
          prometheus_port: 9090,
          grafana_port: 3e3
        },
        enabled: !0,
        lastSync: "2024-01-15T10:30:00Z",
        source: "scm"
      }
    ], this.loading = !1;
  }
  handleSearch(s) {
    this.searchQuery = s.detail.value;
  }
  handleTypeFilter(s) {
    this.typeFilter = s;
  }
  get filteredItems() {
    let s = [...this.inventoryItems];
    if (this.typeFilter !== "all" && (s = s.filter((e) => e.type === this.typeFilter)), this.searchQuery) {
      const e = this.searchQuery.toLowerCase();
      s = s.filter(
        (t) => {
          var i;
          return t.name.toLowerCase().includes(e) || ((i = t.description) == null ? void 0 : i.toLowerCase().includes(e)) || t.groups && t.groups.some((r) => r.toLowerCase().includes(e));
        }
      );
    }
    return s;
  }
  getColumns() {
    return [
      { key: "nameDisplay", label: "Name", type: "link" },
      { key: "typeDisplay", label: "Type", width: "100px" },
      { key: "groupsDisplay", label: "Groups / Hosts", width: "200px" },
      { key: "variablesDisplay", label: "Variables", width: "120px" },
      { key: "sourceDisplay", label: "Source", width: "100px" },
      { key: "lastSyncDisplay", label: "Last Sync", width: "150px" }
    ];
  }
  getInventoryActions(s) {
    return [
      { action: "edit", label: "Edit", icon: "" },
      { action: "duplicate", label: "Duplicate", icon: "" },
      { action: "variables", label: "Manage Variables", icon: "" },
      { action: "disable", label: s.enabled ? "Disable" : "Enable", icon: "" },
      { action: "delete", label: "Delete", icon: "", danger: !0 }
    ];
  }
  prepareTableData() {
    return this.filteredItems.map((s) => ({
      _original: s,
      // Store original item for actions
      nameDisplay: `${s.enabled ? "" : ""} ${s.name}`,
      typeDisplay: `${s.type === "host" ? "" : ""} ${s.type}`,
      groupsDisplay: s.type === "host" && s.groups ? s.groups.join(", ") : s.type === "group" && s.hosts !== void 0 ? `${s.hosts} hosts` : "-",
      variablesDisplay: s.variables ? `${Object.keys(s.variables).length} vars` : "-",
      sourceDisplay: s.source ? `${s.source === "manual" ? "" : s.source === "dynamic" ? "" : ""} ${s.source}` : "-",
      lastSyncDisplay: s.lastSync ? new Date(s.lastSync).toLocaleString() : "-"
    }));
  }
  handleCellClick(s) {
    const { item: e, column: t } = s.detail;
    t.key === "nameDisplay" && e._original && console.log("View details for:", e._original);
  }
  handleAction(s, e) {
    switch (console.log("Action:", s, "Item:", e), s) {
      case "edit":
        break;
      case "duplicate":
        break;
      case "variables":
        break;
      case "disable":
        e.enabled = !e.enabled, this.requestUpdate();
        break;
      case "delete":
        confirm(`Are you sure you want to delete "${e.name}"?`) && (this.inventoryItems = this.inventoryItems.filter((t) => t.id !== e.id));
        break;
    }
  }
  handleAddHost() {
    console.log("Add new host");
  }
  handleAddGroup() {
    console.log("Add new group");
  }
  handleSync() {
    console.log("Sync inventory"), this.loadInventory();
  }
  render() {
    return D`
      <div class="container">
        <div class="header">
          <h2 class="title">Inventory</h2>
        </div>
        
        <div class="controls">
          <div class="controls-left">
            <search-input
              placeholder="Search inventory..."
              @search=${this.handleSearch}
            ></search-input>
            
            <div class="filter-buttons">
              <button 
                class="filter-btn ${this.typeFilter === "all" ? "active" : ""}"
                @click=${() => this.handleTypeFilter("all")}
              >
                All
              </button>
              <button 
                class="filter-btn ${this.typeFilter === "host" ? "active" : ""}"
                @click=${() => this.handleTypeFilter("host")}
              >
                Hosts
              </button>
              <button 
                class="filter-btn ${this.typeFilter === "group" ? "active" : ""}"
                @click=${() => this.handleTypeFilter("group")}
              >
                Groups
              </button>
            </div>
          </div>
          
          <div class="controls-right">
            <button class="btn-secondary" @click=${this.handleSync}>
               Sync
            </button>
            <button class="btn-primary" @click=${this.handleAddHost}>
               Add Host
            </button>
            <button class="btn-primary" @click=${this.handleAddGroup}>
               Add Group
            </button>
          </div>
        </div>
        
        <div class="content">
          ${this.loading ? D`
            <loading-state message="Loading inventory..."></loading-state>
          ` : this.filteredItems.length === 0 ? D`
            <empty-state
              icon=""
              title="No inventory items found"
              description="${this.searchQuery ? "Try adjusting your search or filters" : "Add hosts or groups to get started"}"
            ></empty-state>
          ` : D`
            <resource-table
              .columns=${this.getColumns()}
              .data=${this.prepareTableData()}
              .getActions=${(s) => this.getInventoryActions(s._original)}
              @action=${(s) => this.handleAction(s.detail.action, s.detail.item._original)}
              @cell-click=${(s) => this.handleCellClick(s)}
            ></resource-table>
          `}
        </div>
      </div>
    `;
  }
};
Bs.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--vscode-panel-border);
    }

    .title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-top: 1rem;
    }

    .controls-left {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex: 1;
    }

    .controls-right {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-primary:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    .btn-secondary {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: 1px solid var(--vscode-button-border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .btn-secondary:hover {
      background: var(--vscode-button-secondaryHoverBackground);
    }

    search-input {
      flex: 1;
      max-width: 400px;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .filter-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 6px 12px;
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: 1px solid var(--vscode-button-border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .filter-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground);
    }

    .filter-btn.active {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border-color: var(--vscode-focusBorder);
    }

    .type-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    .type-badge.host {
      background: rgba(30, 136, 229, 0.2);
      color: #1e88e5;
    }

    .type-badge.group {
      background: rgba(156, 39, 176, 0.2);
      color: #9c27b0;
    }

    .variables-count {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      background: var(--vscode-badge-background);
      color: var(--vscode-badge-foreground);
      border-radius: 10px;
      font-size: 11px;
    }

    .groups-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .group-tag {
      display: inline-flex;
      padding: 2px 6px;
      background: var(--vscode-textBlockQuote-background);
      border: 1px solid var(--vscode-textBlockQuote-border);
      border-radius: 3px;
      font-size: 11px;
      color: var(--vscode-textBlockQuote-foreground);
    }

    .source-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 500;
    }

    .source-badge.manual {
      background: rgba(117, 117, 117, 0.2);
      color: #757575;
    }

    .source-badge.dynamic {
      background: rgba(255, 167, 38, 0.2);
      color: #ffa726;
    }

    .source-badge.scm {
      background: rgba(102, 187, 106, 0.2);
      color: #66bb6a;
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 4px;
    }

    .status-indicator.enabled {
      background: #4caf50;
    }

    .status-indicator.disabled {
      background: #9e9e9e;
    }
  `;
xr([
  B()
], Bs.prototype, "loading", 2);
xr([
  B()
], Bs.prototype, "searchQuery", 2);
xr([
  B()
], Bs.prototype, "inventoryItems", 2);
xr([
  B()
], Bs.prototype, "typeFilter", 2);
Bs = xr([
  me("ansible-inventory")
], Bs);
var U_ = Object.defineProperty, W_ = Object.getOwnPropertyDescriptor, kr = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? W_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && U_(e, t, r), r;
};
let Ns = class extends le {
  constructor() {
    super(...arguments), this.loading = !1, this.searchQuery = "", this.executions = [], this.statusFilter = "all";
  }
  connectedCallback() {
    super.connectedCallback(), this.loadData();
  }
  async loadData() {
    this.loading = !0, await new Promise((s) => setTimeout(s, 500)), this.executions = [
      {
        id: "exec-001",
        jobId: "job-001",
        name: "Deploy Web Application",
        type: "template",
        playbook: "deploy-webapp.yml",
        status: "successful",
        startTime: "2024-01-15T14:30:00Z",
        endTime: "2024-01-15T14:35:42Z",
        duration: 342,
        executedBy: "admin",
        hosts: ["web-server-01", "web-server-02", "web-server-03"],
        hostsSucceeded: 3,
        hostsFailed: 0,
        hostsUnreachable: 0,
        hostsSkipped: 0
      },
      {
        id: "exec-002",
        jobId: "job-002",
        name: "System Update",
        type: "playbook",
        playbook: "update-system.yml",
        status: "running",
        startTime: "2024-01-15T15:00:00Z",
        executedBy: "operator",
        hosts: ["app-server-01", "app-server-02", "db-server-01", "db-server-02"],
        hostsSucceeded: 2,
        hostsFailed: 0,
        hostsUnreachable: 0,
        hostsSkipped: 0,
        message: "Updating packages on db-server-01..."
      },
      {
        id: "exec-003",
        jobId: "job-003",
        name: "Database Backup",
        type: "template",
        playbook: "backup-databases.yml",
        status: "failed",
        startTime: "2024-01-15T03:00:00Z",
        endTime: "2024-01-15T03:15:23Z",
        duration: 923,
        executedBy: "system",
        hosts: ["db-server-01", "db-server-02"],
        hostsSucceeded: 1,
        hostsFailed: 1,
        hostsUnreachable: 0,
        hostsSkipped: 0,
        message: "Failed to connect to db-server-02"
      },
      {
        id: "exec-004",
        jobId: "job-004",
        name: "Security Patches",
        type: "playbook",
        playbook: "security-updates.yml",
        status: "successful",
        startTime: "2024-01-14T22:00:00Z",
        endTime: "2024-01-14T22:45:30Z",
        duration: 2730,
        executedBy: "security-team",
        hosts: ["web-server-01", "web-server-02", "app-server-01", "app-server-02"],
        hostsSucceeded: 4,
        hostsFailed: 0,
        hostsUnreachable: 0,
        hostsSkipped: 0
      },
      {
        id: "exec-005",
        jobId: "job-005",
        name: "Configuration Drift Check",
        type: "template",
        playbook: "check-config.yml",
        status: "canceled",
        startTime: "2024-01-14T18:30:00Z",
        endTime: "2024-01-14T18:31:15Z",
        duration: 75,
        executedBy: "admin",
        hosts: ["web-server-01", "web-server-02"],
        hostsSucceeded: 0,
        hostsFailed: 0,
        hostsUnreachable: 0,
        hostsSkipped: 2,
        message: "Canceled by user"
      },
      {
        id: "exec-006",
        jobId: "job-006",
        name: "Deploy Monitoring Agent",
        type: "playbook",
        playbook: "deploy-monitoring.yml",
        status: "pending",
        startTime: "2024-01-15T16:00:00Z",
        executedBy: "monitoring-team",
        hosts: ["new-server-01", "new-server-02"],
        hostsSucceeded: 0,
        hostsFailed: 0,
        hostsUnreachable: 0,
        hostsSkipped: 0,
        message: "Waiting in queue..."
      }
    ], this.loading = !1;
  }
  handleSearch(s) {
    this.searchQuery = s.detail.value;
  }
  handleStatusFilter(s) {
    this.statusFilter = s;
  }
  get filteredExecutions() {
    let s = this.executions;
    if (this.statusFilter !== "all" && (s = s.filter((e) => e.status === this.statusFilter)), this.searchQuery) {
      const e = this.searchQuery.toLowerCase();
      s = s.filter(
        (t) => t.name.toLowerCase().includes(e) || t.playbook.toLowerCase().includes(e) || t.executedBy.toLowerCase().includes(e) || t.status.toLowerCase().includes(e)
      );
    }
    return s;
  }
  formatDuration(s) {
    if (!s) return "-";
    const e = Math.floor(s / 60), t = s % 60;
    return e > 0 ? `${e}m ${t}s` : `${t}s`;
  }
  formatDate(s) {
    const e = new Date(s), i = (/* @__PURE__ */ new Date()).getTime() - e.getTime(), r = Math.floor(i / (1e3 * 60 * 60));
    if (r === 0) {
      const n = Math.floor(i / 6e4);
      return n === 0 ? "Just now" : `${n} min ago`;
    }
    return r < 24 ? `${r} hours ago` : e.toLocaleString();
  }
  getExecutionColumns() {
    return [
      { key: "status", label: "Status", width: "100px" },
      { key: "name", label: "Job Name", type: "link" },
      { key: "playbook", label: "Playbook" },
      { key: "hosts", label: "Hosts" },
      { key: "executedBy", label: "Executed By" },
      { key: "startTime", label: "Started" },
      { key: "duration", label: "Duration" }
    ];
  }
  getExecutionActions(s) {
    const e = [
      { label: "View Output", action: "logs" },
      { label: "View Details", action: "details" }
    ];
    return s.status === "running" ? e.push({ label: "Cancel", action: "cancel", danger: !0 }) : (s.status === "failed" || s.status === "canceled") && e.push({ label: "Retry", action: "retry" }), e;
  }
  renderStatusBadge(s) {
    let e = "";
    switch (s) {
      case "running":
        e = "";
        break;
      case "successful":
        e = "";
        break;
      case "failed":
        e = "";
        break;
      case "canceled":
        e = "";
        break;
      case "pending":
        e = "";
        break;
    }
    return D`
      <span class="status-badge ${s}">
        ${e} ${s.charAt(0).toUpperCase() + s.slice(1)}
      </span>
    `;
  }
  renderHostStats(s) {
    return D`
      <div class="host-stats">
        ${s.hostsSucceeded > 0 ? D`
          <span class="stat-item">
            <span class="stat-icon success"></span>
            ${s.hostsSucceeded}
          </span>
        ` : ""}
        ${s.hostsFailed > 0 ? D`
          <span class="stat-item">
            <span class="stat-icon failed"></span>
            ${s.hostsFailed}
          </span>
        ` : ""}
        ${s.hostsUnreachable > 0 ? D`
          <span class="stat-item">
            <span class="stat-icon unreachable"></span>
            ${s.hostsUnreachable}
          </span>
        ` : ""}
        ${s.hostsSkipped > 0 ? D`
          <span class="stat-item">
            <span class="stat-icon skipped"></span>
            ${s.hostsSkipped}
          </span>
        ` : ""}
      </div>
    `;
  }
  handleExecutionAction(s) {
    const { action: e, item: t } = s.detail;
    switch (console.log("Execution action:", e, t), e) {
      case "logs":
        console.log("Show logs for:", t);
        break;
    }
  }
  handleRefresh() {
    this.loadData();
  }
  handleRunClick() {
    console.log("Run button clicked");
  }
  renderStatsSummary() {
    const s = {
      total: this.executions.length,
      running: this.executions.filter((e) => e.status === "running").length,
      successful: this.executions.filter((e) => e.status === "successful").length,
      failed: this.executions.filter((e) => e.status === "failed").length
    };
    return D`
      <div class="stats-summary">
        <div class="stat-card">
          <div class="stat-value">${s.total}</div>
          <div class="stat-label">Total Executions</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" style="color: #1e88e5;">${s.running}</div>
          <div class="stat-label">Running</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" style="color: #43a047;">${s.successful}</div>
          <div class="stat-label">Successful</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" style="color: #e53935;">${s.failed}</div>
          <div class="stat-label">Failed</div>
        </div>
      </div>
    `;
  }
  render() {
    if (this.loading)
      return D`<loading-state></loading-state>`;
    const s = this.getExecutionColumns(), e = this.filteredExecutions.map((t) => ({
      ...t,
      status: this.renderStatusBadge(t.status),
      hosts: this.renderHostStats(t),
      startTime: this.formatDate(t.startTime),
      duration: this.formatDuration(t.duration)
    }));
    return D`
      <div class="container">
        <div class="header">
          <h1 class="title">Job Executions</h1>
        </div>

        ${this.renderStatsSummary()}

        <div class="controls">
          <div class="controls-left">
            <search-input
              .placeholder=${"Search executions..."}
              @search=${this.handleSearch}
            ></search-input>
            
            <div class="filter-buttons">
              <button 
                class="filter-btn ${this.statusFilter === "all" ? "active" : ""}"
                @click=${() => this.handleStatusFilter("all")}
              >
                All
              </button>
              <button 
                class="filter-btn ${this.statusFilter === "running" ? "active" : ""}"
                @click=${() => this.handleStatusFilter("running")}
              >
                Running
              </button>
              <button 
                class="filter-btn ${this.statusFilter === "successful" ? "active" : ""}"
                @click=${() => this.handleStatusFilter("successful")}
              >
                Successful
              </button>
              <button 
                class="filter-btn ${this.statusFilter === "failed" ? "active" : ""}"
                @click=${() => this.handleStatusFilter("failed")}
              >
                Failed
              </button>
            </div>
          </div>

          <div class="controls-right">
            <button class="refresh-btn" @click=${this.handleRefresh}>
              <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                <path d="M13.65 2.35a8 8 0 10.7 11.3l-1.42-1.42a6 6 0 11-.53-8.46L11 5.17V2h3.17l-1.52 1.52a7.92 7.92 0 011 .83z"/>
              </svg>
              Refresh
            </button>
            
            <button class="btn-run" @click=${this.handleRunClick}>
              <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                <path d="M4 2a1 1 0 000 2v8a1 1 0 102 0V4a1 1 0 100-2zM12.441 7.059A1 1 0 0011 8v4a1 1 0 102 0V8a1 1 0 00-1.559-.941l-5.882-3.882A1 1 0 004 4v8a1 1 0 001.559.941l5.882-3.882z"/>
              </svg>
              Run
            </button>
          </div>
        </div>

        <div class="content">
          ${e.length === 0 ? D`
            <empty-state
              .message=${"No executions found"}
            ></empty-state>
          ` : D`
            <resource-table
              .columns=${s}
              .data=${e}
              .actions=${this.getExecutionActions.bind(this)}
              @action=${this.handleExecutionAction}
            ></resource-table>
          `}
        </div>
      </div>
    `;
  }
};
Ns.styles = re`
    :host {
      display: block;
      height: 100%;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 1rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--vscode-panel-border);
    }

    .title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-top: 1rem;
    }

    .controls-left {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex: 1;
    }

    .controls-right {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-run {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--vscode-button-background, #007acc);
      color: var(--vscode-button-foreground, white);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-run:hover {
      background: var(--vscode-button-hoverBackground, #005a9e);
    }

    search-input {
      flex: 1;
      max-width: 400px;
    }

    .content {
      flex: 1;
      overflow-y: auto;
    }

    .filter-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 6px 12px;
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: 1px solid var(--vscode-button-border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .filter-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground);
    }

    .filter-btn.active {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border-color: var(--vscode-focusBorder);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    .status-badge.running {
      background: rgba(30, 136, 229, 0.2);
      color: #1e88e5;
    }

    .status-badge.successful {
      background: rgba(67, 160, 71, 0.2);
      color: #43a047;
    }

    .status-badge.failed {
      background: rgba(229, 57, 53, 0.2);
      color: #e53935;
    }

    .status-badge.canceled {
      background: rgba(117, 117, 117, 0.2);
      color: #757575;
    }

    .status-badge.pending {
      background: rgba(255, 167, 38, 0.2);
      color: #ffa726;
    }

    .host-stats {
      display: flex;
      gap: 12px;
      font-size: 12px;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .stat-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .stat-icon.success {
      background: #43a047;
    }

    .stat-icon.failed {
      background: #e53935;
    }

    .stat-icon.unreachable {
      background: #ff9800;
    }

    .stat-icon.skipped {
      background: #9e9e9e;
    }

    .refresh-btn {
      padding: 6px 12px;
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .refresh-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground);
    }

    .stats-summary {
      display: flex;
      gap: 2rem;
      padding: 1rem;
      background: var(--vscode-editor-background);
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    .stat-card {
      flex: 1;
      text-align: center;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .stat-label {
      font-size: 0.875rem;
      color: var(--vscode-descriptionForeground);
      margin-top: 0.25rem;
    }
  `;
kr([
  B()
], Ns.prototype, "loading", 2);
kr([
  B()
], Ns.prototype, "searchQuery", 2);
kr([
  B()
], Ns.prototype, "executions", 2);
kr([
  B()
], Ns.prototype, "statusFilter", 2);
Ns = kr([
  me("ansible-executions")
], Ns);
var V_ = Object.defineProperty, q_ = Object.getOwnPropertyDescriptor, Oa = (s, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? q_(e, t) : e, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = (i ? o(e, t, r) : o(r)) || r);
  return i && r && V_(e, t, r), r;
};
let dr = class extends le {
  constructor() {
    super(...arguments), this.subRoute = null, this.activeTab = "playbooks", this.handleLocationChange = () => {
      this.updateActiveTab();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.updateActiveTab(), window.addEventListener("popstate", this.handleLocationChange);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("popstate", this.handleLocationChange);
  }
  updated(s) {
    s.has("subRoute") && this.updateActiveTab();
  }
  updateActiveTab() {
    if (this.subRoute)
      this.subRoute === "inventory" ? this.activeTab = "inventory" : this.subRoute === "executions" ? this.activeTab = "executions" : this.subRoute === "playbooks" ? this.activeTab = "playbooks" : this.subRoute === "templates" && (this.activeTab = "templates");
    else {
      const s = window.location.pathname;
      s.includes("/ansible/templates") ? this.activeTab = "templates" : s.includes("/ansible/inventory") ? this.activeTab = "inventory" : s.includes("/ansible/executions") ? this.activeTab = "executions" : this.activeTab = "playbooks";
    }
  }
  render() {
    return D`
      <div class="ansible-content">
        <div class="tab-content">
          ${this.activeTab === "playbooks" || this.activeTab === "templates" ? D`
            <ansible-playbooks .initialTab=${this.activeTab}></ansible-playbooks>
          ` : ""}
          ${this.activeTab === "inventory" ? D`
            <ansible-inventory></ansible-inventory>
          ` : ""}
          ${this.activeTab === "executions" ? D`
            <ansible-executions></ansible-executions>
          ` : ""}
        </div>
      </div>
    `;
  }
};
dr.styles = re`
    :host {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    .ansible-content {
      flex: 1;
      overflow: auto;
      display: flex;
      flex-direction: column;
    }

    .tab-content {
      flex: 1;
      overflow: auto;
    }
  `;
Oa([
  H({ type: String })
], dr.prototype, "subRoute", 2);
Oa([
  B()
], dr.prototype, "activeTab", 2);
dr = Oa([
  me("ansible-tab")
], dr);
var K_ = Object.defineProperty, Pa = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && K_(e, t, r), r;
};
const qa = class qa extends Fs {
  constructor() {
    super(...arguments), this.collapsed = !1, this.activeItemId = "dashboard", this.expandedItemsArray = ["network", "storage"], this.navigationItems = [
      {
        id: "dashboard",
        label: "nav.dashboard",
        icon: "dashboard",
        route: "dashboard"
      },
      {
        id: "network",
        label: "nav.network",
        icon: "network",
        route: "network",
        children: [
          {
            id: "network-interfaces",
            label: "network.interfaces",
            icon: "interfaces",
            route: "network/interfaces"
          },
          {
            id: "network-bridges",
            label: "network.bridges",
            icon: "bonding",
            route: "network/bridges"
          },
          {
            id: "network-bonds",
            label: "network.bonds",
            icon: "bonding",
            route: "network/bonds"
          },
          {
            id: "network-vlans",
            label: "network.vlans",
            icon: "vlans",
            route: "network/vlans"
          }
        ]
      },
      {
        id: "storage",
        label: "nav.storage",
        icon: "storage",
        route: "storage",
        children: [
          {
            id: "storage-disks",
            label: "storage.disks.title",
            icon: "disks",
            route: "storage/disks"
          },
          {
            id: "storage-lvm",
            label: "storage.lvm.title",
            icon: "lvm",
            route: "storage/lvm"
          },
          {
            id: "storage-raid",
            label: "storage.raid.title",
            icon: "raid",
            route: "storage/raid"
          },
          {
            id: "storage-iscsi",
            label: "storage.iscsi.title",
            icon: "storage",
            route: "storage/iscsi"
          },
          {
            id: "storage-multipath",
            label: "storage.multipath.title",
            icon: "storage",
            route: "storage/multipath"
          },
          {
            id: "storage-btrfs",
            label: "storage.btrfs.title",
            icon: "storage",
            route: "storage/btrfs"
          }
        ]
      },
      {
        id: "containers",
        label: "nav.containers.title",
        icon: "containers",
        route: "containers",
        children: [
          {
            id: "containers-cri",
            label: "nav.containers.cri",
            icon: "containers",
            route: "containers/cri"
          },
          {
            id: "containers-docker",
            label: "nav.containers.docker",
            icon: "docker",
            route: "docker"
          }
        ]
      },
      {
        id: "kubernetes",
        label: "nav.kubernetes",
        icon: "kubernetes",
        route: "kubernetes",
        children: [
          {
            id: "kubernetes-workloads",
            label: "kubernetes.workloads",
            icon: "workload",
            route: "kubernetes/workloads"
          },
          {
            id: "kubernetes-networks",
            label: "kubernetes.networks",
            icon: "k8s-networks",
            route: "kubernetes/networks"
          },
          {
            id: "kubernetes-storage",
            label: "kubernetes.storages",
            icon: "k8s-storage",
            route: "kubernetes/storage"
          },
          {
            id: "kubernetes-configurations",
            label: "kubernetes.configurations",
            icon: "configurations",
            route: "kubernetes/configurations"
          },
          {
            id: "kubernetes-nodes",
            label: "kubernetes.nodes",
            icon: "nodes",
            route: "kubernetes/nodes"
          },
          {
            id: "kubernetes-crds",
            label: "kubernetes.crds",
            icon: "crds",
            route: "kubernetes/crds"
          },
          {
            id: "kubernetes-helm",
            label: "kubernetes.helms",
            icon: "helm",
            route: "kubernetes/helm"
          }
        ]
      },
      {
        id: "ansible",
        label: "nav.ansible",
        icon: "ansible",
        route: "ansible",
        children: [
          {
            id: "ansible-playbooks",
            label: "ansible.playbooks",
            icon: "playbooks",
            route: "ansible/playbooks"
          },
          {
            id: "ansible-inventory",
            label: "ansible.inventory",
            icon: "inventory",
            route: "ansible/inventory"
          },
          {
            id: "ansible-executions",
            label: "ansible.executions",
            icon: "executions",
            route: "ansible/executions"
          }
        ]
      },
      {
        id: "logs",
        label: "nav.logs",
        icon: "logs",
        route: "logs"
      },
      {
        id: "users",
        label: "nav.users",
        icon: "users",
        route: "users"
      },
      {
        id: "terminal",
        label: "nav.terminal",
        icon: "terminal",
        route: "terminal"
      }
    ], this.handlePopState = () => {
      const e = window.location.pathname.slice(1);
      if (e) {
        const t = this.findNavItemByRoute(e);
        t && (this.activeItemId = t.id, this.requestUpdate());
      }
    };
  }
  get expandedItems() {
    return new Set(this.expandedItemsArray);
  }
  set expandedItems(e) {
    this.expandedItemsArray = Array.from(e);
  }
  handleItemClick(e, t) {
    if (t.stopPropagation(), e.children) {
      const i = new Set(this.expandedItemsArray);
      i.has(e.id) ? i.delete(e.id) : i.add(e.id), this.expandedItemsArray = Array.from(i);
    } else if (e.route) {
      this.activeItemId = e.id;
      const [i, r] = e.route.split("?"), n = r ? new URLSearchParams(r) : null, o = i === "dashboard" ? "/" : `/${e.route}`;
      window.history.pushState({ route: i, queryParams: n }, "", o), this.dispatchEvent(new CustomEvent("navigate", {
        detail: { route: i, item: e, queryParams: n },
        bubbles: !0,
        composed: !0
      })), this.requestUpdate();
    }
  }
  handleKeyDown(e, t) {
    t.key === "Enter" || t.key === " " ? (t.preventDefault(), this.handleItemClick(e, t)) : t.key === "ArrowRight" && e.children ? (t.preventDefault(), this.expandedItemsArray.includes(e.id) || (this.expandedItemsArray = [...this.expandedItemsArray, e.id])) : t.key === "ArrowLeft" && e.children && (t.preventDefault(), this.expandedItemsArray.includes(e.id) && (this.expandedItemsArray = this.expandedItemsArray.filter((i) => i !== e.id)));
  }
  renderNavItem(e) {
    const t = e.children && e.children.length > 0, i = this.expandedItems.has(e.id), r = this.isItemActive(e);
    return D`
      <li>
        <div
          class="tree-item ${r ? "active" : ""}"
          @click=${(n) => this.handleItemClick(e, n)}
          @keydown=${(n) => this.handleKeyDown(e, n)}
          title=${this.collapsed ? L(e.label) : ""}
          tabindex="0"
          role="treeitem"
          aria-expanded=${t ? i : void 0}
          aria-selected=${r}
        >
          ${t ? D`
            <span class="tree-item-arrow ${i ? "expanded" : ""}">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path d="M6 4l4 4-4 4z"/>
              </svg>
            </span>
          ` : D`<span class="tree-item-arrow"></span>`}
          <span class="tree-item-icon icon-${e.icon}"></span>
          <span class="tree-item-label">${L(e.label)}</span>
        </div>
        ${t && i && !this.collapsed ? D`
          <ul class="tree-children">
            ${e.children.map((n) => this.renderNavItem(n))}
          </ul>
        ` : ""}
      </li>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.expandedItemsArray.includes("containers") || (this.expandedItemsArray = [...this.expandedItemsArray, "containers"]), this.expandedItemsArray.includes("kubernetes") || (this.expandedItemsArray = [...this.expandedItemsArray, "kubernetes"]), this.expandedItemsArray.includes("ansible") || (this.expandedItemsArray = [...this.expandedItemsArray, "ansible"]);
    const e = window.location.pathname.slice(1);
    if (!e || e === "")
      this.activeItemId = "dashboard";
    else {
      const t = this.findNavItemByRoute(e);
      t ? this.activeItemId = t.id : this.activeItemId = "";
    }
    window.addEventListener("popstate", this.handlePopState);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("popstate", this.handlePopState);
  }
  findNavItemByRoute(e) {
    const t = (i) => {
      for (const r of i) {
        if (r.route === e || r.route && e.startsWith(r.route + "/"))
          return r;
        if (r.children) {
          const n = t(r.children);
          if (n) return n;
        }
      }
      return null;
    };
    return t(this.navigationItems);
  }
  isItemActive(e) {
    return e.children && e.children.length > 0 ? !1 : this.activeItemId === e.id;
  }
  render() {
    return D`
      <ul class="tree" role="tree">
        ${this.navigationItems.map((e) => this.renderNavItem(e))}
      </ul>
    `;
  }
};
qa.styles = re`
    :host {
      display: block;
      height: 100%;
      background-color: var(--vscode-sidebar);
      color: var(--vscode-text);
      border-right: 1px solid var(--vscode-border);
      overflow-y: auto;
      user-select: none;
    }

    .tree {
      padding: 20px 0 0 0;
      margin: 0;
      list-style: none;
    }

    .tree-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      cursor: pointer;
      position: relative;
      font-size: 13px;
      transition: all 0.15s ease;
      border-left: 3px solid transparent;
    }

    .tree-item:hover {
      background-color: var(--vscode-sidebar-hover);
      border-left-color: var(--vscode-text-dim);
    }

    .tree-item.active {
      background-color: var(--vscode-sidebar-active);
      border-left-color: var(--vscode-sidebar-active-border);
      color: var(--vscode-accent);
    }

    .tree-item.active .tree-item-icon {
      color: var(--vscode-accent);
    }

    .tree-item-icon {
      width: 16px;
      height: 16px;
      margin-right: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .tree-item-label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-item-arrow {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s;
    }

    .tree-item-arrow.expanded {
      transform: rotate(90deg);
    }

    .tree-children {
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .tree-children .tree-item {
      padding-left: 28px;
    }

    .tree-children .tree-children .tree-item {
      padding-left: 44px;
    }

    /* Icons */
    .icon-system::before { content: ''; }
    .icon-dashboard::before { content: ''; }
    .icon-logs::before { content: ''; }
    .icon-terminal::before { content: ''; }
    .icon-network::before { content: ''; }
    .icon-interfaces::before { content: ''; }
    .icon-bonding::before { content: ''; }
    .icon-vlans::before { content: ''; }
    .icon-storage::before { content: ''; }
    .icon-disks::before { content: ''; }
    .icon-lvm::before { content: ''; }
    .icon-raid::before { content: ''; }
    .icon-containers::before { content: ''; }
    .icon-docker::before { content: ''; }
    .icon-images::before { content: ''; }
    .icon-kubernetes::before { content: ''; }
    .icon-workload::before { content: ''; }
    .icon-k8s-networks::before { content: ''; }
    .icon-k8s-storage::before { content: ''; }
    .icon-configurations::before { content: ''; }
    .icon-nodes::before { content: ''; }
    .icon-crds::before { content: ''; }
    .icon-helm::before { content: ''; }
    .icon-users::before { content: ''; }
    .icon-ansible::before { content: ''; }
    .icon-playbooks::before { content: ''; }
    .icon-inventory::before { content: ''; }
    .icon-executions::before { content: ''; }

    :host([collapsed]) .tree-item-label,
    :host([collapsed]) .tree-item-arrow,
    :host([collapsed]) .tree-children {
      display: none;
    }

    :host([collapsed]) .tree-item {
      padding: 8px;
      justify-content: center;
    }

    :host([collapsed]) .tree-item-icon {
      margin-right: 0;
    }

    /* Focus styles for keyboard navigation */
    .tree-item:focus-visible {
      outline: 2px solid var(--vscode-accent);
      outline-offset: -2px;
    }

    /* Subtle animation on icon when hovering */
    .tree-item:hover .tree-item-icon {
      transform: translateX(2px);
      transition: transform 0.15s ease;
    }

    /* Child items styling */
    .tree-children .tree-item {
      font-size: 12px;
      opacity: 0.9;
    }

    .tree-children .tree-item.active {
      opacity: 1;
    }
  `;
let pi = qa;
Pa([
  H({ type: Boolean })
], pi.prototype, "collapsed");
Pa([
  H({ type: String })
], pi.prototype, "activeItemId");
Pa([
  H({ type: Array })
], pi.prototype, "expandedItemsArray");
customElements.define("sidebar-tree", pi);
var Q_ = Object.defineProperty, Vs = (s, e, t, i) => {
  for (var r = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (r = o(e, t, r) || r);
  return r && Q_(e, t, r), r;
};
const Ka = class Ka extends le {
  constructor() {
    super(...arguments), this.isAuthenticated = !1, this.activeView = "dashboard", this.currentTheme = Ya.getTheme(), this.currentLocale = Mi.getLocale(), this.languageMenuOpen = !1, this.sidebarCollapsed = !1, this.subRoute = null, this.handleAuthLogin = () => {
      this.isAuthenticated = !0;
    }, this.handleAuthLogout = () => {
      this.isAuthenticated = !1;
    }, this.handleLoginSuccess = () => {
      this.isAuthenticated = !0;
    }, this.handleThemeChange = (e) => {
      this.currentTheme = e.detail.theme;
    }, this.handleDocumentClick = (e) => {
      e.target.closest(".language-selector") || (this.languageMenuOpen = !1);
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.isAuthenticated = ts.isAuthenticated();
    const e = Mi.onChange(() => {
      this.currentLocale = Mi.getLocale(), this.requestUpdate();
    });
    this._unsubscribeI18n = e;
    const t = window.location.pathname.slice(1);
    if (!t || t === "")
      this.activeView = "dashboard", window.history.replaceState({ route: "dashboard" }, "", "/");
    else {
      const [i, ...r] = t.split("/");
      this.subRoute = r.length > 0 ? r.join("/") : null, i && this.isValidRoute(i) ? this.activeView = i : i && (this.activeView = t);
    }
    window.addEventListener("popstate", (i) => {
      if (i.state && i.state.route) {
        const [r, ...n] = i.state.route.split("/");
        this.activeView = r, this.subRoute = n.length > 0 ? n.join("/") : null;
      } else {
        const r = window.location.pathname.slice(1);
        if (!r || r === "")
          this.activeView = "dashboard", this.subRoute = null;
        else {
          const [n, ...o] = r.split("/");
          this.subRoute = o.length > 0 ? o.join("/") : null, this.activeView = n && this.isValidRoute(n) ? n : r;
        }
      }
    }), window.addEventListener("auth:login", this.handleAuthLogin), window.addEventListener("auth:logout", this.handleAuthLogout), this.addEventListener("login-success", this.handleLoginSuccess), window.addEventListener("theme-changed", this.handleThemeChange), document.addEventListener("click", this.handleDocumentClick);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._unsubscribeI18n && this._unsubscribeI18n(), document.removeEventListener("click", this.handleDocumentClick), window.removeEventListener("theme-changed", this.handleThemeChange), window.removeEventListener("auth:login", this.handleAuthLogin), window.removeEventListener("auth:logout", this.handleAuthLogout);
  }
  handleLogout() {
    ts.logout();
  }
  toggleTheme() {
    Ya.toggleTheme();
  }
  toggleLanguageMenu(e) {
    e.stopPropagation(), this.languageMenuOpen = !this.languageMenuOpen;
  }
  async selectLanguage(e) {
    await Mi.setLocale(e), this.languageMenuOpen = !1;
  }
  render() {
    return this.isAuthenticated ? D`
      <!-- App Header -->
      <header class="app-header">
        <div class="header-title">Vapor</div>
        <div class="header-actions">
          <button class="theme-toggle" @click="${this.toggleTheme}" title="${L("app.theme")}">
            ${this.currentTheme === "dark" ? D`
              <svg class="theme-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
              </svg>
            ` : D`
              <svg class="theme-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
              </svg>
            `}
          </button>
          
          <div class="language-selector">
            <button class="language-button" @click="${this.toggleLanguageMenu}" title="${L("app.language")}">
              <svg class="language-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
              </svg>
              ${this.currentLocale.toUpperCase()}
            </button>
            
            ${this.languageMenuOpen ? D`
              <div class="language-dropdown">
                <div class="language-option ${this.currentLocale === "en" ? "active" : ""}" @click="${() => this.selectLanguage("en")}">
                  English
                  ${this.currentLocale === "en" ? D`
                    <svg class="check-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                  ` : ""}
                </div>
                <div class="language-option ${this.currentLocale === "id" ? "active" : ""}" @click="${() => this.selectLanguage("id")}">
                  Bahasa Indonesia
                  ${this.currentLocale === "id" ? D`
                    <svg class="check-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                    </svg>
                  ` : ""}
                </div>
              </div>
            ` : ""}
          </div>
          
          <span class="user-info">Logged in</span>
          <button class="logout-button" @click="${this.handleLogout}">${L("app.logout")}</button>
        </div>
      </header>
      <!-- App Content -->
      <div class="app-content">
        <!-- Sidebar -->
        <sidebar-tree 
          ?collapsed="${this.sidebarCollapsed}"
          activeItemId="${this.activeView}"
          @navigate="${this.handleNavigation}"
        ></sidebar-tree>
        
        <button class="sidebar-toggle ${this.sidebarCollapsed ? "collapsed" : ""}" @click="${this.toggleSidebar}">
          ${this.sidebarCollapsed ? "" : ""}
        </button>

        <!-- Main Content -->
        <main class="main">
          <div class="tab-content">
            ${this.activeView === "dashboard" ? D`<dashboard-tab></dashboard-tab>` : ""}
            ${this.activeView === "network" ? D`<network-tab .subRoute=${this.subRoute}></network-tab>` : ""}
            ${this.activeView === "storage" ? D`<storage-tab .subRoute=${this.subRoute}></storage-tab>` : ""}
            ${this.activeView === "containers" ? D`<containers-tab></containers-tab>` : ""}
            ${this.activeView === "docker" ? D`<docker-tab .subRoute=${this.subRoute}></docker-tab>` : ""}
            ${this.activeView === "logs" ? D`<logs-tab></logs-tab>` : ""}
            ${this.activeView === "terminal" ? D`<terminal-tab></terminal-tab>` : ""}
            ${this.activeView === "users" ? D`<users-tab></users-tab>` : ""}
            ${this.activeView === "kubernetes" ? D`<kubernetes-tab .subRoute=${this.subRoute}></kubernetes-tab>` : ""}
            ${this.activeView === "ansible" ? D`<ansible-tab .subRoute=${this.subRoute}></ansible-tab>` : ""}
            ${this.isValidRoute(this.activeView) ? "" : D`<div>404 - Page Not Found</div>`}
          </div>
        </main>
      </div>
      </div>
    ` : D`<login-page></login-page>`;
  }
  toggleSidebar() {
    this.sidebarCollapsed = !this.sidebarCollapsed;
  }
  handleNavigation(e) {
    const t = e.detail.route, [i, ...r] = t.split("/");
    this.activeView = i, this.subRoute = r.length > 0 ? r.join("/") : null;
  }
  isValidRoute(e) {
    return ["dashboard", "network", "storage", "containers", "logs", "terminal", "users", "docker", "kubernetes", "ansible"].includes(e);
  }
};
Ka.styles = re`
    :host {
      display: block;
      height: 100vh;
      background-color: var(--surface-0);
      color: var(--text-primary);
      font-family: var(--font-family);
    }
  
    .app-header {
      background-color: var(--surface-1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      height: 56px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid var(--border-color);
    }
    
    .header-title {
      font-size: 1.25rem;
      font-weight: 500;
    }
    
    .header-actions {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .user-info {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }
    
    .logout-button {
      padding: 0.5rem 1rem;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .logout-button:hover {
      background: var(--surface-2);
      border-color: var(--primary);
    }

    .theme-toggle {
      padding: 0.5rem;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
    }

    .theme-toggle:hover {
      background: var(--surface-2);
      border-color: var(--primary);
    }

    .theme-icon {
      width: 20px;
      height: 20px;
    }

    .language-selector {
      position: relative;
    }

    .language-button {
      padding: 0.5rem 1rem;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .language-button:hover {
      background: var(--surface-2);
      border-color: var(--primary);
    }

    .language-icon {
      width: 16px;
      height: 16px;
    }

    .language-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 0.25rem;
      background: var(--surface-1);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 120px;
      z-index: 1000;
    }

    .language-option {
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .language-option:hover {
      background: var(--surface-2);
    }

    .language-option.active {
      background: var(--surface-3);
      color: var(--primary);
    }

    .check-icon {
      width: 14px;
      height: 14px;
      margin-left: auto;
    }

    .app-content {
      display: flex;
      height: calc(100vh - 56px);
    }

    sidebar-tree {
      width: 200px;
      background-color: var(--surface-1);
      transition: width 0.3s ease-in-out;
      border-right: 1px solid var(--border-color);
    }

    sidebar-tree[collapsed] {
      width: 60px;
    }
    
    .sidebar-toggle {
      position: absolute;
      top: 70px;
      left: 200px;
      transform: translateX(-50%);
      z-index: 10;
      padding: 0.25rem;
      background: var(--surface-1);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .sidebar-toggle:hover {
      background: var(--surface-2);
      color: var(--text-primary);
    }
    
    .sidebar-toggle.collapsed {
      left: 60px;
    }
    
    .main {
      flex: 1;
      overflow: auto;
      background-color: var(--surface-0);
      color: var(--text-primary);
      padding: 2rem;
      display: flex;
      flex-direction: column;
    }
    
    .tab-content {
      margin-top: 1rem;
      flex: 1;
      overflow: auto;
    }
  `;
let Rt = Ka;
Vs([
  B()
], Rt.prototype, "isAuthenticated");
Vs([
  B()
], Rt.prototype, "activeView");
Vs([
  B()
], Rt.prototype, "currentTheme");
Vs([
  B()
], Rt.prototype, "currentLocale");
Vs([
  B()
], Rt.prototype, "languageMenuOpen");
Vs([
  B()
], Rt.prototype, "sidebarCollapsed");
Vs([
  B()
], Rt.prototype, "subRoute");
customElements.define("app-root", Rt);
export {
  Rt as AppRoot
};
