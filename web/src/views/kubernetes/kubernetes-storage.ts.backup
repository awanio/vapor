import { LitElement, html, css } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { KubernetesApi } from '../../services/kubernetes-api.js';
import type {
  KubernetesNamespace,
  KubernetesPersistentVolume,
  KubernetesPersistentVolumeClaim,
  KubernetesResourceDetails
} from '../../services/kubernetes-api.js';
import '../../components/ui/search-input.js';
import '../../components/ui/empty-state.js';
import '../../components/ui/loading-state.js';
import '../../components/tabs/tab-group.js';
import '../../components/tables/resource-table.js';
import '../../components/drawers/detail-drawer.js';
import '../../components/modals/delete-modal.js';
import type { Tab } from '../../components/tabs/tab-group.js';
import type { Column } from '../../components/tables/resource-table.js';
import type { ActionItem } from '../../components/ui/action-dropdown.js';
import type { DeleteItem } from '../../components/modals/delete-modal.js';

/**
 * Kubernetes Storage view component
 * Manages PersistentVolumeClaims, PersistentVolumes, and StorageClasses
 */
@customElement('kubernetes-storage')
export class KubernetesStorage extends LitElement {
  static override styles = css`
    :host {
      display: block;
      height: 100%;
      background: #1a1d23;
      color: #e0e0e0;
    }

    .storage-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding: 20px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .title {
      font-size: 24px;
      font-weight: 500;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .create-button {
      background: #4a7c59;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    .create-button:hover {
      background: #5a8c69;
    }

    .content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .filters {
      display: flex;
      gap: 16px;
      margin-bottom: 20px;
      align-items: center;
    }

    .resource-count {
      font-size: 14px;
      color: #999;
      margin-left: auto;
    }

    /* Detail styles */
    .detail-content {
      padding: 20px;
    }

    .detail-content h3 {
      margin: 20px 0 10px 0;
      color: #e0e0e0;
      font-size: 16px;
      font-weight: 500;
    }

    .detail-content h3:first-child {
      margin-top: 0;
    }

    .detail-item {
      display: flex;
      padding: 8px 0;
      border-bottom: 1px solid #2a2d3a;
    }

    .detail-item .label {
      flex: 0 0 150px;
      color: #999;
      font-size: 14px;
    }

    .detail-item .value {
      flex: 1;
      color: #e0e0e0;
      font-size: 14px;
    }

    .capacity-bar {
      width: 100%;
      height: 20px;
      background: #2a2d3a;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 8px;
    }

    .capacity-fill {
      height: 100%;
      background: #4a7c59;
      transition: width 0.3s;
    }

    .capacity-text {
      font-size: 12px;
      color: #999;
      margin-top: 4px;
    }
  `;

  // Storage resource types
  @property({ type: String }) activeTab = 'pvcs';
  @property({ type: String }) namespace = 'All Namespaces';
  @property({ type: String }) searchQuery = '';
  
  @state() private loading = false;
  @state() private pvcs: any[] = [];
  @state() private pvs: any[] = [];
  @state() private storageClasses: any[] = [];
  @state() private namespaces: string[] = [];
  
  // UI state
  @state() private showDeleteModal = false;
  @state() private showDetailDrawer = false;
  @state() private showCreateDrawer = false;
  @state() private selectedResource: any = null;
  @state() private detailType = '';

  private api = new Api();

  override connectedCallback() {
    super.connectedCallback();
    this.fetchNamespaces();
    this.fetchStorageResources();
  }

  override render() {
    const tabs = [
      { id: 'pvcs', label: 'PVCs', count: this.pvcs.length },
      { id: 'pvs', label: 'PVs', count: this.pvs.length },
      { id: 'storageclasses', label: 'Storage Classes', count: this.storageClasses.length }
    ];

    return html`
      <div class="storage-container">
        <div class="header">
          <h1 class="title">Storage Resources</h1>
          <div class="controls">
            <button class="create-button" @click=${this.handleCreate}>
              Create Resource
            </button>
          </div>
        </div>

        <div class="content">
          <div class="filters">
            <namespace-dropdown
              .namespaces=${this.namespaces.map(ns => ({ name: ns }))}
              .selectedNamespace=${this.namespace}
              @namespace-change=${this.handleNamespaceChange}
            ></namespace-dropdown>

            <search-input
              .value=${this.searchQuery}
              placeholder="Search storage resources..."
              @search-change=${this.handleSearch}
            ></search-input>

            <span class="resource-count">
              ${this.getFilteredData().length} resources
            </span>
          </div>

          <tab-group
            .tabs=${tabs}
            .activeTab=${this.activeTab}
            @tab-change=${this.handleTabChange}
          ></tab-group>

          ${this.loading ? html`
            <loading-state message="Loading storage resources..."></loading-state>
          ` : this.renderContent()}
        </div>

        <delete-modal
          .show=${this.showDeleteModal}
          .item=${this.selectedResource}
          @confirm-delete=${this.handleDelete}
          @cancel-delete=${this.handleCancelDelete}
        ></delete-modal>

        <detail-drawer
          .show=${this.showDetailDrawer}
          .title=${this.getDetailTitle()}
          @close=${() => this.showDetailDrawer = false}
        >
          ${this.renderResourceDetail()}
        </detail-drawer>

        <create-resource-drawer
          .show=${this.showCreateDrawer}
          .title="Create Storage Resource"
          @close=${() => this.showCreateDrawer = false}
          @create=${this.handleCreateResource}
        ></create-resource-drawer>

        <notification-container></notification-container>
      </div>
    `;
  }

  private renderContent() {
    const data = this.getFilteredData();

    if (data.length === 0) {
      return html`
        <empty-state
          message="No ${this.activeTab} found"
          icon="storage"
        ></empty-state>
      `;
    }

    return html`
      <resource-table
        .columns=${this.getColumns()}
        .data=${data}
        .getActions=${(item: any) => this.getResourceActions(item)}
        @cell-click=${this.handleCellClick}
        @action=${this.handleAction}
      ></resource-table>
    `;
  }

  private getColumns() {
    switch (this.activeTab) {
      case 'pvcs':
        return [
          { key: 'name', label: 'Name', type: 'link' },
          { key: 'namespace', label: 'Namespace' },
          { key: 'status', label: 'Status', type: 'status' },
          { key: 'volume', label: 'Volume' },
          { key: 'capacity', label: 'Capacity' },
          { key: 'accessModes', label: 'Access Modes', type: 'custom' },
          { key: 'storageClass', label: 'Storage Class' },
          { key: 'age', label: 'Age' }
        ];
      
      case 'pvs':
        return [
          { key: 'name', label: 'Name', type: 'link' },
          { key: 'capacity', label: 'Capacity' },
          { key: 'accessModes', label: 'Access Modes', type: 'custom' },
          { key: 'reclaimPolicy', label: 'Reclaim Policy' },
          { key: 'status', label: 'Status', type: 'status' },
          { key: 'claim', label: 'Claim' },
          { key: 'storageClass', label: 'Storage Class' },
          { key: 'reason', label: 'Reason' },
          { key: 'age', label: 'Age' }
        ];
      
      case 'storageclasses':
        return [
          { key: 'name', label: 'Name', type: 'link' },
          { key: 'provisioner', label: 'Provisioner' },
          { key: 'reclaimPolicy', label: 'Reclaim Policy' },
          { key: 'volumeBindingMode', label: 'Volume Binding Mode' },
          { key: 'allowVolumeExpansion', label: 'Allow Expansion', type: 'custom' },
          { key: 'default', label: 'Default', type: 'custom' },
          { key: 'age', label: 'Age' }
        ];
      
      default:
        return [];
    }
  }

  private getFilteredData() {
    let data: any[] = [];
    
    switch (this.activeTab) {
      case 'pvcs':
        data = this.pvcs;
        break;
      case 'pvs':
        data = this.pvs;
        break;
      case 'storageclasses':
        data = this.storageClasses;
        break;
    }

    // Filter by namespace (only for PVCs)
    if (this.namespace !== 'All Namespaces' && this.activeTab === 'pvcs') {
      data = data.filter(item => item.namespace === this.namespace);
    }

    // Filter by search query
    if (this.searchQuery) {
      const query = this.searchQuery.toLowerCase();
      data = data.filter(item => 
        item.name.toLowerCase().includes(query) ||
        (item.namespace && item.namespace.toLowerCase().includes(query))
      );
    }

    return data;
  }

  private getResourceActions(item: any) {
    const actions = [
      { label: 'View Details', action: 'view' },
      { label: 'Edit', action: 'edit' }
    ];

    // Add expand action for PVCs
    if (this.activeTab === 'pvcs' && item.status === 'Bound') {
      actions.push({ label: 'Expand Volume', action: 'expand' });
    }

    actions.push({ label: 'Delete', action: 'delete', danger: true } as any);
    
    return actions;
  }

  private async fetchNamespaces() {
    try {
      const response = await this.api.get('/kubernetes/namespaces');
      this.namespaces = ['All Namespaces', ...response.items.map((ns: any) => ns.metadata.name)];
    } catch (error) {
      console.error('Failed to fetch namespaces:', error);
    }
  }

  private async fetchStorageResources() {
    this.loading = true;
    
    try {
      const [pvcs, pvs, storageClasses] = await Promise.all([
        this.api.get('/kubernetes/persistentvolumeclaims'),
        this.api.get('/kubernetes/persistentvolumes'),
        this.api.get('/kubernetes/storageclasses')
      ]);

      this.pvcs = this.processPVCs(pvcs.items || []);
      this.pvs = this.processPVs(pvs.items || []);
      this.storageClasses = this.processStorageClasses(storageClasses.items || []);
    } catch (error) {
      console.error('Failed to fetch storage resources:', error);
      this.showNotification('Failed to load storage resources', 'error');
    } finally {
      this.loading = false;
    }
  }

  private processPVCs(pvcs: any[]): any[] {
    return pvcs.map(pvc => ({
      name: pvc.metadata.name,
      namespace: pvc.metadata.namespace,
      status: pvc.status.phase,
      volume: pvc.spec.volumeName || '',
      capacity: pvc.status.capacity?.storage || pvc.spec.resources.requests.storage,
      accessModes: pvc.spec.accessModes?.join(', ') || '',
      storageClass: pvc.spec.storageClassName || '',
      age: this.getAge(pvc.metadata.creationTimestamp),
      raw: pvc
    }));
  }

  private processPVs(pvs: any[]): any[] {
    return pvs.map(pv => ({
      name: pv.metadata.name,
      capacity: pv.spec.capacity?.storage || '',
      accessModes: pv.spec.accessModes?.join(', ') || '',
      reclaimPolicy: pv.spec.persistentVolumeReclaimPolicy,
      status: pv.status.phase,
      claim: pv.spec.claimRef ? `${pv.spec.claimRef.namespace}/${pv.spec.claimRef.name}` : '',
      storageClass: pv.spec.storageClassName || '',
      reason: pv.status.reason || '',
      age: this.getAge(pv.metadata.creationTimestamp),
      raw: pv
    }));
  }

  private processStorageClasses(classes: any[]): any[] {
    return classes.map(sc => ({
      name: sc.metadata.name,
      provisioner: sc.provisioner,
      reclaimPolicy: sc.reclaimPolicy || 'Delete',
      volumeBindingMode: sc.volumeBindingMode || 'Immediate',
      allowVolumeExpansion: sc.allowVolumeExpansion || false,
      default: sc.metadata.annotations?.['storageclass.kubernetes.io/is-default-class'] === 'true',
      age: this.getAge(sc.metadata.creationTimestamp),
      raw: sc
    }));
  }

  private getAge(timestamp: string): string {
    const created = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - created.getTime();
    
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    
    if (days > 0) return `${days}d`;
    if (hours > 0) return `${hours}h`;
    return '<1h';
  }

  private handleTabChange(e: CustomEvent) {
    this.activeTab = e.detail.tabId;
  }

  private handleNamespaceChange(e: CustomEvent) {
    this.namespace = e.detail.namespace;
  }

  private handleSearch(e: CustomEvent) {
    this.searchQuery = e.detail.value;
  }

  private handleCellClick(e: CustomEvent) {
    if (e.detail.column.type === 'link') {
      this.showResourceDetail(e.detail.item);
    }
  }

  private handleAction(e: CustomEvent) {
    const { action, item } = e.detail;
    
    switch (action) {
      case 'view':
        this.showResourceDetail(item);
        break;
      case 'edit':
        this.editResource(item);
        break;
      case 'delete':
        this.confirmDelete(item);
        break;
      case 'expand':
        this.expandVolume(item);
        break;
    }
  }

  private showResourceDetail(item: any) {
    this.selectedResource = item;
    this.detailType = this.activeTab;
    this.showDetailDrawer = true;
  }

  private editResource(_item: any) {
    // TODO: Implement edit functionality
    this.showNotification('Edit functionality coming soon', 'info');
  }

  private confirmDelete(item: any) {
    this.selectedResource = item;
    this.showDeleteModal = true;
  }

  private expandVolume(_item: any) {
    // TODO: Implement volume expansion
    this.showNotification('Volume expansion coming soon', 'info');
  }

  private handleCreate() {
    this.showCreateDrawer = true;
  }

  private async handleCreateResource(e: CustomEvent) {
    const { resource } = e.detail;
    
    try {
      // TODO: Implement actual resource creation
      await this.api.post(`/kubernetes/${this.activeTab}`, resource);
      this.showNotification('Resource created successfully', 'success');
      this.showCreateDrawer = false;
      this.fetchStorageResources();
    } catch (error) {
      this.showNotification('Failed to create resource', 'error');
    }
  }

  private async handleDelete() {
    if (!this.selectedResource) return;
    
    try {
      const namespace = this.selectedResource.namespace || '';
      const name = this.selectedResource.name;
      
      await this.api.delete(`/kubernetes/${this.activeTab}/${namespace}/${name}`);
      this.showNotification(`${name} deleted successfully`, 'success');
      this.showDeleteModal = false;
      this.fetchStorageResources();
    } catch (error) {
      this.showNotification('Failed to delete resource', 'error');
    }
  }

  private handleCancelDelete() {
    this.showDeleteModal = false;
    this.selectedResource = null;
  }

  private getDetailTitle(): string {
    if (!this.selectedResource) return '';
    
    const typeMap: Record<string, string> = {
      pvcs: 'PersistentVolumeClaim',
      pvs: 'PersistentVolume',
      storageclasses: 'StorageClass'
    };
    
    return `${typeMap[this.detailType] || ''} Details: ${this.selectedResource.name}`;
  }

  private renderResourceDetail() {
    if (!this.selectedResource) return html``;
    
    switch (this.detailType) {
      case 'pvcs':
        return this.renderPVCDetail();
      case 'pvs':
        return this.renderPVDetail();
      case 'storageclasses':
        return this.renderStorageClassDetail();
      default:
        return html``;
    }
  }

  private renderPVCDetail() {
    const pvc = this.selectedResource.raw;
    
    return html`
      <div class="detail-content">
        <h3>Basic Information</h3>
        <div class="detail-item">
          <span class="label">Name:</span>
          <span class="value">${pvc.metadata.name}</span>
        </div>
        <div class="detail-item">
          <span class="label">Namespace:</span>
          <span class="value">${pvc.metadata.namespace}</span>
        </div>
        <div class="detail-item">
          <span class="label">Status:</span>
          <span class="value">
            <status-badge status=${pvc.status.phase.toLowerCase()}></status-badge>
          </span>
        </div>
        <div class="detail-item">
          <span class="label">Storage Class:</span>
          <span class="value">${pvc.spec.storageClassName || 'Default'}</span>
        </div>
        
        <h3>Capacity</h3>
        <div class="detail-item">
          <span class="label">Requested:</span>
          <span class="value">${pvc.spec.resources.requests.storage}</span>
        </div>
        ${pvc.status.capacity ? html`
          <div class="detail-item">
            <span class="label">Actual:</span>
            <span class="value">${pvc.status.capacity.storage}</span>
          </div>
        ` : ''}
        
        <h3>Access</h3>
        <div class="detail-item">
          <span class="label">Access Modes:</span>
          <span class="value">${pvc.spec.accessModes?.join(', ') || 'None'}</span>
        </div>
        <div class="detail-item">
          <span class="label">Volume Mode:</span>
          <span class="value">${pvc.spec.volumeMode || 'Filesystem'}</span>
        </div>
        
        ${pvc.spec.volumeName ? html`
          <h3>Bound Volume</h3>
          <div class="detail-item">
            <span class="label">Volume Name:</span>
            <span class="value">${pvc.spec.volumeName}</span>
          </div>
        ` : ''}
        
        ${pvc.status.conditions && pvc.status.conditions.length > 0 ? html`
          <h3>Conditions</h3>
          ${pvc.status.conditions.map((condition: any) => html`
            <div class="detail-item">
              <span class="label">${condition.type}:</span>
              <span class="value">${condition.status} - ${condition.message || 'No message'}</span>
            </div>
          `)}
        ` : ''}
      </div>
    `;
  }

  private renderPVDetail() {
    const pv = this.selectedResource.raw;
    
    return html`
      <div class="detail-content">
        <h3>Basic Information</h3>
        <div class="detail-item">
          <span class="label">Name:</span>
          <span class="value">${pv.metadata.name}</span>
        </div>
        <div class="detail-item">
          <span class="label">Status:</span>
          <span class="value">
            <status-badge status=${pv.status.phase.toLowerCase()}></status-badge>
          </span>
        </div>
        <div class="detail-item">
          <span class="label">Reclaim Policy:</span>
          <span class="value">${pv.spec.persistentVolumeReclaimPolicy}</span>
        </div>
        
        <h3>Capacity & Access</h3>
        <div class="detail-item">
          <span class="label">Capacity:</span>
          <span class="value">${pv.spec.capacity.storage}</span>
        </div>
        <div class="detail-item">
          <span class="label">Access Modes:</span>
          <span class="value">${pv.spec.accessModes?.join(', ') || 'None'}</span>
        </div>
        <div class="detail-item">
          <span class="label">Volume Mode:</span>
          <span class="value">${pv.spec.volumeMode || 'Filesystem'}</span>
        </div>
        
        ${pv.spec.claimRef ? html`
          <h3>Claim Reference</h3>
          <div class="detail-item">
            <span class="label">Namespace:</span>
            <span class="value">${pv.spec.claimRef.namespace}</span>
          </div>
          <div class="detail-item">
            <span class="label">Name:</span>
            <span class="value">${pv.spec.claimRef.name}</span>
          </div>
        ` : ''}
        
        <h3>Source</h3>
        ${this.renderPVSource(pv)}
        
        ${pv.spec.nodeAffinity ? html`
          <h3>Node Affinity</h3>
          <div class="detail-item">
            <span class="label">Required:</span>
            <span class="value">${JSON.stringify(pv.spec.nodeAffinity.required, null, 2)}</span>
          </div>
        ` : ''}
      </div>
    `;
  }

  private renderPVSource(pv: any) {
    if (pv.spec.hostPath) {
      return html`
        <div class="detail-item">
          <span class="label">Type:</span>
          <span class="value">HostPath</span>
        </div>
        <div class="detail-item">
          <span class="label">Path:</span>
          <span class="value">${pv.spec.hostPath.path}</span>
        </div>
      `;
    } else if (pv.spec.nfs) {
      return html`
        <div class="detail-item">
          <span class="label">Type:</span>
          <span class="value">NFS</span>
        </div>
        <div class="detail-item">
          <span class="label">Server:</span>
          <span class="value">${pv.spec.nfs.server}</span>
        </div>
        <div class="detail-item">
          <span class="label">Path:</span>
          <span class="value">${pv.spec.nfs.path}</span>
        </div>
      `;
    } else if (pv.spec.csi) {
      return html`
        <div class="detail-item">
          <span class="label">Type:</span>
          <span class="value">CSI</span>
        </div>
        <div class="detail-item">
          <span class="label">Driver:</span>
          <span class="value">${pv.spec.csi.driver}</span>
        </div>
        <div class="detail-item">
          <span class="label">Volume Handle:</span>
          <span class="value">${pv.spec.csi.volumeHandle}</span>
        </div>
      `;
    } else {
      return html`
        <div class="detail-item">
          <span class="label">Type:</span>
          <span class="value">Unknown</span>
        </div>
      `;
    }
  }

  private renderStorageClassDetail() {
    const sc = this.selectedResource.raw;
    
    return html`
      <div class="detail-content">
        <h3>Basic Information</h3>
        <div class="detail-item">
          <span class="label">Name:</span>
          <span class="value">${sc.metadata.name}</span>
        </div>
        <div class="detail-item">
          <span class="label">Provisioner:</span>
          <span class="value">${sc.provisioner}</span>
        </div>
        <div class="detail-item">
          <span class="label">Is Default:</span>
          <span class="value">${this.selectedResource.default ? 'Yes' : 'No'}</span>
        </div>
        
        <h3>Configuration</h3>
        <div class="detail-item">
          <span class="label">Reclaim Policy:</span>
          <span class="value">${sc.reclaimPolicy || 'Delete'}</span>
        </div>
        <div class="detail-item">
          <span class="label">Volume Binding Mode:</span>
          <span class="value">${sc.volumeBindingMode || 'Immediate'}</span>
        </div>
        <div class="detail-item">
          <span class="label">Allow Volume Expansion:</span>
          <span class="value">${sc.allowVolumeExpansion ? 'Yes' : 'No'}</span>
        </div>
        
        ${sc.parameters && Object.keys(sc.parameters).length > 0 ? html`
          <h3>Parameters</h3>
          ${Object.entries(sc.parameters).map(([key, value]) => html`
            <div class="detail-item">
              <span class="label">${key}:</span>
              <span class="value">${value}</span>
            </div>
          `)}
        ` : ''}
        
        ${sc.allowedTopologies && sc.allowedTopologies.length > 0 ? html`
          <h3>Allowed Topologies</h3>
          ${sc.allowedTopologies.map((topology: any, index: number) => html`
            <div class="detail-item">
              <span class="label">Topology ${index + 1}:</span>
              <span class="value">${JSON.stringify(topology.matchLabelExpressions)}</span>
            </div>
          `)}
        ` : ''}
      </div>
    `;
  }

  private showNotification(message: string, type: 'info' | 'success' | 'error' | 'warning' = 'info') {
    const container = this.shadowRoot?.querySelector('notification-container') as any;
    if (container) {
      container.addNotification({ type, message });
    }
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'kubernetes-storage': KubernetesStorage;
  }
}
